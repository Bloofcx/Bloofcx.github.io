

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bloo">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1uW411f72n?spm_id_from&#x3D;333.337.search-card.all.click，主要是对图做一些必要的解释，也许对你没有参考价值。。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://bloofcx.github.io/2022/04/12/os/index.html">
<meta property="og:site_name" content="Bloo">
<meta property="og:description" content="参考https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1uW411f72n?spm_id_from&#x3D;333.337.search-card.all.click，主要是对图做一些必要的解释，也许对你没有参考价值。。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314101541245.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314101702771.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314102014485.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314100629747.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314095722816.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314101327083.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314103806052.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314105742354.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314110510820.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314112645043.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314112823551.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314112916863.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314113334784.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314113712026.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314114124892.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314114350433.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314114700639.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314115723694.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314185910289.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190108570.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190325342.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190601181.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190746834.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314185630289.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314191904592.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314192233279.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314192425671.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314192743746.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314193111494.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314193313426.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314193627988.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314194436384.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195201347.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195618170.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195742024.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195837235.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200013810.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200259134.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200333132.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200523542.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200559358.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314201008316.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314201033083.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314201309131.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202303944.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202337631.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202419821.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202502565.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202745466.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202821052.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314203014295.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314203133547.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314203451738.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315101750899.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315101830624.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102008501.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102313425.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102541329.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102912248.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315103100186.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315103420007.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315103911075.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315104409112.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315104752933.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315105928232.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315110207423.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315110548448.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315110744311.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111139608.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111243805.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111540912.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111755175.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315112622166.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315113008700.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315113244873.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315113708077.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114149061.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114343276.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114439108.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114834832.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315115032588.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315115442930.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315115539550.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315140720888.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315140905840.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315141118766.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315141835271.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315141858679.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315142116822.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315142545605.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315142902768.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315143032359.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315153217040.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315144019183.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315144313435.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315144936056.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315145213412.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150017680.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150225932.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150444209.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150759529.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150904269.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151306909.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151326311.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151547725.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151852730.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151938981.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315152247073.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315152559378.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315153722011.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315154106879.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315154712009.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315155748580.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315160450793.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315160927016.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161141452.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161416331.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161656419.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161842043.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161954935.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315162336046.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315162614428.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315163836144.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315163945697.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164208803.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164331593.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164545591.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164828959.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315165622326.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315184540203.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315184709513.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315184849983.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315185637612.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315190028579.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315190220994.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315190459458.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191212264.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191508500.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191834893.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191939659.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315192455070.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315192751422.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193451486.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193645495.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193735471.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193836928.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193949135.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194216137.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194710456.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194837246.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194938881.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195043941.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195132996.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195340624.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195402683.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316104711131.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316104833846.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316104929457.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105109329.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105202344.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105421244.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105846558.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110104720.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110225989.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110446729.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110815007.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110958953.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111059671.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111213808.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111321169.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111402830.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111613746.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111849951.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316112319233.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316112357397.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316112943929.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113557923.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113706630.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113941988.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113417809.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114047677.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114323630.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114516719.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114732929.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316115003158.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316115157753.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143325894.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143400299.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143447159.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316141202432.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316141359910.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316142449864.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143133176.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143650881.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143953869.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316144140317.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316144211754.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316144400307.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316145011673.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316145619754.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316145756774.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316150049996.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316150202618.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316150400758.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316151001873.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316151159812.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316151703757.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316151912231.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316152234235.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316152332248.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316152507960.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316152722265.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316153024253.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316153144634.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316153602722.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316153941197.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316154316946.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316154537699.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316154828628.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316155114602.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316155345905.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316155707140.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316155914130.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316160256308.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316160602236.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316160928808.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316160945836.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316161240412.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316161318156.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316161719461.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316161922647.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316162042920.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316162717935.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316185003082.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316185230533.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316185424543.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316185811356.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316190356638.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316190516195.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316190535001.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316190659040.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316191815197.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316192049203.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316192258237.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316192530795.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316192758620.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316192835099.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316193051262.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316193543860.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316193619833.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316193831165.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316194110732.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316194447529.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316194725057.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316194916384.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316195257045.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316195311150.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316195417039.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316195735072.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316195935089.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316200757200.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316201303313.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316201428593.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316201644782.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316202222399.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316202307917.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316202420592.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316202729203.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316202907928.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316202931210.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316203008197.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316203608393.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316203935765.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316204006873.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316204158628.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316204436028.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316204750456.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316204802677.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316205002882.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316205439909.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317093501831.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317093551747.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317093843765.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317094030744.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317094212990.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317094402522.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317094844068.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317095123293.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317095240884.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317095517202.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317095714835.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317095803078.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317101149943.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317101356539.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317101736888.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317102204705.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317102429558.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317102751076.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317103149857.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317104010327.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317104330558.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317104818593.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317105211437.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317105659276.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317105708144.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317110148346.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317110317695.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317111345352.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317111518383.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317114116923.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317114326780.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317114655209.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317114940338.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317115221895.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317115556400.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317115649853.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317120026581.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317174222615.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317174318786.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317174628338.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317174918896.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317175128757.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317175329645.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317175636002.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317175920030.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317180158687.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317184840176.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317185151704.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317185524459.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317185722120.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317190723521.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317191007531.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317191537025.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317191623604.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317191813441.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317192032401.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317192312399.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317192837756.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317192919075.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317193159445.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317193522806.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317193854353.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317194052621.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317194436628.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317194724955.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317194936376.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317195216164.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317195613561.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317200145674.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317200750121.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317201345547.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220317201436043.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318085930854.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318090131091.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318090625347.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318091205552.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318091620719.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318091952493.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318092008662.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318092724846.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318092934188.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318093106060.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318093132432.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318093343953.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318094441978.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318094541898.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318094911813.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318095031507.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318095246411.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318095606638.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318095722807.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318095809696.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318095918007.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318100018653.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318100111196.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318100249506.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318100616756.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318100932053.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318101523946.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318102720762.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318103559456.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318103707853.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318103942389.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318105155526.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318105337112.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318105918029.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318110131277.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318110346598.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318110513636.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318110749255.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318111130240.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318111402627.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318111457035.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318111908089.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318112110916.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318112505107.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318112853605.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318112953652.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318113125505.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318113203969.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318113457887.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318113943889.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318114246021.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318114811727.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318144114875.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318144733701.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318145038802.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318145640781.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318150037321.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318150235386.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318150337122.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318150427738.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318150715435.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318150849097.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318151007899.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318151306935.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318151731931.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318151811608.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318151935490.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318152020907.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318152131908.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318152643126.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318152833224.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318153053760.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318153314140.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318153338618.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318153648848.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318153824536.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318153925945.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318154232176.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318154349159.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318154517682.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318154844102.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318154947692.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318155130911.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318155431242.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318155827444.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318155950645.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318160226944.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318160422893.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318160518959.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318160553156.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318160750317.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318160956174.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318161130204.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318161255596.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220318161355144.png">
<meta property="article:published_time" content="2022-04-12T14:24:14.000Z">
<meta property="article:modified_time" content="2022-04-12T14:28:49.935Z">
<meta property="article:author" content="Bloo">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://bloofcx.github.io/img/mac/image-20220314101541245.png">
  
  
  <title>操作系统 - Bloo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"bloofcx.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bloo | LongMayTheSunShine</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-12 22:24" pubdate>
        April 12, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      141 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统</h1>
            
            <div class="markdown-body">
              <h1 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h1><h2 id="从用户角度来看"><a href="#从用户角度来看" class="headerlink" title="从用户角度来看"></a>从用户角度来看</h2><p><img src="/img/mac/image-20220314101541245.png" srcset="/img/loading.gif" lazyload alt="image-20220314101541245"></p>
<h2 id="操作系统的层次架构"><a href="#操作系统的层次架构" class="headerlink" title="操作系统的层次架构"></a>操作系统的层次架构</h2><p><img src="/img/mac/image-20220314101702771.png" srcset="/img/loading.gif" lazyload alt="image-20220314101702771"></p>
<h2 id="os-kernel-和-shell"><a href="#os-kernel-和-shell" class="headerlink" title="os kernel 和 shell"></a>os kernel 和 shell</h2><p><img src="/img/mac/image-20220314102014485.png" srcset="/img/loading.gif" lazyload alt="image-20220314102014485"></p>
<p>shell 可以理解为操作系统提供的对外进行管理的接口。我们要学习的是操作系统的 kernel。</p>
<h2 id="kernel-要管理的硬件"><a href="#kernel-要管理的硬件" class="headerlink" title="kernel 要管理的硬件"></a>kernel 要管理的硬件</h2><p><img src="/img/mac/image-20220314100629747.png" srcset="/img/loading.gif" lazyload alt="image-20220314100629747"></p>
<h2 id="os-Kernel-的特征"><a href="#os-Kernel-的特征" class="headerlink" title="os Kernel 的特征"></a>os Kernel 的特征</h2><ul>
<li>并行：一个时间点上有多个程序执行，一般要求多核 cpu。但是 kernel 的特征是并发。并发是一段时间内有多个程序执行。</li>
<li>虚拟：操作系统将 cpu 抽象成进程，将磁盘抽象成文件，将内存抽象成地址空间。</li>
</ul>
<p><img src="/img/mac/image-20220314095722816.png" srcset="/img/loading.gif" lazyload alt="image-20220314095722816"></p>
<ul>
<li>异步：需要保证结果相同，1+1 一定也是等于 2 的。</li>
<li><img src="/img/mac/image-20220314101327083.png" srcset="/img/loading.gif" lazyload alt="image-20220314101327083"></li>
</ul>
<h2 id="操作系统需要从更高的角度来学习。"><a href="#操作系统需要从更高的角度来学习。" class="headerlink" title="操作系统需要从更高的角度来学习。"></a>操作系统需要从更高的角度来学习。</h2><p><img src="/img/mac/image-20220314103806052.png" srcset="/img/loading.gif" lazyload alt="image-20220314103806052"></p>
<h2 id="调度线程，多道程序设计，分时操作的基本介绍"><a href="#调度线程，多道程序设计，分时操作的基本介绍" class="headerlink" title="调度线程，多道程序设计，分时操作的基本介绍"></a>调度线程，多道程序设计，分时操作的基本介绍</h2><p>我们知道，io 的效率远远低于 cpu 的效率，当 cpu read disk 的时候，可以去执行其他程序。这是多道程序设计。</p>
<p><img src="/img/mac/image-20220314105742354.png" srcset="/img/loading.gif" lazyload alt="image-20220314105742354"></p>
<p>分时操作的时间，把每个程序持有时间片的时间大大减少，如千分之一秒，随后不断的打断程序。</p>
<p>分时操作的好处：</p>
<p><img src="/img/mac/image-20220314110510820.png" srcset="/img/loading.gif" lazyload alt="image-20220314110510820"></p>
<h1 id="第二课-启动，中断，异常和系统调用"><a href="#第二课-启动，中断，异常和系统调用" class="headerlink" title="第二课-启动，中断，异常和系统调用"></a>第二课-启动，中断，异常和系统调用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>Bootloader 的作用:加载 os 到内存中</p>
<p>bios 是用来对一些硬件的处理</p>
<p><img src="/img/mac/image-20220314112645043.png" srcset="/img/loading.gif" lazyload alt="image-20220314112645043"></p>
<h3 id="启动的过程"><a href="#启动的过程" class="headerlink" title="启动的过程"></a>启动的过程</h3><p>x86 架构中，bios 从如图所示的这个地址开始执行</p>
<p><img src="/img/mac/image-20220314112823551.png" srcset="/img/loading.gif" lazyload alt="image-20220314112823551"></p>
<p>Bios 自检，加载硬件驱动</p>
<p><img src="/img/mac/image-20220314112916863.png" srcset="/img/loading.gif" lazyload alt="image-20220314112916863"></p>
<p>自检后，将 boot loader 从硬盘的第一个扇区加载到内存。boot loader 又接着把 os 从硬盘加载到内存中。</p>
<p><img src="/img/mac/image-20220314113334784.png" srcset="/img/loading.gif" lazyload alt="image-20220314113334784"></p>
<h2 id="系统调用，中断，异常"><a href="#系统调用，中断，异常" class="headerlink" title="系统调用，中断，异常"></a>系统调用，中断，异常</h2><h3 id="os-分别与硬件和程序打交道有以下几种形式："><a href="#os-分别与硬件和程序打交道有以下几种形式：" class="headerlink" title="os 分别与硬件和程序打交道有以下几种形式："></a>os 分别与硬件和程序打交道有以下几种形式：</h3><ul>
<li>对硬件采用中断</li>
<li>对应用程序采用系统调用和异常</li>
</ul>
<h3 id="他们的定义："><a href="#他们的定义：" class="headerlink" title="他们的定义："></a>他们的定义：</h3><p>异常是应用程序意想不到的行为，或者是恶意程序，又或是程序的资源得不到满足，这都应该被操作系统及时发现；</p>
<p><img src="/img/mac/image-20220314113712026.png" srcset="/img/loading.gif" lazyload alt="image-20220314113712026"></p>
<h3 id="为什么应用程序不能直接和硬件打交道？"><a href="#为什么应用程序不能直接和硬件打交道？" class="headerlink" title="为什么应用程序不能直接和硬件打交道？"></a>为什么应用程序不能直接和硬件打交道？</h3><p>应用程序可能不被信任；操作系统封装了对 device 的操作，只开放接口，不用关注硬件的细节；</p>
<p><img src="/img/mac/image-20220314114124892.png" srcset="/img/loading.gif" lazyload alt="image-20220314114124892"></p>
<h3 id="系统调用-中断-异常的特点和差异"><a href="#系统调用-中断-异常的特点和差异" class="headerlink" title="系统调用/中断/异常的特点和差异"></a>系统调用/中断/异常的特点和差异</h3><ul>
<li>产生的源头不同</li>
</ul>
<p><img src="/img/mac/image-20220314114350433.png" srcset="/img/loading.gif" lazyload alt="image-20220314114350433"></p>
<ul>
<li>处理时间</li>
</ul>
<p>异步是当事件产生的时候，应用程序根本不知道什么时候会产生；</p>
<p>异常是同步的，异常的指令触发了系统调用的请求，指令的位置是一个同步的时间点，是同步的；</p>
<p>系统调用中，返回结果的这个时间可能是同步（应用程序等待结果）；也可能是异步（应用程序接着去干其他事，然后 os 会发一个异步的消息告诉应用程序我事干完了）；请求调用的这个时间点是同步的。</p>
<p><img src="/img/mac/image-20220314114700639.png" srcset="/img/loading.gif" lazyload alt="image-20220314114700639"></p>
<ul>
<li>响应</li>
</ul>
<p><img src="/img/mac/image-20220314115723694.png" srcset="/img/loading.gif" lazyload alt="image-20220314115723694"></p>
<h3 id="中断和异常的处理机制"><a href="#中断和异常的处理机制" class="headerlink" title="中断和异常的处理机制"></a>中断和异常的处理机制</h3><h4 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h4><p><img src="/img/mac/image-20220314185910289.png" srcset="/img/loading.gif" lazyload alt="image-20220314185910289"></p>
<p>cpu 根据这个标记能够生成一个中断号，将其发给 os，os 根据中断号来进行处理。</p>
<p><img src="/img/mac/image-20220314190108570.png" srcset="/img/loading.gif" lazyload alt="image-20220314190108570"></p>
<p>可以看到对程序是透明的。</p>
<h4 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h4><p><img src="/img/mac/image-20220314190325342.png" srcset="/img/loading.gif" lazyload alt="image-20220314190325342"></p>
<p>发生异常后，也会产生一个异常编号，和上面中断的情况是类似的。如果异常处理中是重新执行异常指令，那么这个行为对程序来说也是透明的。</p>
<h3 id="系统调用的执行过程"><a href="#系统调用的执行过程" class="headerlink" title="系统调用的执行过程"></a>系统调用的执行过程</h3><p>简单的例子：os 开放一个接口给程序。</p>
<p><img src="/img/mac/image-20220314190601181.png" srcset="/img/loading.gif" lazyload alt="image-20220314190601181"></p>
<p><img src="/img/mac/image-20220314190746834.png" srcset="/img/loading.gif" lazyload alt="image-20220314190746834"></p>
<p><img src="/img/mac/image-20220314185630289.png" srcset="/img/loading.gif" lazyload alt="image-20220314185630289"></p>
<p>app 应用程序通过 library code 直接或者间接访问系统调用的接口，同时完成用户态转变内核态。</p>
<p>用户态：无法执行特权指令和 io 指令，无法控制计算机系统。</p>
<p>内核态：可以执行任意一个 os 指令。</p>
<p>开销：因为要完成堆栈的切换和特权级的转换，所以调用操作系统接口比普通函数的执行开销要更大。</p>
<h2 id="跨越操作系统边界的开销"><a href="#跨越操作系统边界的开销" class="headerlink" title="跨越操作系统边界的开销"></a>跨越操作系统边界的开销</h2><p><img src="/img/mac/image-20220314191904592.png" srcset="/img/loading.gif" lazyload alt="image-20220314191904592"></p>
<p>保证了应用程序在安全可靠的环境中执行，开销是值得的。</p>
<h1 id="第三课-操作系统管理物理内存"><a href="#第三课-操作系统管理物理内存" class="headerlink" title="第三课 操作系统管理物理内存"></a>第三课 操作系统管理物理内存</h1><h2 id="计算机体系结构-内存分层体系"><a href="#计算机体系结构-内存分层体系" class="headerlink" title="计算机体系结构/内存分层体系"></a>计算机体系结构/内存分层体系</h2><p><img src="/img/mac/image-20220314192233279.png" srcset="/img/loading.gif" lazyload alt="image-20220314192233279"></p>
<p>cpu 要访问的指令在什么地方</p>
<ul>
<li><p>L1 L2 Cache - cpu 内部。缓存小，高速</p>
</li>
<li><p>主存 速度相对 cache 慢，内存大</p>
</li>
</ul>
<p><img src="/img/mac/image-20220314192425671.png" srcset="/img/loading.gif" lazyload alt="image-20220314192425671"></p>
<p>操作系统内核做的事情-4 个。</p>
<p><img src="/img/mac/image-20220314192743746.png" srcset="/img/loading.gif" lazyload alt="image-20220314192743746"></p>
<p>内存不够的时候，会把不常用的数据临时的放在磁盘上，变成虚拟内存。</p>
<p><img src="/img/mac/image-20220314193111494.png" srcset="/img/loading.gif" lazyload alt="image-20220314193111494"></p>
<h2 id="地址空间-amp-地址生成"><a href="#地址空间-amp-地址生成" class="headerlink" title="地址空间&amp;地址生成"></a>地址空间&amp;地址生成</h2><h3 id="地址空间定义"><a href="#地址空间定义" class="headerlink" title="地址空间定义"></a>地址空间定义</h3><p>物理地址空间，主存上相应的位置</p>
<p>逻辑地址空间-&gt;应用程序看到的一个一维的地址空间，是易于访问的。</p>
<p>操作系统：逻辑地址空间会由 os 映射到物理地址空间上。</p>
<p><img src="/img/mac/image-20220314193313426.png" srcset="/img/loading.gif" lazyload alt="image-20220314193313426"></p>
<h3 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h3><h4 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h4><p>c 程序，汇编中函数的位置，变量的名字就是逻辑地址。他是一个便于用户理解的地址。</p>
<p><img src="/img/mac/image-20220314193627988.png" srcset="/img/loading.gif" lazyload alt="image-20220314193627988"></p>
<p>.o 文件中，把逻辑地址改为相对从 0 开始的地址。链接过程把多个.o 文件的合成一个.exe 文件。放在硬盘中的 exe 还要通过 loader 程序加载到内存中，图中最后一个图还有一个相应的偏移量。到这里为止都还是逻辑地址，是应用程序看到的地址。</p>
<p>总结：编译器把基于符号的地址空间变成基于逻辑地址的地址空间，操作系统可以进一步完成逻辑地址到物理地址的映射。</p>
<h4 id="物理地址生成"><a href="#物理地址生成" class="headerlink" title="物理地址生成"></a>物理地址生成</h4><p>1:cpu 把指令取出来，他的 ALU 部件需要参数，所以把指令中的逻辑地址交给 MMU。</p>
<p>2:MMU 根据地址转换表来查逻辑地址对应的物理地址，如果有那就返回；</p>
<p>3:如果没有，就会去内存中的 map 中找，如果找到了，cpu 就给主存发信息表示我要某个物理地址的内容，</p>
<p>4:内存把该内容通过总线传给 cpu。</p>
<p>操作系统在其中的作用：在这四步之前，生成逻辑地址和物理地址转换表。</p>
<p><img src="/img/mac/image-20220314194436384.png" srcset="/img/loading.gif" lazyload alt="image-20220314194436384"></p>
<h3 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h3><p><img src="/img/mac/image-20220314195201347.png" srcset="/img/loading.gif" lazyload alt="image-20220314195201347"></p>
<p>操作系统确保每一个程序可以访问的地址空间，包括起始地址和长度，如果超过这块空间，就会报 system memory error</p>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><img src="/img/mac/image-20220314195618170.png" srcset="/img/loading.gif" lazyload alt="image-20220314195618170"></p>
<p><img src="/img/mac/image-20220314195742024.png" srcset="/img/loading.gif" lazyload alt="image-20220314195742024"></p>
<h4 id="首次适配算法"><a href="#首次适配算法" class="headerlink" title="首次适配算法"></a>首次适配算法</h4><p><img src="/img/mac/image-20220314195837235.png" srcset="/img/loading.gif" lazyload alt="image-20220314195837235"></p>
<p>可用空闲空间分别是 1k 2k 500 bytes</p>
<p><img src="/img/mac/image-20220314200013810.png" srcset="/img/loading.gif" lazyload alt="image-20220314200013810"></p>
<p>优点</p>
<ul>
<li>简单</li>
<li>易于产生更大空闲块，向着地址空间的结尾</li>
</ul>
<p>劣势</p>
<ul>
<li>外部碎片 多次使用之后更为明显</li>
<li>不确定性</li>
</ul>
<h4 id="最优适配算法"><a href="#最优适配算法" class="headerlink" title="最优适配算法"></a>最优适配算法</h4><p><img src="/img/mac/image-20220314200259134.png" srcset="/img/loading.gif" lazyload alt="image-20220314200259134"></p>
<p>可以看出，空闲的 100 很难再被使用到了。</p>
<p><img src="/img/mac/image-20220314200333132.png" srcset="/img/loading.gif" lazyload alt="image-20220314200333132"></p>
<h4 id="最差适配算法"><a href="#最差适配算法" class="headerlink" title="最差适配算法"></a>最差适配算法</h4><p><img src="/img/mac/image-20220314200523542.png" srcset="/img/loading.gif" lazyload alt="image-20220314200523542"></p>
<p><img src="/img/mac/image-20220314200559358.png" srcset="/img/loading.gif" lazyload alt="image-20220314200559358"></p>
<p>三个算法总结：三个算法里，没有最好的。每个应用程序不同，需求也不同，是随机的可变的。不论哪种算法，都会产生内/外碎片。</p>
<p>这三种的办法产生的碎片如何处理？下面介绍 2 种</p>
<h4 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h4><p><img src="/img/mac/image-20220314201008316.png" srcset="/img/loading.gif" lazyload alt="image-20220314201008316"></p>
<p>紧致的方式，把内存空间压缩</p>
<p><img src="/img/mac/image-20220314201033083.png" srcset="/img/loading.gif" lazyload alt="image-20220314201033083"></p>
<p>什么时候做这个行为？</p>
<p>把程序从一个地方挪到另一个地方。</p>
<p>开销如何？</p>
<p>频繁的拷贝，开销是很大的。</p>
<h4 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h4><p><img src="/img/mac/image-20220314201309131.png" srcset="/img/loading.gif" lazyload alt="image-20220314201309131"></p>
<p>这时 p3 需要更多的内存，把 p4 所占的 memory 暂时放到 disk 上，让 p3 正常执行。</p>
<p>问题</p>
<p>把哪一个程序换出去？</p>
<p>什么时候换入换出？</p>
<p>开销？</p>
<p>换入换出是以一个程序为粒度，开销也是很大的。</p>
<h1 id="第四课-非连续内存管理"><a href="#第四课-非连续内存管理" class="headerlink" title="第四课 非连续内存管理"></a>第四课 非连续内存管理</h1><h2 id="为什么需要非连续内存"><a href="#为什么需要非连续内存" class="headerlink" title="为什么需要非连续内存"></a>为什么需要非连续内存</h2><p><img src="/img/mac/image-20220314202303944.png" srcset="/img/loading.gif" lazyload alt="image-20220314202303944"></p>
<p><img src="/img/mac/image-20220314202337631.png" srcset="/img/loading.gif" lazyload alt="image-20220314202337631"></p>
<p>解决内外碎片等等。</p>
<p><img src="/img/mac/image-20220314202419821.png" srcset="/img/loading.gif" lazyload alt="image-20220314202419821"></p>
<p>软件的开销较大，考虑硬件。</p>
<h2 id="如何管理非连续内存"><a href="#如何管理非连续内存" class="headerlink" title="如何管理非连续内存"></a>如何管理非连续内存</h2><p><img src="/img/mac/image-20220314202502565.png" srcset="/img/loading.gif" lazyload alt="image-20220314202502565"></p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h4><p><img src="/img/mac/image-20220314202745466.png" srcset="/img/loading.gif" lazyload alt="image-20220314202745466"></p>
<p>应用程序自己往往也会有多个不同的逻辑段。</p>
<p>比如 jvm 中，也有 heap，stack，native stack，pc register，method area 多个不同的段。</p>
<p>可以把他们相应的分离出来。</p>
<p><img src="/img/mac/image-20220314202821052.png" srcset="/img/loading.gif" lazyload alt="image-20220314202821052"></p>
<p>左边是连续的虚拟地址，右边是</p>
<p>不连续的物理地址。</p>
<p><img src="/img/mac/image-20220314203014295.png" srcset="/img/loading.gif" lazyload alt="image-20220314203014295"></p>
<h4 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><p>段访问机制，用硬件来实现</p>
<p><img src="/img/mac/image-20220314203133547.png" srcset="/img/loading.gif" lazyload alt="image-20220314203133547"></p>
<p>从一维的逻辑地址空间通过段访问机制映射到不同的物理地址中去。而这些物理地址是由不同的段组成的。</p>
<p>硬件实现方案</p>
<p><img src="/img/mac/image-20220314203451738.png" srcset="/img/loading.gif" lazyload alt="image-20220314203451738"></p>
<p>其中段号就等于段表的索引，即 segment num。段表中包含了物理地址的起始位置和长度，从而确定相应的段在物理地址中的哪一块，如果不在合法的范围内，cpu 就会报一个异常让操作系统来 kill 或者重新执行该指令。</p>
<p>其中关键的是，这个段表就是由操作系统来生成的。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>目前主流的机制，分段已经用的很少了。现在往往都是以分页的形式来解决非连续内存管理。</p>
<h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>页的大小往往是固定不变的。</p>
<p><img src="/img/mac/image-20220315101750899.png" srcset="/img/loading.gif" lazyload alt="image-20220315101750899"></p>
<p>逻辑页和物理页的大小是相等的。</p>
<p><img src="/img/mac/image-20220315101830624.png" srcset="/img/loading.gif" lazyload alt="image-20220315101830624"></p>
<h5 id="物理地址页帧"><a href="#物理地址页帧" class="headerlink" title="物理地址页帧"></a>物理地址页帧</h5><p><img src="/img/mac/image-20220315102008501.png" srcset="/img/loading.gif" lazyload alt="image-20220315102008501"></p>
<p>9bit 是页帧内的偏移，7 个 bit 是帧号的大小</p>
<p><img src="/img/mac/image-20220315102313425.png" srcset="/img/loading.gif" lazyload alt="image-20220315102313425"></p>
<h5 id="逻辑地址页-page"><a href="#逻辑地址页-page" class="headerlink" title="逻辑地址页 page"></a>逻辑地址页 page</h5><p><img src="/img/mac/image-20220315102541329.png" srcset="/img/loading.gif" lazyload alt="image-20220315102541329"></p>
<p>计算过程和物理地址是一样的。</p>
<h4 id="页寻址方案"><a href="#页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案</h4><p>页号作为索引查找 page table 页表，page table 里面的内容是帧号。</p>
<p>得到帧号后，再加上偏移地址就能得到物理地址。</p>
<p>类似的，页表也是由操作系统来生成的。</p>
<p><img src="/img/mac/image-20220315102912248.png" srcset="/img/loading.gif" lazyload alt="image-20220315102912248"></p>
<p>注：逻辑地址的页和页帧大小一致，但逻辑地址更大，后面会介绍虚拟内存来解决二者大小不一致问题。</p>
<p><img src="/img/mac/image-20220315103100186.png" srcset="/img/loading.gif" lazyload alt="image-20220315103100186"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="页表-pagetable-的结构和优化"><a href="#页表-pagetable-的结构和优化" class="headerlink" title="页表 pagetable 的结构和优化"></a>页表 pagetable 的结构和优化</h3><p><img src="/img/mac/image-20220315103420007.png" srcset="/img/loading.gif" lazyload alt="image-20220315103420007"></p>
<p>其中 flags 包括这个物理页帧是否存在，是否写过读过等。后面会再具体介绍。</p>
<p>逻辑地址空间有 16bit，64kb，而物理地址只有 32kb。所以，物理页帧无法和逻辑页一一对应。</p>
<p>resident bit 为 0 表示对应的物理页帧在内存中不存在，如果被 cpu 访问了会报异常。</p>
<p><img src="/img/mac/image-20220315103911075.png" srcset="/img/loading.gif" lazyload alt="image-20220315103911075"></p>
<p>页表还存在的问题：</p>
<p>1.空间，越小越好</p>
<p>2.时间，越快越好</p>
<p>如果页表太大，cpu cache 放不下，将会放在内存中，造成 2 次内存访问</p>
<p>间接访问，也是解决空间问题，类似于索引机制。</p>
<p><img src="/img/mac/image-20220315104409112.png" srcset="/img/loading.gif" lazyload alt="image-20220315104409112"></p>
<h4 id="性能优化之时间：tlb"><a href="#性能优化之时间：tlb" class="headerlink" title="性能优化之时间：tlb"></a>性能优化之时间：tlb</h4><p><img src="/img/mac/image-20220315104752933.png" srcset="/img/loading.gif" lazyload alt="image-20220315104752933"></p>
<p>Tlb 存在于 cpu 上的 mmu 内存访问单元</p>
<p>他是一个 key value 的快表。</p>
<p>存的是 p 和 f，对应的是页号和帧号。</p>
<p>如果 tlb 命中，返回。</p>
<p>如果 tlb miss 未命中，查 pagetable，将其放入 tlb，返回。x86 架构中，这个行为是硬件自身完成的；mips 架构是由操作系统来完成，也就是软件支撑。</p>
<h4 id="性能优化之空间：二级页表"><a href="#性能优化之空间：二级页表" class="headerlink" title="性能优化之空间：二级页表"></a>性能优化之空间：二级页表</h4><p>一级页表存的是第二级页表的起始地址，这个地址再跟 p2 进行相加作为索引去二级页表中查找相应的值，得到 frame number。</p>
<p><img src="/img/mac/image-20220315105928232.png" srcset="/img/loading.gif" lazyload alt="image-20220315105928232"></p>
<p>多次查找开销不是很大吗？</p>
<p>一级页表中，如果 resident 标志位为 0，二级页表中根本不需要存在。这就省了很多空间，尤其是在多级页表的情况下。</p>
<p>推广到多级页表：</p>
<p><img src="/img/mac/image-20220315110207423.png" srcset="/img/loading.gif" lazyload alt="image-20220315110207423"></p>
<p>典型的以时间换取空间。</p>
<h4 id="性能优化之空间：反向页表"><a href="#性能优化之空间：反向页表" class="headerlink" title="性能优化之空间：反向页表"></a>性能优化之空间：反向页表</h4><p>因为之前介绍的页表的大小均和逻辑地址大小挂钩，但是逻辑地址比较大，也就造成了页表很大。</p>
<p>有没有办法让页表和物理地址挂钩？让索引变成帧号，内容成为页号。</p>
<p><img src="/img/mac/image-20220315110548448.png" srcset="/img/loading.gif" lazyload alt="image-20220315110548448"></p>
<p>需要解决的问题，我们 cpu 得到的是逻辑页号，怎么解决和帧号的对应。</p>
<p>页寄存器</p>
<p><img src="/img/mac/image-20220315110744311.png" srcset="/img/loading.gif" lazyload alt="image-20220315110744311"></p>
<p>关联内存</p>
<p><img src="/img/mac/image-20220315111139608.png" srcset="/img/loading.gif" lazyload alt="image-20220315111139608"></p>
<p><img src="/img/mac/image-20220315111243805.png" srcset="/img/loading.gif" lazyload alt="image-20220315111243805"></p>
<p>哈希 table</p>
<p><img src="/img/mac/image-20220315111540912.png" srcset="/img/loading.gif" lazyload alt="image-20220315111540912"></p>
<p>存在 hash 碰撞问题</p>
<p><img src="/img/mac/image-20220315111755175.png" srcset="/img/loading.gif" lazyload alt="image-20220315111755175"></p>
<h1 id="第五课-虚拟内存"><a href="#第五课-虚拟内存" class="headerlink" title="第五课 虚拟内存"></a>第五课 虚拟内存</h1><p><img src="/img/mac/image-20220315112622166.png" srcset="/img/loading.gif" lazyload alt="image-20220315112622166"></p>
<p>越快的存储器离 cpu 越近。</p>
<p><img src="/img/mac/image-20220315113008700.png" srcset="/img/loading.gif" lazyload alt="image-20220315113008700"></p>
<p><img src="/img/mac/image-20220315113244873.png" srcset="/img/loading.gif" lazyload alt="image-20220315113244873"></p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>覆盖：把常用的代码放到内存中，不用的先放到硬盘中；需要的时候再拿出，进行一个覆盖。</p>
<p>早期微软的 dos 系统就是采用覆盖技术 80 - 90 年代。</p>
<p><img src="/img/mac/image-20220315113708077.png" srcset="/img/loading.gif" lazyload alt="image-20220315113708077"></p>
<p>没有相关调用关系的代码块先放到硬盘。a-b,a-c 的例子。</p>
<p><img src="/img/mac/image-20220315114149061.png" srcset="/img/loading.gif" lazyload alt="image-20220315114149061"></p>
<p>另一种调用关系、覆盖方法：</p>
<p>可以看到，通过程序员的安排，把空间用到极致。</p>
<p><img src="/img/mac/image-20220315114343276.png" srcset="/img/loading.gif" lazyload alt="image-20220315114343276"></p>
<p>缺点：</p>
<p>覆盖关系不好确定</p>
<p>频繁换入换出开销大</p>
<p><img src="/img/mac/image-20220315114439108.png" srcset="/img/loading.gif" lazyload alt="image-20220315114439108"></p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>unix 早期提出的方法。</p>
<p>交换：把不常用的程序放到硬盘里，把内存空间让出来，让正在运行的程序有更大的内存可以使用。<img src="/img/mac/image-20220315114834832.png" srcset="/img/loading.gif" lazyload alt="image-20220315114834832"></p>
<p><img src="/img/mac/image-20220315115032588.png" srcset="/img/loading.gif" lazyload alt="image-20220315115032588"></p>
<p>实现过程中的问题：</p>
<p><img src="/img/mac/image-20220315115442930.png" srcset="/img/loading.gif" lazyload alt="image-20220315115442930"></p>
<p>重定位：可能换出的那个时候的地址已经被占用了，换入的时候地址又要重新考虑</p>
<p>覆盖和交换的比较：</p>
<p><img src="/img/mac/image-20220315115539550.png" srcset="/img/loading.gif" lazyload alt="image-20220315115539550"></p>
<h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2><p>虚拟内存管理技术。</p>
<p>前面介绍的覆盖和交换都存在一些弊端。</p>
<p>一个增加程序员负担，一个粒度太大导致开销大。</p>
<p><img src="/img/mac/image-20220315140720888.png" srcset="/img/loading.gif" lazyload alt="image-20220315140720888"></p>
<p>让粒度更小，并且带有覆盖的特征。</p>
<p><img src="/img/mac/image-20220315140905840.png" srcset="/img/loading.gif" lazyload alt="image-20220315140905840"></p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>为了让内存管理完全依赖于 os，需要程序带有局部性。</p>
<p><img src="/img/mac/image-20220315141118766.png" srcset="/img/loading.gif" lazyload alt="image-20220315141118766"></p>
<p><img src="/img/mac/image-20220315141835271.png" srcset="/img/loading.gif" lazyload alt="image-20220315141835271"></p>
<p>一个例子：每页大小 4k,内存也定为 4k。1024 * 4byte = 4k</p>
<p><img src="/img/mac/image-20220315141858679.png" srcset="/img/loading.gif" lazyload alt="image-20220315141858679"></p>
<p>缺页异常：要频繁的把每个页都读取到内存中。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>操作系统可以在分段和分页的基础之上，来进行虚存管理</p>
<p><img src="/img/mac/image-20220315142116822.png" srcset="/img/loading.gif" lazyload alt="image-20220315142116822"></p>
<h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p><img src="/img/mac/image-20220315142545605.png" srcset="/img/loading.gif" lazyload alt="image-20220315142545605"></p>
<p>程序是感觉不到内存的具体大小的，处理过程都给 os 来执行，程序会感受到自己可用的空间是足够的。</p>
<p>交换的粒度相对于交换技术来说更小。</p>
<p>换入换出的机制，可能 os 会把虚拟地址空间中连续的代码换出。</p>
<h3 id="虚拟页式内存管理"><a href="#虚拟页式内存管理" class="headerlink" title="虚拟页式内存管理"></a>虚拟页式内存管理</h3><p><img src="/img/mac/image-20220315142902768.png" srcset="/img/loading.gif" lazyload alt="image-20220315142902768"></p>
<p>其中 resident 在接下来的管理有关键作用。</p>
<p><img src="/img/mac/image-20220315143032359.png" srcset="/img/loading.gif" lazyload alt="image-20220315143032359"></p>
<p>上图的请求调用机制就是由 resident bit 来实现的。</p>
<p>页面置换：需要一些算法，把不常用的页帧换出，后面介绍。</p>
<p>页表结构再深入</p>
<p><img src="/img/mac/image-20220315153217040.png" srcset="/img/loading.gif" lazyload alt="image-20220315153217040"></p>
<p>修改位：代表这个页是否被写过。被写过后内存和磁盘的数据是不一致的，需要刷盘。</p>
<p>驻留位：resident，已经介绍过。</p>
<p>Mov reg,0</p>
<p>0 对应的页帧是 2，通过计算公式</p>
<p>2*页大小 4k + 偏移 = 8192，得到对应的物理地址 8192。</p>
<p>mov reg 32768，对应第 8 位，驻留位是 0 的情况，发生缺页中断。需要操作系统把页从外存中调入。</p>
<p><img src="/img/mac/image-20220315144019183.png" srcset="/img/loading.gif" lazyload alt="image-20220315144019183"></p>
<p>缺页中断执行流程：</p>
<p><img src="/img/mac/image-20220315144313435.png" srcset="/img/loading.gif" lazyload alt="image-20220315144313435"></p>
<p>内存的各个段在外存中的存储形式：后备存储</p>
<p><img src="/img/mac/image-20220315144936056.png" srcset="/img/loading.gif" lazyload alt="image-20220315144936056"></p>
<h3 id="虚拟内存性能"><a href="#虚拟内存性能" class="headerlink" title="虚拟内存性能"></a>虚拟内存性能</h3><p><img src="/img/mac/image-20220315145213412.png" srcset="/img/loading.gif" lazyload alt="image-20220315145213412"></p>
<p>p ： 缺页的比例</p>
<p>q ： 进行了写操作的页</p>
<p>1+q：因为是脏页要写入磁盘，又要多访问一次磁盘。</p>
<p>如果程序有局部性原理，产生缺页的情况就会大大减少，让效率更高。</p>
<h1 id="第六课-页面置换算法"><a href="#第六课-页面置换算法" class="headerlink" title="第六课 页面置换算法"></a>第六课 页面置换算法</h1><h2 id="功能目标"><a href="#功能目标" class="headerlink" title="功能目标"></a>功能目标</h2><p>磁盘 io 的开销是比较高的，尽量少换入换出。</p>
<p><img src="/img/mac/image-20220315150017680.png" srcset="/img/loading.gif" lazyload alt="image-20220315150017680"></p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>我们可以直接不考虑偏移，因为要研究的页的换入换出，只考虑页号。</p>
<p><img src="/img/mac/image-20220315150225932.png" srcset="/img/loading.gif" lazyload alt="image-20220315150225932"></p>
<h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换"><a href="#最优页面置换" class="headerlink" title="最优页面置换"></a>最优页面置换</h3><p>不太现实，但是可以作为其他算法的评判标准。其他算法越逼近他，效果就越好。</p>
<p><img src="/img/mac/image-20220315150444209.png" srcset="/img/loading.gif" lazyload alt="image-20220315150444209"></p>
<p>Requests：当前时间轴下要访问的页</p>
<p>总共有四个页帧，五个页，所以会发生页替换。</p>
<p>第一次访问 e 的时候发生缺页，需要用算法计算。</p>
<p><img src="/img/mac/image-20220315150759529.png" srcset="/img/loading.gif" lazyload alt="image-20220315150759529"></p>
<h3 id="先进先出算法-fifo"><a href="#先进先出算法-fifo" class="headerlink" title="先进先出算法 fifo"></a>先进先出算法 fifo</h3><p>belady 现象，你给他的物理页帧越多，反而缺页情况也越多。</p>
<p><img src="/img/mac/image-20220315150904269.png" srcset="/img/loading.gif" lazyload alt="image-20220315150904269"></p>
<p><img src="/img/mac/image-20220315151306909.png" srcset="/img/loading.gif" lazyload alt="image-20220315151306909"></p>
<p><img src="/img/mac/image-20220315151326311.png" srcset="/img/loading.gif" lazyload alt="image-20220315151326311"></p>
<p>实现简单，但缺页次数多。</p>
<h3 id="最近最久未使用算法-lru"><a href="#最近最久未使用算法-lru" class="headerlink" title="最近最久未使用算法 lru"></a>最近最久未使用算法 lru</h3><p>least recently used</p>
<p>他是根据过去很长时间都没访问过的页面，来推测未来。最优页面置换是根据未来来推测未来。</p>
<p><img src="/img/mac/image-20220315151547725.png" srcset="/img/loading.gif" lazyload alt="image-20220315151547725"></p>
<p>实验过程：</p>
<p><img src="/img/mac/image-20220315151852730.png" srcset="/img/loading.gif" lazyload alt="image-20220315151852730"></p>
<p><img src="/img/mac/image-20220315151938981.png" srcset="/img/loading.gif" lazyload alt="image-20220315151938981"></p>
<p>lru 维护各个页面的使用时间：</p>
<p>链表 - 头插法，最近使用的成为链首，每次剔除的时候选择链尾。</p>
<p>栈，最近使用的页压入栈中，每次剔除的时候从栈尾中弹出。</p>
<p><img src="/img/mac/image-20220315152247073.png" srcset="/img/loading.gif" lazyload alt="image-20220315152247073"></p>
<p>虽然解决缺页效果不错，但是开销比较大，因为每次都要遍历链表或者栈看看页帧是否在里面。</p>
<p><img src="/img/mac/image-20220315152559378.png" srcset="/img/loading.gif" lazyload alt="image-20220315152559378"></p>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>访问位 置 1 是由硬件来完成的，但是软件可以对其修改。</p>
<p>当页帧最近被访问过，访问位置 1。</p>
<p><img src="/img/mac/image-20220315153722011.png" srcset="/img/loading.gif" lazyload alt="image-20220315153722011"></p>
<p>环形链表的维护：</p>
<p><img src="/img/mac/image-20220315154106879.png" srcset="/img/loading.gif" lazyload alt="image-20220315154106879"></p>
<p>当发生了缺页，从当前指针开始遍历，如果是访问位是 1，就将其变 0；直到找到访问位为 0 的页，将其替换。</p>
<p>实验过程：</p>
<p><img src="/img/mac/image-20220315154712009.png" srcset="/img/loading.gif" lazyload alt="image-20220315154712009"></p>
<h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p>在 clock 的基础上，多判断一个 dirty bit（是否写过该页）</p>
<p><img src="/img/mac/image-20220315155748580.png" srcset="/img/loading.gif" lazyload alt="image-20220315155748580"></p>
<p>两个 bit，四种情况。</p>
<p>如果写入过某个页，两个 bit 都会变成 1；第一次遍历到这个页的时候变成 0 1，第二次再变成 0 0；再下一次 replace。</p>
<p>所以被写入过的页，被换出的机会更少；只读的页，会更快的被换出。所以叫做二次机会法。</p>
<p>实验过程：10 表示 used bit = 1，dirty bit = 0；</p>
<p><img src="/img/mac/image-20220315160450793.png" srcset="/img/loading.gif" lazyload alt="image-20220315160450793"></p>
<h3 id="最不常用算法-lfu"><a href="#最不常用算法-lfu" class="headerlink" title="最不常用算法 lfu"></a>最不常用算法 lfu</h3><p>least frequently used</p>
<p>lfu 和 lru 的区别：一个是访问次数，一个是多久未访问。</p>
<p><img src="/img/mac/image-20220315160927016.png" srcset="/img/loading.gif" lazyload alt="image-20220315160927016"></p>
<p>问题：一个页面在进程开始时用的很多，但以后就不再使用了。</p>
<p>解决方法：定期把次数寄存器右移一位。就是除以 2。</p>
<p>实验过程：</p>
<p><img src="/img/mac/image-20220315161141452.png" srcset="/img/loading.gif" lazyload alt="image-20220315161141452"></p>
<h3 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h3><p><img src="/img/mac/image-20220315161416331.png" srcset="/img/loading.gif" lazyload alt="image-20220315161416331"></p>
<p>head：当前在内存中要被淘汰的页。</p>
<p><img src="/img/mac/image-20220315161656419.png" srcset="/img/loading.gif" lazyload alt="image-20220315161656419"></p>
<p><img src="/img/mac/image-20220315161842043.png" srcset="/img/loading.gif" lazyload alt="image-20220315161842043"></p>
<p>同样的访问序列，加大了页帧，产生的缺页反而更多，被一个叫 belady 的科学家发现。</p>
<p>采用 lru 算法就不会产生 belady</p>
<p><img src="/img/mac/image-20220315161954935.png" srcset="/img/loading.gif" lazyload alt="image-20220315161954935"></p>
<p>为什么呢？</p>
<p>lru 满足栈算法，你给他资源越多，他的缺页越少。具体内容自行 google 或翻阅《操作系统概述》。</p>
<p><img src="/img/mac/image-20220315162336046.png" srcset="/img/loading.gif" lazyload alt="image-20220315162336046"></p>
<p><img src="/img/mac/image-20220315162614428.png" srcset="/img/loading.gif" lazyload alt="image-20220315162614428"></p>
<p>clock 算法只用了 1bit，思路是模仿 lru，但开销更小。</p>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><p>上面的算法都是针对一个进程的局部置换算法。并且用的都是固定物理页帧。</p>
<p>我们希望通过动态页帧来最大程度减少缺页的发生</p>
<p><img src="/img/mac/image-20220315163836144.png" srcset="/img/loading.gif" lazyload alt="image-20220315163836144"></p>
<p>不同的页帧的效果差别是很大的，能否动态调整？</p>
<h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p><img src="/img/mac/image-20220315163945697.png" srcset="/img/loading.gif" lazyload alt="image-20220315163945697"></p>
<p>前面的局部置换算法全部基于程序的局部性原理。</p>
<p>定义：</p>
<p>工作集窗口类似于滑动窗口</p>
<p><img src="/img/mac/image-20220315164208803.png" srcset="/img/loading.gif" lazyload alt="image-20220315164208803"></p>
<p>例子</p>
<p><img src="/img/mac/image-20220315164331593.png" srcset="/img/loading.gif" lazyload alt="image-20220315164331593"></p>
<p>可以看到，滑动集对页进行了去重操作。</p>
<p><img src="/img/mac/image-20220315164545591.png" srcset="/img/loading.gif" lazyload alt="image-20220315164545591"></p>
<p>工作集表示的是程序进行的时候要访问的页是哪些，这些页可能在内存中，也可能不在内存中。</p>
<p>常驻集表示在内存中有哪些页。</p>
<p>我们希望工作集和常驻集尽量重合，以减少缺页。</p>
<p><img src="/img/mac/image-20220315164828959.png" srcset="/img/loading.gif" lazyload alt="image-20220315164828959"></p>
<p>给不同的应用程序以不同的常驻集，来减少缺页。</p>
<h3 id="两个全局页面置换算法"><a href="#两个全局页面置换算法" class="headerlink" title="两个全局页面置换算法"></a>两个全局页面置换算法</h3><h4 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h4><p>工作集是随着时间进行移动的滑动窗口，不在滑动窗口（工作集）内的就换出去。具体图示在上方的图。</p>
<p>实验过程：</p>
<p>这个可以动手画一下，光看可能不够清晰。</p>
<p><img src="/img/mac/image-20220315165622326.png" srcset="/img/loading.gif" lazyload alt="image-20220315165622326"></p>
<p>在物理内存中放的页参考的是工作集窗口</p>
<h3 id="缺页率页面置换算法"><a href="#缺页率页面置换算法" class="headerlink" title="缺页率页面置换算法"></a>缺页率页面置换算法</h3><p>缺页率：缺页次数/内存访问次数<img src="/img/mac/image-20220315184540203.png" srcset="/img/loading.gif" lazyload alt="image-20220315184540203"></p>
<p>缺页率算法实现</p>
<p><img src="/img/mac/image-20220315184709513.png" srcset="/img/loading.gif" lazyload alt="image-20220315184709513"></p>
<p>缺页率高和低的计算</p>
<p>计算这次缺失和上次缺失的时间进行相减。如果值大于某个阈值，说明缺页率比较低，相应的可以减少工作集。如果小于某个阈值，说明缺页率高。</p>
<p><img src="/img/mac/image-20220315184849983.png" srcset="/img/loading.gif" lazyload alt="image-20220315184849983"></p>
<p>实验过程：图有点糊， t current - t last &gt; 2</p>
<p><img src="/img/mac/image-20220315185637612.png" srcset="/img/loading.gif" lazyload alt="image-20220315185637612"></p>
<p>两个算法发生的时机是不一样的，缺页率算法是在中断发生时发生。</p>
<h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><p><img src="/img/mac/image-20220315190028579.png" srcset="/img/loading.gif" lazyload alt="image-20220315190028579"></p>
<p>cpu 利用率是 y 轴：尽量不把 cpu 用于换入换出。</p>
<p>开启的进程数是 x 轴：</p>
<p><img src="/img/mac/image-20220315190220994.png" srcset="/img/loading.gif" lazyload alt="image-20220315190220994"></p>
<p>解决：尽量让平均页缺失时间等于页缺失服务时间，让尽量跑更多的进程的情况下，还保持 cpu 高利用率。</p>
<p><img src="/img/mac/image-20220315190459458.png" srcset="/img/loading.gif" lazyload alt="image-20220315190459458"></p>
<h1 id="第七课-进程管理"><a href="#第七课-进程管理" class="headerlink" title="第七课-进程管理"></a>第七课-进程管理</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>进程代表着运行着的程序的执行过程，消耗着各种资源如 cpu，内存，网络，io 等。</p>
<p><img src="/img/mac/image-20220315191212264.png" srcset="/img/loading.gif" lazyload alt="image-20220315191212264"></p>
<p><img src="/img/mac/image-20220315191508500.png" srcset="/img/loading.gif" lazyload alt="image-20220315191508500">代码编译后成为可执行文件，只有当操作系统把可执行文件调入内存中执行起来，所谓执行就是 cpu 调用其中的一条条指令，完成不同的功能，这个过程是动态的执行过程，这个执行过程就是<strong>进程</strong>。和静态的可执行文件是不同的。</p>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p><img src="/img/mac/image-20220315191834893.png" srcset="/img/loading.gif" lazyload alt="image-20220315191834893"></p>
<p>进程和程序的联系：</p>
<p>程序的代码限制了进程产生的功能。</p>
<p><img src="/img/mac/image-20220315191939659.png" srcset="/img/loading.gif" lazyload alt="image-20220315191939659"></p>
<p>进程与程序的区别：</p>
<p>核心态：某些行为只能 os 才能完成（如读取文件）；os 代表进程在内存中完成这些行为</p>
<p>用户态：仅仅执行程序写的代码</p>
<p><img src="/img/mac/image-20220315192455070.png" srcset="/img/loading.gif" lazyload alt="image-20220315192455070"></p>
<p>类比，便于理解：</p>
<p><img src="/img/mac/image-20220315192751422.png" srcset="/img/loading.gif" lazyload alt="image-20220315192751422"></p>
<h2 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h2><p>动态性 包括进程创建、切换、结束</p>
<p>并行：在一个时刻有多个进程执行，需要多核 cpu 支撑</p>
<p>并发：在一段短时间内有多个进程执行</p>
<p>独立性：可以给每个进程分配几个独立的页表，在内存管理方面予以支持。</p>
<p>制约性</p>
<p><img src="/img/mac/image-20220315193451486.png" srcset="/img/loading.gif" lazyload alt="image-20220315193451486"></p>
<h2 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h2><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p><img src="/img/mac/image-20220315193645495.png" srcset="/img/loading.gif" lazyload alt="image-20220315193645495"></p>
<p>进程控制块可以作为进程存在的唯一标识。</p>
<p><img src="/img/mac/image-20220315193735471.png" srcset="/img/loading.gif" lazyload alt="image-20220315193735471"></p>
<p><img src="/img/mac/image-20220315193836928.png" srcset="/img/loading.gif" lazyload alt="image-20220315193836928"></p>
<h3 id="pcb-含有的信息"><a href="#pcb-含有的信息" class="headerlink" title="pcb 含有的信息"></a>pcb 含有的信息</h3><p><img src="/img/mac/image-20220315193949135.png" srcset="/img/loading.gif" lazyload alt="image-20220315193949135"></p>
<p>处理机即 cpu</p>
<p>控制进程处于哪个状态，运行等待或者就绪等其他情况，描述进程的执行现状。</p>
<p><img src="/img/mac/image-20220315194216137.png" srcset="/img/loading.gif" lazyload alt="image-20220315194216137"></p>
<p>数据结构连接信息：如进程 a 创建了进程 b，a 就是 b 的父进程。</p>
<h3 id="pcb-的组织方式"><a href="#pcb-的组织方式" class="headerlink" title="pcb 的组织方式"></a>pcb 的组织方式</h3><p>链表：可以更好地完成动态的插入和删除</p>
<p>如果没有频繁的创建和删除，可以考虑索引</p>
<p><img src="/img/mac/image-20220315194710456.png" srcset="/img/loading.gif" lazyload alt="image-20220315194710456"></p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><p>创建-运行-等待-唤醒-结束</p>
<p><img src="/img/mac/image-20220315194837246.png" srcset="/img/loading.gif" lazyload alt="image-20220315194837246"></p>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>有下图三种情况</p>
<p>系统初始化：先创建一个 init 进程，init 再创建其他进程</p>
<p><img src="/img/mac/image-20220315194938881.png" srcset="/img/loading.gif" lazyload alt="image-20220315194938881"></p>
<h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p><img src="/img/mac/image-20220315195043941.png" srcset="/img/loading.gif" lazyload alt="image-20220315195043941"></p>
<h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待 / 阻塞"></a>进程等待 / 阻塞</h4><p><img src="/img/mac/image-20220315195132996.png" srcset="/img/loading.gif" lazyload alt="image-20220315195132996"></p>
<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>等待的事件到达了，进入就绪态，等待操作系统调度，让 cpu 去执行</p>
<p><img src="/img/mac/image-20220315195340624.png" srcset="/img/loading.gif" lazyload alt="image-20220315195340624"></p>
<h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p><img src="/img/mac/image-20220315195402683.png" srcset="/img/loading.gif" lazyload alt="image-20220315195402683"></p>
<h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><img src="/img/mac/image-20220316104711131.png" srcset="/img/loading.gif" lazyload alt="image-20220316104711131"></p>
<p>三个主要的基本状态和其他的基本状态：</p>
<p><img src="/img/mac/image-20220316104833846.png" srcset="/img/loading.gif" lazyload alt="image-20220316104833846"></p>
<p><img src="/img/mac/image-20220316104929457.png" srcset="/img/loading.gif" lazyload alt="image-20220316104929457"></p>
<p>Running -&gt; ready ：给每个进程分配一个小的时间片，让每个进程都有机会执行</p>
<p><img src="/img/mac/image-20220316105109329.png" srcset="/img/loading.gif" lazyload alt="image-20220316105109329"></p>
<p>不会持续很久，pcb 的创建是很快的。</p>
<p><img src="/img/mac/image-20220316105202344.png" srcset="/img/loading.gif" lazyload alt="image-20220316105202344"></p>
<p>操作系统来完成，os 管理着一个时钟，对应的管理时间片。</p>
<p><img src="/img/mac/image-20220316105421244.png" srcset="/img/loading.gif" lazyload alt="image-20220316105421244"></p>
<p>事件还没有产生，对应的资源没得到满足。</p>
<p>阻塞时 事件来了，或者资源满足了，就从阻塞态进入就绪态，这也是操作系统来完成的状态转换。</p>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p><img src="/img/mac/image-20220316105846558.png" srcset="/img/loading.gif" lazyload alt="image-20220316105846558"></p>
<p><img src="/img/mac/image-20220316110104720.png" srcset="/img/loading.gif" lazyload alt="image-20220316110104720"></p>
<p>阻塞挂起时，进程的资源得到了满足，成为就绪挂起。</p>
<p><img src="/img/mac/image-20220316110225989.png" srcset="/img/loading.gif" lazyload alt="image-20220316110225989"></p>
<p>操作系统维护状态队列</p>
<p><img src="/img/mac/image-20220316110446729.png" srcset="/img/loading.gif" lazyload alt="image-20220316110446729"></p>
<p><img src="/img/mac/image-20220316110815007.png" srcset="/img/loading.gif" lazyload alt="image-20220316110815007"></p>
<p>多个就绪队列，这几个队列的优先级不同。</p>
<p>事件 1 满足后，将等待事件 1 的进程转为就绪状态。</p>
<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p><img src="/img/mac/image-20220316110958953.png" srcset="/img/loading.gif" lazyload alt="image-20220316110958953"></p>
<h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程</h3><p>编写一个 mp3</p>
<p><img src="/img/mac/image-20220316111059671.png" srcset="/img/loading.gif" lazyload alt="image-20220316111059671"></p>
<p>可能 read 的地方阻塞了，导致声音断断续续。</p>
<p><img src="/img/mac/image-20220316111213808.png" srcset="/img/loading.gif" lazyload alt="image-20220316111213808"></p>
<p>多进程的问题：并发的开销….</p>
<p><img src="/img/mac/image-20220316111321169.png" srcset="/img/loading.gif" lazyload alt="image-20220316111321169"></p>
<p><img src="/img/mac/image-20220316111402830.png" srcset="/img/loading.gif" lazyload alt="image-20220316111402830"></p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>进程当中的一条执行流程</p>
<p>从两个方面重新理解进程</p>
<p>资源管理+线程</p>
<p><img src="/img/mac/image-20220316111613746.png" srcset="/img/loading.gif" lazyload alt="image-20220316111613746"></p>
<p>多个线程共享进程所拥有的资源，可以直接访问进程的代码，资源，文件等等。</p>
<p><img src="/img/mac/image-20220316111849951.png" srcset="/img/loading.gif" lazyload alt="image-20220316111849951"></p>
<p>什么时候用进程，什么时候用线程？</p>
<p>打开浏览器的网页，现在一般是进程，如果用线程，一旦这个网页有问题，会导致其他的网页也崩溃。</p>
<p>高精度计算里可以用线程实现，如天气预报，空气动力学计算等等</p>
<p><img src="/img/mac/image-20220316112319233.png" srcset="/img/loading.gif" lazyload alt="image-20220316112319233"></p>
<p>线程的资源共享和独占</p>
<p>code data files 共享，stack · pcgister 独占</p>
<p>复习 jvm：heap，method area 中资源线程共享，stack，pc register 线程独占</p>
<p><img src="/img/mac/image-20220316112357397.png" srcset="/img/loading.gif" lazyload alt="image-20220316112357397"></p>
<p>线程与进程的比较</p>
<p><img src="/img/mac/image-20220316112943929.png" srcset="/img/loading.gif" lazyload alt="image-20220316112943929"></p>
<p>进程的创建时还要进行资源的管理，而线程直接使用进程的资源，所以时间短。</p>
<p>线程的切换：线程切换不需要进行页的切换，而进程需要，从而要更改页表/tlb 等结构。</p>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>操作系统看不到的，由用户线程库来管理</p>
<p>用户线程的 tcb 操作系统是看不到的，线程的调度和管理由线程库函数管理。</p>
<p><img src="/img/mac/image-20220316113557923.png" srcset="/img/loading.gif" lazyload alt="image-20220316113557923"></p>
<p><img src="/img/mac/image-20220316113706630.png" srcset="/img/loading.gif" lazyload alt="image-20220316113706630"></p>
<p>用户线程缺点：</p>
<p><img src="/img/mac/image-20220316113941988.png" srcset="/img/loading.gif" lazyload alt="image-20220316113941988"></p>
<h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>操作系统管理的线程</p>
<p>tcb 是放在内核中的</p>
<h4 id="用户线程和内核线程的对应关系"><a href="#用户线程和内核线程的对应关系" class="headerlink" title="用户线程和内核线程的对应关系"></a>用户线程和内核线程的对应关系</h4><p><img src="/img/mac/image-20220316113417809.png" srcset="/img/loading.gif" lazyload alt="image-20220316113417809"></p>
<p><img src="/img/mac/image-20220316114047677.png" srcset="/img/loading.gif" lazyload alt="image-20220316114047677"></p>
<p>cpu 调度单位成了线程，进程主要完成资源的管理。 pcb 统一管理 tcb。</p>
<p><img src="/img/mac/image-20220316114323630.png" srcset="/img/loading.gif" lazyload alt="image-20220316114323630"></p>
<h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p><img src="/img/mac/image-20220316114516719.png" srcset="/img/loading.gif" lazyload alt="image-20220316114516719"></p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>context switch</p>
<p>进程的上下文切换</p>
<p>进程的上下文切换换的是寄存器，如 pc register ， 栈指针等。</p>
<p><img src="/img/mac/image-20220316114732929.png" srcset="/img/loading.gif" lazyload alt="image-20220316114732929"></p>
<p>切换时，将进程的当前状态（上下文）保存到 pcb 中的某一块中。再将要执行的进程的 pcb 中取出它对应的上下文。</p>
<p><img src="/img/mac/image-20220316115003158.png" srcset="/img/loading.gif" lazyload alt="image-20220316115003158"></p>
<p><img src="/img/mac/image-20220316115157753.png" srcset="/img/loading.gif" lazyload alt="image-20220316115157753"></p>
<p>僵尸队列：后续介绍。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>windows 和 unix 进程创建的系统调用</p>
<p><img src="/img/mac/image-20220316143325894.png" srcset="/img/loading.gif" lazyload alt="image-20220316143325894"></p>
<p><img src="/img/mac/image-20220316143400299.png" srcset="/img/loading.gif" lazyload alt="image-20220316143400299"></p>
<p><img src="/img/mac/image-20220316143447159.png" srcset="/img/loading.gif" lazyload alt="image-20220316143447159"></p>
<p>fork 的地址空间复制</p>
<p><img src="/img/mac/image-20220316141202432.png" srcset="/img/loading.gif" lazyload alt="image-20220316141202432"></p>
<p><img src="/img/mac/image-20220316141359910.png" srcset="/img/loading.gif" lazyload alt="image-20220316141359910"></p>
<p>通过 if else 让子父进程执行的代码不一致。</p>
<p>空闲进程的创建</p>
<p><img src="/img/mac/image-20220316142449864.png" srcset="/img/loading.gif" lazyload alt="image-20220316142449864"></p>
<p><img src="/img/mac/image-20220316143133176.png" srcset="/img/loading.gif" lazyload alt="image-20220316143133176">让创建和加载在一个系统调用中完成，或者使用写时复制，用的时候再进行。</p>
<h3 id="加载和执行过程"><a href="#加载和执行过程" class="headerlink" title="加载和执行过程"></a>加载和执行过程</h3><p><img src="/img/mac/image-20220316143650881.png" srcset="/img/loading.gif" lazyload alt="image-20220316143650881"></p>
<p>如果 exec 系统调用执行成功的话，why would i execute 不会输出。因为原先的代码块已经被改写了。</p>
<p><img src="/img/mac/image-20220316143953869.png" srcset="/img/loading.gif" lazyload alt="image-20220316143953869"></p>
<p>fork 先创建新的地址空间，子进程先完全复制父进程的内存空间，当 exec 执行完后，子进程才执行不同的程序</p>
<p><img src="/img/mac/image-20220316144140317.png" srcset="/img/loading.gif" lazyload alt="image-20220316144140317"></p>
<p>可以看到进程本身的堆栈代码段都变化了。</p>
<p><img src="/img/mac/image-20220316144211754.png" srcset="/img/loading.gif" lazyload alt="image-20220316144211754"></p>
<p>fork 开销很大：</p>
<p>待优化的地方，复制的这个过程是可以被优化的，因为 exec 执行完后子进程都要修改掉。</p>
<p><img src="/img/mac/image-20220316144400307.png" srcset="/img/loading.gif" lazyload alt="image-20220316144400307"></p>
<p>写时复制：当父进程执行 fork 时，不复制全部的数据，只进行元数据如页表等必要数据的复制。 当父进程或子进程对某一地址单元进行写的时候，会触发一个异常，让操作系统把触发异常的页复制成两份，进行按需写的操作。这是很高效的。</p>
<h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>我们看到上面的 else 语句块中，父进程总是会调用一个 wait()</p>
<p><img src="/img/mac/image-20220316145011673.png" srcset="/img/loading.gif" lazyload alt="image-20220316145011673"></p>
<p>父进程得到子进程的 exit 消息后，且父进程在 wait，父进程帮助子进程把它的 PCB 在内存中释放掉。</p>
<p>僵尸状态：要死还不死的状态</p>
<p>子进程调用 exit 后其实已经没法正常工作，只等着被父进程回收。</p>
<p><img src="/img/mac/image-20220316145619754.png" srcset="/img/loading.gif" lazyload alt="image-20220316145619754"></p>
<p>如果父进程没有在 wait，那么会有 root 根进程代替父进程进行回收僵尸进程。</p>
<p><img src="/img/mac/image-20220316145756774.png" srcset="/img/loading.gif" lazyload alt="image-20220316145756774"></p>
<p>执行 exec 时，进程可能处于不同的状态</p>
<p>调用 exec 时-&gt; running</p>
<p>加载运行程序-&gt; ready</p>
<h1 id="第八课-cpu-调度"><a href="#第八课-cpu-调度" class="headerlink" title="第八课 cpu 调度"></a>第八课 cpu 调度</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/img/mac/image-20220316150049996.png" srcset="/img/loading.gif" lazyload alt="image-20220316150049996"></p>
<p>什么时候调度？</p>
<p><img src="/img/mac/image-20220316150202618.png" srcset="/img/loading.gif" lazyload alt="image-20220316150202618">当某个进程从一个状态切换到另一个状态时，进行调度</p>
<p><img src="/img/mac/image-20220316150400758.png" srcset="/img/loading.gif" lazyload alt="image-20220316150400758"></p>
<p>上面的两个是用户态的抢占</p>
<p>内核的不可抢占：当一个用户态进程发起系统调用进入内核态，操作系统可以确定返回的是发起系统调用的那个进程，在这个过程中不会发生等待。</p>
<h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><p><img src="/img/mac/image-20220316151001873.png" srcset="/img/loading.gif" lazyload alt="image-20220316151001873"></p>
<p>让进程更充分的利用 cpu 资源</p>
<p>评价调度的指标</p>
<p><img src="/img/mac/image-20220316151159812.png" srcset="/img/loading.gif" lazyload alt="image-20220316151159812"></p>
<p>周转时间包括两块：初始化之后还要等待一段时间才能被 cpu 执行的等待时间，执行过程中的执行时间</p>
<p><img src="/img/mac/image-20220316151703757.png" srcset="/img/loading.gif" lazyload alt="image-20220316151703757"></p>
<p>上面的指标有的是冲突的，如响应时间和吞吐量，我们要根据调度算法力求达到平衡。</p>
<p>我们希望算法有这样的效果：</p>
<p><img src="/img/mac/image-20220316151912231.png" srcset="/img/loading.gif" lazyload alt="image-20220316151912231"></p>
<p><img src="/img/mac/image-20220316152234235.png" srcset="/img/loading.gif" lazyload alt="image-20220316152234235"></p>
<p><img src="/img/mac/image-20220316152332248.png" srcset="/img/loading.gif" lazyload alt="image-20220316152332248"></p>
<p>希望每个进程得到 cpu 使用时间大致相同，</p>
<p>每个进程等待 cpu 的时间也大致相同，为公平。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><img src="/img/mac/image-20220316152507960.png" srcset="/img/loading.gif" lazyload alt="image-20220316152507960"></p>
<p>多级反馈队列：既强调公平又根据进程的动态执行过程来动态调整。</p>
<ul>
<li>FCFS 先来先服务</li>
</ul>
<p><img src="/img/mac/image-20220316152722265.png" srcset="/img/loading.gif" lazyload alt="image-20220316152722265"></p>
<p>如果前面的进程执行时间长，会导致后面进程的等待时间也相应长，严重影响周转时间和平均等待时间。</p>
<p><img src="/img/mac/image-20220316153024253.png" srcset="/img/loading.gif" lazyload alt="image-20220316153024253"></p>
<ul>
<li>短任务优先 SRT/SPN</li>
</ul>
<p><img src="/img/mac/image-20220316153144634.png" srcset="/img/loading.gif" lazyload alt="image-20220316153144634"></p>
<p>如果来了一个时间比现在正在执行的进程时间短的进程。抢占（SRT)：现在执行的进程进入就绪，新来的执行。</p>
<p>非抢占(SPN)：新来的最短时间进程进入链头</p>
<p><img src="/img/mac/image-20220316153602722.png" srcset="/img/loading.gif" lazyload alt="image-20220316153602722"></p>
<p>可以看到最短任务优先的速度是最快的。</p>
<p><img src="/img/mac/image-20220316153941197.png" srcset="/img/loading.gif" lazyload alt="image-20220316153941197"></p>
<p>我们很难知道一个程序的执行时间。所以这个算法很难实现。</p>
<p><img src="/img/mac/image-20220316154316946.png" srcset="/img/loading.gif" lazyload alt="image-20220316154316946"></p>
<p>我们通过一种公式来预估程序的执行时间。</p>
<p>通过 2 个时刻来预估下一刻的时间。也是一种根据过去来预估未来的方式。</p>
<ul>
<li>最高响应比优先</li>
</ul>
<p><img src="/img/mac/image-20220316154537699.png" srcset="/img/loading.gif" lazyload alt="image-20220316154537699"></p>
<p>综合考虑了等待时间和执行时间。</p>
<ul>
<li>轮询 round robin</li>
</ul>
<p>让各个进程轮流占有时间片执行</p>
<p><img src="/img/mac/image-20220316154828628.png" srcset="/img/loading.gif" lazyload alt="image-20220316154828628"></p>
<p>没有占满时间片的直接交出。</p>
<p><img src="/img/mac/image-20220316155114602.png" srcset="/img/loading.gif" lazyload alt="image-20220316155114602"></p>
<p>时间片太小，切换太频繁。时间片太大，退化成 fcfs</p>
<p>看看不同时间片大小下的平均等待时间</p>
<p><img src="/img/mac/image-20220316155345905.png" srcset="/img/loading.gif" lazyload alt="image-20220316155345905"> fcfs 相对于 rr 牺牲了公平性</p>
<ul>
<li>多级反馈队列</li>
</ul>
<p>多级队列：</p>
<p>把就绪队列分为多级，他们有不同优先级，每级采取不同算法</p>
<p><img src="/img/mac/image-20220316155707140.png" srcset="/img/loading.gif" lazyload alt="image-20220316155707140"></p>
<p>多级反馈队列：</p>
<p>根据进程的动态变化，而让进程在不同的队列中移动</p>
<p><img src="/img/mac/image-20220316155914130.png" srcset="/img/loading.gif" lazyload alt="image-20220316155914130"></p>
<ul>
<li>FFS 公平共享调度</li>
</ul>
<p><img src="/img/mac/image-20220316160256308.png" srcset="/img/loading.gif" lazyload alt="image-20220316160256308"></p>
<p>现在介绍的调度算法是简单的，实际操作系统中可能更复杂，但是我们上面的算法都会体现出思想。如公平性和等待时间如何权衡等。</p>
<p><img src="/img/mac/image-20220316160602236.png" srcset="/img/loading.gif" lazyload alt="image-20220316160602236"></p>
<h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>区别于前面的通用型操作系统方法。</p>
<p>实施调度大多用于工业控制如火车，机床和嵌入式之类的实施系统中。</p>
<p><img src="/img/mac/image-20220316160928808.png" srcset="/img/loading.gif" lazyload alt="image-20220316160928808"></p>
<p>实施系统分为两类：</p>
<p><img src="/img/mac/image-20220316160945836.png" srcset="/img/loading.gif" lazyload alt="image-20220316160945836"></p>
<p>前者的重要性任务如果不完成可能会发生灾难性的后果。所以必须要完成。</p>
<p><img src="/img/mac/image-20220316161240412.png" srcset="/img/loading.gif" lazyload alt="image-20220316161240412"></p>
<p>released：代表程序进入就绪</p>
<p>就绪后等待一段时间执行，execution time</p>
<p>deadline ：期限，执行时间一定不能超过期限，超过了实时性就不能得到满足</p>
<p>relative deadline：在周期中的某个任务的相对期限。</p>
<p><img src="/img/mac/image-20220316161318156.png" srcset="/img/loading.gif" lazyload alt="image-20220316161318156"></p>
<p><img src="/img/mac/image-20220316161719461.png" srcset="/img/loading.gif" lazyload alt="image-20220316161719461"></p>
<p><img src="/img/mac/image-20220316161922647.png" srcset="/img/loading.gif" lazyload alt="image-20220316161922647"></p>
<p>任务的优先级随着执行过程而发生改变</p>
<p>实施系统的两种调度算法</p>
<p><img src="/img/mac/image-20220316162042920.png" srcset="/img/loading.gif" lazyload alt="image-20220316162042920"></p>
<h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>前面的调度算法都是针对单个 cpu</p>
<p>我们要考虑程序放哪个 cpu 上，和负载均衡问题。</p>
<p>但是对于每个独立的 cpu 内部，里面用的方法和普通操作系统的调度算法差不多。</p>
<p><img src="/img/mac/image-20220316162717935.png" srcset="/img/loading.gif" lazyload alt="image-20220316162717935"></p>
<p>不多介绍。</p>
<h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><h1 id="第九课-同步"><a href="#第九课-同步" class="headerlink" title="第九课 同步"></a>第九课 同步</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p><img src="/img/mac/image-20220316185003082.png" srcset="/img/loading.gif" lazyload alt="image-20220316185003082"></p>
<p>上图中的线程可以替换进程，在这里都看作是 cpu 的调度单位</p>
<p><img src="/img/mac/image-20220316185230533.png" srcset="/img/loading.gif" lazyload alt="image-20220316185230533"></p>
<p>完成相应的共享和交互</p>
<p>不确定性和不可重现的例子：</p>
<p><img src="/img/mac/image-20220316185424543.png" srcset="/img/loading.gif" lazyload alt="image-20220316185424543"></p>
<p>有点像 jvm 中的 i++的字节码：iinc 1，1 之类的</p>
<p>java 中类似的并发问题：不确定进程 1 的时间片什么时候用完，从而在本该进行原子操作的代码中发生非原子操作</p>
<p><img src="/img/mac/image-20220316185811356.png" srcset="/img/loading.gif" lazyload alt="image-20220316185811356"></p>
<p>调度导致线程上下文切换，切换完毕后，进程 1 的寄存器要进行恢复，这样就又恢复到了 100。</p>
<p><img src="/img/mac/image-20220316190356638.png" srcset="/img/loading.gif" lazyload alt="image-20220316190356638"></p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>引入同步互斥，解决</p>
<p><img src="/img/mac/image-20220316190516195.png" srcset="/img/loading.gif" lazyload alt="image-20220316190516195"></p>
<p>方法：保证原子操作</p>
<p><img src="/img/mac/image-20220316190535001.png" srcset="/img/loading.gif" lazyload alt="image-20220316190535001"></p>
<p><img src="/img/mac/image-20220316190659040.png" srcset="/img/loading.gif" lazyload alt="image-20220316190659040"></p>
<p>可能 a 先执行完，b 先执行完，还有一种一直僵持下去的情况，谁都无法 print。</p>
<p>我们要通过同步机制解决这个问题。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>有一段代码要访问共享资源如静态变量，访问共享资源的那段代码就是临界区</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>保证访问临界区的进程只有一个，不允许多个进程都进入临界区</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>a 等 b 的资源</p>
<p>b 等 a 的资源</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个迟迟得不到资源的进程</p>
<p><img src="/img/mac/image-20220316191815197.png" srcset="/img/loading.gif" lazyload alt="image-20220316191815197"></p>
<p>例子：</p>
<p><img src="/img/mac/image-20220316192049203.png" srcset="/img/loading.gif" lazyload alt="image-20220316192049203"></p>
<p>其实就是两个进程做了重复的事，不是我们所期望的。</p>
<p>可以用锁来解决</p>
<p><img src="/img/mac/image-20220316192258237.png" srcset="/img/loading.gif" lazyload alt="image-20220316192258237"></p>
<p>锁住冰箱，粒度太大了，我们可以用粒度更小的标签来当作锁</p>
<p><img src="/img/mac/image-20220316192530795.png" srcset="/img/loading.gif" lazyload alt="image-20220316192530795"></p>
<p>但是依旧存在问题</p>
<p>如果进程切换在第二个 if 语句，那么一样会出问题</p>
<p><img src="/img/mac/image-20220316192758620.png" srcset="/img/loading.gif" lazyload alt="image-20220316192758620"></p>
<p><img src="/img/mac/image-20220316192835099.png" srcset="/img/loading.gif" lazyload alt="image-20220316192835099"></p>
<p>如果把放置标签放在第一步</p>
<p>根本不会有人去买面包</p>
<p><img src="/img/mac/image-20220316193051262.png" srcset="/img/loading.gif" lazyload alt="image-20220316193051262"></p>
<p>比如 a 先放标签，b 也放标签，到了判断有无标签的时候，都进不去 if 里面的代码块。</p>
<p>为便签增加标签，依旧不行</p>
<p><img src="/img/mac/image-20220316193543860.png" srcset="/img/loading.gif" lazyload alt="image-20220316193543860"></p>
<p><img src="/img/mac/image-20220316193619833.png" srcset="/img/loading.gif" lazyload alt="image-20220316193619833"></p>
<p><img src="/img/mac/image-20220316193831165.png" srcset="/img/loading.gif" lazyload alt="image-20220316193831165"></p>
<p>这样的逻辑可以解决一个人买面包且不多买</p>
<p>但是</p>
<p><img src="/img/mac/image-20220316194110732.png" srcset="/img/loading.gif" lazyload alt="image-20220316194110732"></p>
<p>这只是两个进程的情况，很难推广到多个。</p>
<p>另一个解决方案<img src="/img/mac/image-20220316194447529.png" srcset="/img/loading.gif" lazyload alt="image-20220316194447529"></p>
<p>同一时间只能有一个进程执行临界区的的代码，其他进程如果想进来需要等待。</p>
<p><img src="/img/mac/image-20220316194725057.png" srcset="/img/loading.gif" lazyload alt="image-20220316194725057"></p>
<h3 id="怎么设计进入和离开临界区的代码"><a href="#怎么设计进入和离开临界区的代码" class="headerlink" title="怎么设计进入和离开临界区的代码"></a>怎么设计进入和离开临界区的代码</h3><p><img src="/img/mac/image-20220316194916384.png" srcset="/img/loading.gif" lazyload alt="image-20220316194916384"></p>
<p>设计的原则，一个进程如果想进去，就一定会进去等等……</p>
<p><img src="/img/mac/image-20220316195257045.png" srcset="/img/loading.gif" lazyload alt="image-20220316195257045"></p>
<h4 id="方法-1-禁用硬件中断"><a href="#方法-1-禁用硬件中断" class="headerlink" title="方法 1 禁用硬件中断"></a>方法 1 禁用硬件中断</h4><p>中断使得操作系统有了打断进程的能力，但这也是得到不确定结果的主要原因。</p>
<p><img src="/img/mac/image-20220316195311150.png" srcset="/img/loading.gif" lazyload alt="image-20220316195311150"></p>
<p>缺点：中断主要是用于及时的外设进行交互的，如果停止了中断，硬件没法得到及时的响应，会有一定影响。</p>
<p><img src="/img/mac/image-20220316195417039.png" srcset="/img/loading.gif" lazyload alt="image-20220316195417039"></p>
<h4 id="方法-2-基于软件的解决方法"><a href="#方法-2-基于软件的解决方法" class="headerlink" title="方法 2 基于软件的解决方法"></a>方法 2 基于软件的解决方法</h4><p><img src="/img/mac/image-20220316195735072.png" srcset="/img/loading.gif" lazyload alt="image-20220316195735072"></p>
<p>根据 turn 来决定谁进入临界区</p>
<p><img src="/img/mac/image-20220316195935089.png" srcset="/img/loading.gif" lazyload alt="image-20220316195935089"></p>
<p>假设 turn = 0；非 0 的进程进来会在 while 里面打转，只有 0 的进程会进入临界区</p>
<p>progress：某个进程不往前走了，一直在临界区门口等着。如果进程 1 进去后把 turn 改成了 0，但是 1 想再进去一次，可是 0 不再来访问这次代码了，导致 1 无法进去，一直在门口打转。</p>
<p>另一种方案</p>
<p>flag[i] == 1 表示进程 i 想进入临界区</p>
<p><img src="/img/mac/image-20220316200757200.png" srcset="/img/loading.gif" lazyload alt="image-20220316200757200"></p>
<p>j 是现在正在临界区里的进程，它执行完后把 flag[j]置 0，让等待的进程 i 进入。</p>
<p>这种方案有什么问题？</p>
<p>没有互斥。</p>
<p>初始的时候，两个进程的对应 flag 都为 0，都进入了第二条语句，造成两个人买面包问题。</p>
<p>交换两条语句</p>
<p><img src="/img/mac/image-20220316201303313.png" srcset="/img/loading.gif" lazyload alt="image-20220316201303313"></p>
<p>进程 0 和进程 1 可能都在 while 循环中打转</p>
<p>正确解法：</p>
<p><img src="/img/mac/image-20220316201428593.png" srcset="/img/loading.gif" lazyload alt="image-20220316201428593"></p>
<p>皮特森算法</p>
<p><img src="/img/mac/image-20220316201644782.png" srcset="/img/loading.gif" lazyload alt="image-20220316201644782"></p>
<p>互斥的证明：反证法，假设有两个进程 0，1。</p>
<p>如果两个进程都在临界区，但是 turn 又只能有一个值，所以不会有互斥。</p>
<p>德克斯算法 也是一个可行的算法</p>
<p><img src="/img/mac/image-20220316202222399.png" srcset="/img/loading.gif" lazyload alt="image-20220316202222399"></p>
<p>推广到 n 个进程：另一个算法</p>
<p>让 n 个进程有序的进入临界区</p>
<p><img src="/img/mac/image-20220316202307917.png" srcset="/img/loading.gif" lazyload alt="image-20220316202307917"></p>
<p>bakery 算法，例子</p>
<p>相当于银行取号，叫到号的进临界区，如果票号一样，就按他们的身份标识（身份证）来排。</p>
<p><img src="/img/mac/image-20220316202420592.png" srcset="/img/loading.gif" lazyload alt="image-20220316202420592"></p>
<p>总结</p>
<p><img src="/img/mac/image-20220316202729203.png" srcset="/img/loading.gif" lazyload alt="image-20220316202729203"></p>
<p>忙等：在 while 中循环打转</p>
<h4 id="方法-3-更高级的抽象-原子操作指令"><a href="#方法-3-更高级的抽象-原子操作指令" class="headerlink" title="方法 3 更高级的抽象 原子操作指令"></a>方法 3 更高级的抽象 原子操作指令</h4><p><img src="/img/mac/image-20220316202907928.png" srcset="/img/loading.gif" lazyload alt="image-20220316202907928"></p>
<p>只有获得锁的才能进入临界区</p>
<p><img src="/img/mac/image-20220316202931210.png" srcset="/img/loading.gif" lazyload alt="image-20220316202931210"></p>
<p>抽象怎么实现？</p>
<p><img src="/img/mac/image-20220316203008197.png" srcset="/img/loading.gif" lazyload alt="image-20220316203008197"></p>
<p>test-and-set：一条机器指令，完成通常的读写操作的两条指令</p>
<p>exchange ： 输入的是两个内存单元</p>
<p><img src="/img/mac/image-20220316203608393.png" srcset="/img/loading.gif" lazyload alt="image-20220316203608393"></p>
<p>Test and Set 的具体使用</p>
<p><img src="/img/mac/image-20220316203935765.png" srcset="/img/loading.gif" lazyload alt="image-20220316203935765"></p>
<p>两个进程和 n 个进程都可以实现</p>
<p>在自旋的进程还能再优化，让忙等的进程睡眠，进入一个等待队列，锁释放后再进行唤醒</p>
<p><img src="/img/mac/image-20220316204006873.png" srcset="/img/loading.gif" lazyload alt="image-20220316204006873"></p>
<p><img src="/img/mac/image-20220316204158628.png" srcset="/img/loading.gif" lazyload alt="image-20220316204158628"></p>
<p>但是不忙等的情况会发生线程上下文切换，而忙等又占用一定的 cpu 资源。如果临界区的代码较长，可以考虑无忙等待；如果临界区的代码很短，那就可以等一会。</p>
<p>exchange 实现机制</p>
<p><img src="/img/mac/image-20220316204436028.png" srcset="/img/loading.gif" lazyload alt="image-20220316204436028"></p>
<p>基于原子操作指令的同步现在是广泛使用的</p>
<p><img src="/img/mac/image-20220316204750456.png" srcset="/img/loading.gif" lazyload alt="image-20220316204750456"></p>
<p><img src="/img/mac/image-20220316204802677.png" srcset="/img/loading.gif" lazyload alt="image-20220316204802677"></p>
<p>高优先级的进程在忙等的时候，因为低优先级进程的优先级低，导致无法释放锁。从而发生死锁。可以用上面介绍的优先级反转来解决。</p>
<p><img src="/img/mac/image-20220316205002882.png" srcset="/img/loading.gif" lazyload alt="image-20220316205002882"></p>
<h1 id="第十课-信号量和管程"><a href="#第十课-信号量和管程" class="headerlink" title="第十课 信号量和管程"></a>第十课 信号量和管程</h1><p>复习第九课</p>
<p><img src="/img/mac/image-20220316205439909.png" srcset="/img/loading.gif" lazyload alt="image-20220316205439909"></p>
<p>软件的开销是很大的，我们用硬件来支撑这个锁的概念。</p>
<h2 id="信号量-sem"><a href="#信号量-sem" class="headerlink" title="信号量 sem"></a>信号量 sem</h2><p>临界区的读操作是可以并发执行的，但我们上面的都只能有一个进程进入临界区，这就引出信号量的概念</p>
<p><img src="/img/mac/image-20220317093501831.png" srcset="/img/loading.gif" lazyload alt="image-20220317093501831"></p>
<p>直到一个列车离开临界区，等待的那个列车会被离开的列车唤醒，进入临界区</p>
<p><img src="/img/mac/image-20220317093551747.png" srcset="/img/loading.gif" lazyload alt="image-20220317093551747"></p>
<h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p><img src="/img/mac/image-20220317093843765.png" srcset="/img/loading.gif" lazyload alt="image-20220317093843765"></p>
<p>一般来说，只唤醒一个进程的话，采用 fifo 机制，让等的最久的进程进行唤醒。</p>
<p><img src="/img/mac/image-20220317094030744.png" srcset="/img/loading.gif" lazyload alt="image-20220317094030744"></p>
<p>模拟 lock 操作，初值设成 1</p>
<p><img src="/img/mac/image-20220317094212990.png" srcset="/img/loading.gif" lazyload alt="image-20220317094212990"></p>
<p>模拟同步操作，将初值设为 0</p>
<p><img src="/img/mac/image-20220317094402522.png" srcset="/img/loading.gif" lazyload alt="image-20220317094402522"></p>
<p>当线程 a 需要线程 b 执行到某个地方时，才能接着执行，就可以采用上面的设 sem 初值为 0 的操作。</p>
<p>上面的二进制 sem 有局限，看一下计数信号量的使用</p>
<p><img src="/img/mac/image-20220317094844068.png" srcset="/img/loading.gif" lazyload alt="image-20220317094844068"></p>
<p>我们可以有多个生产者往 buffer 中写数据，也可以有多个 consumer 往里面读数据，这都取决于我们的 sem 怎么设置。</p>
<p>用二进制信号量做操作/取出的互斥</p>
<p><img src="/img/mac/image-20220317095123293.png" srcset="/img/loading.gif" lazyload alt="image-20220317095123293"></p>
<p>具体实现</p>
<p>fullbuffer：bufffer 里面的数据初始值 0</p>
<p>emptybuffer：当前生产者可以往 buffer 里面放多少个数据</p>
<p><img src="/img/mac/image-20220317095240884.png" srcset="/img/loading.gif" lazyload alt="image-20220317095240884"></p>
<p>确保互斥</p>
<p><img src="/img/mac/image-20220317095517202.png" srcset="/img/loading.gif" lazyload alt="image-20220317095517202"></p>
<p>可以有 n 个生产者进入 deposit</p>
<p>执行完后把 full buffer+1,意味着通知消费者来取数据</p>
<p><img src="/img/mac/image-20220317095714835.png" srcset="/img/loading.gif" lazyload alt="image-20220317095714835"></p>
<p>消费者和生产者相反</p>
<p><img src="/img/mac/image-20220317095803078.png" srcset="/img/loading.gif" lazyload alt="image-20220317095803078"></p>
<p>如果 p/v 操作顺序改了，如消费者的 mutex -p 和 emptyBuffer - p 交换顺序</p>
<p>有可能发生死锁。</p>
<h3 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h3><p>等待队列里的进程，就是待唤醒的进程。</p>
<p>信号量的本身结构和 pv 操作硬件原语</p>
<p><img src="/img/mac/image-20220317101149943.png" srcset="/img/loading.gif" lazyload alt="image-20220317101149943"></p>
<p><img src="/img/mac/image-20220317101356539.png" srcset="/img/loading.gif" lazyload alt="image-20220317101356539">和锁的区别：锁还可以进行忙等和等待队列；而信号量只能用等待队列进行。</p>
<h2 id="管程-monitor"><a href="#管程-monitor" class="headerlink" title="管程 monitor"></a>管程 monitor</h2><p>最开始提出是用在简化高级语言的同步互斥问题。</p>
<p>管程是什么？</p>
<p>包含了一系列的共享变量，以及操作了这些共享变量的函数的总和</p>
<p><img src="/img/mac/image-20220317101736888.png" srcset="/img/loading.gif" lazyload alt="image-20220317101736888"></p>
<p>条件变量？</p>
<p>在访问共享资源和变量的过程中，可能某个条件得不到满足，把得不到满足资源的线程挂起，就挂在条件变量变量上，根据条件个数来确定条件变量。</p>
<p><img src="/img/mac/image-20220317102204705.png" srcset="/img/loading.gif" lazyload alt="image-20220317102204705"></p>
<p>进入管程是互斥的，需要 lock，所以用了进入队列 entry lock。</p>
<p>圆柱体代表着操作共享变量的函数，x 和 y 是条件变量，条件变量也有自己的等待队列。</p>
<p>对条件变量有 wait 和 signal 操作</p>
<p><img src="/img/mac/image-20220317102429558.png" srcset="/img/loading.gif" lazyload alt="image-20220317102429558"></p>
<p>条件变量的实现以及条件变量的两个方法</p>
<p><img src="/img/mac/image-20220317102751076.png" srcset="/img/loading.gif" lazyload alt="image-20220317102751076"></p>
<p>schedule 是选择 ready 状态的线程去执行</p>
<p>为什么要先 release 再 require？后面再说</p>
<p>wakeup 是把 sleep 的线程改为 ready 状态</p>
<p>我们再用管程来解决生产消费</p>
<p><img src="/img/mac/image-20220317103149857.png" srcset="/img/loading.gif" lazyload alt="image-20220317103149857"></p>
<p>notFull 和 not empty 是两个条件变量</p>
<p>count 表示 buffer 的大小</p>
<p><img src="/img/mac/image-20220317104010327.png" srcset="/img/loading.gif" lazyload alt="image-20220317104010327"></p>
<p>先看生产者，当 buffer 满了之后，我们将 lock 传入 wait 方法，先释放一次锁，让其他线程先来执行（不能让这个线程带着锁去等待 c），当它再次得到锁之后（notfull.singal)，依旧会在生产者的 while 里继续判断 count==n；</p>
<p>消费者这边也是一样的</p>
<p><img src="/img/mac/image-20220317104330558.png" srcset="/img/loading.gif" lazyload alt="image-20220317104330558"></p>
<p>再来看一个细节，当一个线程调用了条件变量的 signal 方法后，是直接让唤醒的线程直接执行，还是等待调用 signal 方法的线程执行完毕后再执行</p>
<p>hoare 方法，让唤醒的线程直接去执行</p>
<p>hansen，让调用 signal 的执行完毕后再去执行那个被唤醒的线程</p>
<p><img src="/img/mac/image-20220317104818593.png" srcset="/img/loading.gif" lazyload alt="image-20220317104818593"></p>
<p>if 还是 while</p>
<p><img src="/img/mac/image-20220317105211437.png" srcset="/img/loading.gif" lazyload alt="image-20220317105211437"></p>
<p>因为 hansen 的实现方式可能导致唤醒的多个线程来抢占 cpu，导致 count 不为 n，所以要用 whiile 做判断</p>
<p>hoare</p>
<p>不需要多次判断 count==n，因为执行 signal 后就去执行唤醒的线程了，但是在执行 signal 之前一定会执行 count–</p>
<h2 id="同步互斥基本总结"><a href="#同步互斥基本总结" class="headerlink" title="同步互斥基本总结"></a>同步互斥基本总结</h2><p>信号量和管程</p>
<p><img src="/img/mac/image-20220317105659276.png" srcset="/img/loading.gif" lazyload alt="image-20220317105659276"></p>
<p><img src="/img/mac/image-20220317105708144.png" srcset="/img/loading.gif" lazyload alt="image-20220317105708144"></p>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h3><p><img src="/img/mac/image-20220317110148346.png" srcset="/img/loading.gif" lazyload alt="image-20220317110148346"></p>
<p><img src="/img/mac/image-20220317110317695.png" srcset="/img/loading.gif" lazyload alt="image-20220317110317695"></p>
<p>读者优先：如果有人在读，又有人想写，写的人等着；当有人在读时，如果后面的读者想进来，也可以进来</p>
<p>Rcount 位读者的数量，写者始终只有一个</p>
<p>semwait 就是 p，sempost 就是 v</p>
<p>读者优先的实现：</p>
<p><img src="/img/mac/image-20220317111345352.png" srcset="/img/loading.gif" lazyload alt="image-20220317111345352"></p>
<p><img src="/img/mac/image-20220317111518383.png" srcset="/img/loading.gif" lazyload alt="image-20220317111518383"></p>
<p>如何实现写者优先？读者需要给两种写者让步，一种是正在执行写操作的写者，另一种是在等待队列中的写者，只要这两者都不存在，读者才能进入。</p>
<p><img src="/img/mac/image-20220317114116923.png" srcset="/img/loading.gif" lazyload alt="image-20220317114116923"></p>
<p><strong>上面用的是信号量，这里用管程实现</strong></p>
<p><img src="/img/mac/image-20220317114326780.png" srcset="/img/loading.gif" lazyload alt="image-20220317114326780"></p>
<p>伪代码 写优先</p>
<p><img src="/img/mac/image-20220317114655209.png" srcset="/img/loading.gif" lazyload alt="image-20220317114655209"></p>
<p>具体实现</p>
<p><img src="/img/mac/image-20220317114940338.png" srcset="/img/loading.gif" lazyload alt="image-20220317114940338"></p>
<p>有 writer 存在，就不能进行读。这是同时判断了 aw 和 ww，体现了写者优先。</p>
<p>确保 ar=0，再去判断 wait writer 以及唤醒写者 体现可以有多个读者同时读；而写者要等到没有人在读或者写的时候才能进行写</p>
<p><img src="/img/mac/image-20220317115221895.png" srcset="/img/loading.gif" lazyload alt="image-20220317115221895"></p>
<p>写者的实现</p>
<p><img src="/img/mac/image-20220317115556400.png" srcset="/img/loading.gif" lazyload alt="image-20220317115556400"></p>
<p>具体代码</p>
<p><img src="/img/mac/image-20220317115649853.png" srcset="/img/loading.gif" lazyload alt="image-20220317115649853"></p>
<p>先判断等待的 writer，在判断等待的 reader，这里还用的是 broadcast 广播。</p>
<p><img src="/img/mac/image-20220317120026581.png" srcset="/img/loading.gif" lazyload alt="image-20220317120026581"></p>
<h3 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h3><p>五个人吃饭，一个人吃饭要两把叉子，总共五把叉子</p>
<p><img src="/img/mac/image-20220317174222615.png" srcset="/img/loading.gif" lazyload alt="image-20220317174222615"></p>
<p><img src="/img/mac/image-20220317174318786.png" srcset="/img/loading.gif" lazyload alt="image-20220317174318786"></p>
<p>基本的想法，但是是错的。</p>
<p>如果五个人同步执行，都执行了第二条语句，都准备执行第三个的时候就发生了死锁。</p>
<p>再进一步呢？我们加个判断</p>
<p><img src="/img/mac/image-20220317174628338.png" srcset="/img/loading.gif" lazyload alt="image-20220317174628338"></p>
<p>依旧有问题：</p>
<p>还是五把叉子一起拿起，一样有问题。</p>
<p>如果修改了每个人的等待时间</p>
<p><img src="/img/mac/image-20220317174918896.png" srcset="/img/loading.gif" lazyload alt="image-20220317174918896"></p>
<p>虽然可行，但是随机时间是不固定的，我们不能保证每个哲学家都能吃上饭，如果一个哲学家要等特别久，这样还是不理想。</p>
<p>如果我们给每个人吃饭操作都加上锁，虽然能解决，但是效率 很低。</p>
<p><img src="/img/mac/image-20220317175128757.png" srcset="/img/loading.gif" lazyload alt="image-20220317175128757"></p>
<p>上面方案的缺点</p>
<p><img src="/img/mac/image-20220317175329645.png" srcset="/img/loading.gif" lazyload alt="image-20220317175329645"></p>
<p>饥饿状态表明自己想要叉子（锁）</p>
<p><img src="/img/mac/image-20220317175636002.png" srcset="/img/loading.gif" lazyload alt="image-20220317175636002"></p>
<p><img src="/img/mac/image-20220317175920030.png" srcset="/img/loading.gif" lazyload alt="image-20220317175920030"></p>
<p><img src="/img/mac/image-20220317180158687.png" srcset="/img/loading.gif" lazyload alt="image-20220317180158687"></p>
<p><img src="/img/mac/image-20220317184840176.png" srcset="/img/loading.gif" lazyload alt="image-20220317184840176"></p>
<p>哲学家的运行的函数：</p>
<p><img src="/img/mac/image-20220317185151704.png" srcset="/img/loading.gif" lazyload alt="image-20220317185151704"></p>
<p>拿叉子的函数 takeforks 的具体实现：</p>
<p><img src="/img/mac/image-20220317185524459.png" srcset="/img/loading.gif" lazyload alt="image-20220317185524459"></p>
<p>state 的赋值和拿叉子需要锁来保护</p>
<p>再进一步：拿两把叉子的具体操作</p>
<p>当我处于 hungry 并且左右邻居都没在吃饭</p>
<p>我就可以拿两把叉子了，<strong>并且这里通知我自己可以吃饭了</strong>，后面还会有另外的场景来调用这个函数，就是另外一种情形。</p>
<p><img src="/img/mac/image-20220317185722120.png" srcset="/img/loading.gif" lazyload alt="image-20220317185722120"></p>
<p>putforks 具体操作</p>
<p><img src="/img/mac/image-20220317190723521.png" srcset="/img/loading.gif" lazyload alt="image-20220317190723521"></p>
<p>这里就复用了上面的代码</p>
<p>自己吃完饭后判断左右邻居是能否吃饭，如果可以的话，就把它们给唤醒，并且把叉子给他们。</p>
<p><img src="/img/mac/image-20220317191007531.png" srcset="/img/loading.gif" lazyload alt="image-20220317191007531"></p>
<p>eat（）其实不需要了，因为拿到叉子后已经变成了 eat 状态，think（）可以用作初始化使用。</p>
<p>伪代码 - 数据结构 - 定义各种变量 - 代码撰写，我们同步问题的这一章基本就是这样的流程，来解决同步互斥问题。</p>
<h1 id="第-11-课-死锁和进程间通信"><a href="#第-11-课-死锁和进程间通信" class="headerlink" title="第 11 课 死锁和进程间通信"></a>第 11 课 死锁和进程间通信</h1><p>大纲</p>
<p><img src="/img/mac/image-20220317191537025.png" srcset="/img/loading.gif" lazyload alt="image-20220317191537025"></p>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>我们把行车道理解成一种资源</p>
<p><img src="/img/mac/image-20220317191623604.png" srcset="/img/loading.gif" lazyload alt="image-20220317191623604"></p>
<p>车的倒退就是一种释放资源的过程。</p>
<p><img src="/img/mac/image-20220317191813441.png" srcset="/img/loading.gif" lazyload alt="image-20220317191813441"></p>
<p>死锁的出现是在并发的基础之上的。</p>
<h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p><img src="/img/mac/image-20220317192032401.png" srcset="/img/loading.gif" lazyload alt="image-20220317192032401"></p>
<p>进程对资源有三种情况，请求，持有，释放。资源对应的状态时空闲，正在使用，空闲。</p>
<p>有关资源：</p>
<p><img src="/img/mac/image-20220317192312399.png" srcset="/img/loading.gif" lazyload alt="image-20220317192312399"></p>
<p>如果一个进程拥有一个资源并且请求其他资源，就有可能发生死锁。</p>
<p>一般来说，一个进程的资源得不到满足，他就会进入 blocked 状态</p>
<p>我们用一个有向图来表示资源分配图</p>
<p><img src="/img/mac/image-20220317192837756.png" srcset="/img/loading.gif" lazyload alt="image-20220317192837756"></p>
<p><img src="/img/mac/image-20220317192919075.png" srcset="/img/loading.gif" lazyload alt="image-20220317192919075"></p>
<p>举个例子</p>
<p>r2 中有两个资源实例，一个给了 p1，一个给了 p2.</p>
<p>p1 请求 r1 资源但是无法得到满足，因为 r1 资源已经给 p2 占用了。</p>
<p><img src="/img/mac/image-20220317193159445.png" srcset="/img/loading.gif" lazyload alt="image-20220317193159445"></p>
<p>虽然这里有进程的 sleep，但是没有产生死锁。</p>
<p>我们更进一步，看看</p>
<p><img src="/img/mac/image-20220317193522806.png" srcset="/img/loading.gif" lazyload alt="image-20220317193522806"></p>
<p>图中有一个 p1 到 p3 的大环，有 p2 到 p3 的小环。这里有死锁存在。因为三个线程最后都会 sleep，互相等待对方释放资源。</p>
<p>另一种情况</p>
<p><img src="/img/mac/image-20220317193854353.png" srcset="/img/loading.gif" lazyload alt="image-20220317193854353"></p>
<p>p2 运行一段时间后会释放 r1 的实例，打破 p1 和 p3 的“死锁”。</p>
<p>小总结</p>
<p><img src="/img/mac/image-20220317194052621.png" srcset="/img/loading.gif" lazyload alt="image-20220317194052621"></p>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p><img src="/img/mac/image-20220317194436628.png" srcset="/img/loading.gif" lazyload alt="image-20220317194436628"></p>
<p>循环等待其实就是上面所说的环</p>
<p>上面所介绍的是必要条件，并不是说这四个条件会产生死锁。</p>
<h2 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h2><p><img src="/img/mac/image-20220317194724955.png" srcset="/img/loading.gif" lazyload alt="image-20220317194724955"></p>
<p>约束从上往下递减。</p>
<p><img src="/img/mac/image-20220317194936376.png" srcset="/img/loading.gif" lazyload alt="image-20220317194936376">判断出现死锁的开销挺大的，所以有的操作系统干脆忽略死锁。</p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>就是让死锁不出现。</p>
<p>只要把死锁出现之后的四个条件之一打破，就可以预防死锁。</p>
<p><img src="/img/mac/image-20220317195216164.png" srcset="/img/loading.gif" lazyload alt="image-20220317195216164"></p>
<p>如果互斥不满足，会带来不确定性问题，不好。</p>
<p>占用并等待：极端一点，如果每个进程要 hold 所有的资源才能运行，这样虽然可以运行，但是饥饿现象非常明显。</p>
<p><img src="/img/mac/image-20220317195613561.png" srcset="/img/loading.gif" lazyload alt="image-20220317195613561"></p>
<p>要让无抢占不执行，只能把对应的进程 kill 掉让他释放资源。</p>
<p>将循环等待打破是可行的，将资源类型排序，。。。</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>进程获取资源前先进行判断，如果有可能发生死锁，就不把资源给他。要进行这样的判断需要一些条件</p>
<p><img src="/img/mac/image-20220317200145674.png" srcset="/img/loading.gif" lazyload alt="image-20220317200145674"></p>
<p>进程先确定自己需要的资源数量和大小等等，如果超出了自己的需求，系统就可以不给他分配资源。</p>
<p>动态检查进程获取资源后是否可能出现环，如果会出现就不给其分配资源</p>
<p><img src="/img/mac/image-20220317200750121.png" srcset="/img/loading.gif" lazyload alt="image-20220317200750121"></p>
<p>安全序列：一个进程一定能够等到他所需要的资源从而顺利结束。就是对于一个进程 pi ， 他所需的资源可以由 p0 到 pi-1 所拥有的资源满足。</p>
<p><img src="/img/mac/image-20220317201345547.png" srcset="/img/loading.gif" lazyload alt="image-20220317201345547"></p>
<p><img src="/img/mac/image-20220317201436043.png" srcset="/img/loading.gif" lazyload alt="image-20220317201436043"></p>
<p>虚线表示进程所需要的资源。</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>简单点 说就是银行贷款钱一定要收的回来，如果钱没法回来，就不给他钱。<img src="/img/mac/image-20220318085930854.png" srcset="/img/loading.gif" lazyload alt="image-20220318085930854"></p>
<p><img src="/img/mac/image-20220318090131091.png" srcset="/img/loading.gif" lazyload alt="image-20220318090131091"></p>
<p>寻找我们前面所说的 safe 序列</p>
<p><img src="/img/mac/image-20220318090625347.png" srcset="/img/loading.gif" lazyload alt="image-20220318090625347"></p>
<p>max 矩阵：pi 需要资源 rj 的资源个数</p>
<p>available</p>
<p>allocation：pi 已有资源 rj 的个数</p>
<p>need ： pi 未来可能需要资源 rj 的个数</p>
<p>need= max - allocationa</p>
<p><img src="/img/mac/image-20220318091205552.png" srcset="/img/loading.gif" lazyload alt="image-20220318091205552"></p>
<p>finish i = true 表示进程的资源可以得到满足，并且正常结束</p>
<p>如果 need i 的每一个资源都小于 work</p>
<p>这个进程就能正常结束</p>
<p>这个进程正常结束后，这个进程所拥有的资源全部释放，转给 work</p>
<p>上述为判断安全的算法，我们接下来以他为基础来构建银行家算法</p>
<p><img src="/img/mac/image-20220318091620719.png" srcset="/img/loading.gif" lazyload alt="image-20220318091620719"></p>
<p>举个例子</p>
<p><img src="/img/mac/image-20220318091952493.png" srcset="/img/loading.gif" lazyload alt="image-20220318091952493"></p>
<p><img src="/img/mac/image-20220318092008662.png" srcset="/img/loading.gif" lazyload alt="image-20220318092008662"></p>
<p>首先找一个进程所需资源 need&lt;available</p>
<p>找到了 p2，所以把 p2 的 allocate 还给 available</p>
<p>接着，我们可以选择 p1，流程和上面是一样的。继续实现下去我们就能得到一个 safe 序列。</p>
<p>另一个例子</p>
<p>如果 available 原先是 112，p1 发起一次 101 的资源获取请求之后变成这样</p>
<p><img src="/img/mac/image-20220318092724846.png" srcset="/img/loading.gif" lazyload alt="image-20220318092724846"></p>
<p>这时候没有一个进程的资源能够得到满足，说明这是一个 unsafe 队列，我们的银行家算法不会满足这次 p1 的资源请求</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>和上面的死锁避免相比，我们的条件再次放宽</p>
<p><img src="/img/mac/image-20220318092934188.png" srcset="/img/loading.gif" lazyload alt="image-20220318092934188"></p>
<p>可以死锁，死锁后将其查出来。</p>
<p>我们对上面的资源分配图简化一下，变成进程等待图</p>
<p><img src="/img/mac/image-20220318093106060.png" srcset="/img/loading.gif" lazyload alt="image-20220318093106060"></p>
<p><img src="/img/mac/image-20220318093132432.png" srcset="/img/loading.gif" lazyload alt="image-20220318093132432"></p>
<h4 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h4><p><img src="/img/mac/image-20220318093343953.png" srcset="/img/loading.gif" lazyload alt="image-20220318093343953"></p>
<p>我们一般很少使用银行家算法和死锁检测算法，一个是系统很难知道每个进程所需要的资源总数，一个是死锁检测开销很大。</p>
<p><img src="/img/mac/image-20220318094441978.png" srcset="/img/loading.gif" lazyload alt="image-20220318094441978"></p>
<p>available 初始值为 000</p>
<p>safe 队列的顺序是 p0 p2 p1 p3 p4</p>
<p>有可能出现死锁的情况</p>
<p><img src="/img/mac/image-20220318094541898.png" srcset="/img/loading.gif" lazyload alt="image-20220318094541898"></p>
<p><img src="/img/mac/image-20220318094911813.png" srcset="/img/loading.gif" lazyload alt="image-20220318094911813"></p>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>如果已经发生死锁了，看下如何解决</p>
<p>一般是 kill 一个进程，判断的依据如下</p>
<p><img src="/img/mac/image-20220318095031507.png" srcset="/img/loading.gif" lazyload alt="image-20220318095031507"></p>
<p><img src="/img/mac/image-20220318095246411.png" srcset="/img/loading.gif" lazyload alt="image-20220318095246411"></p>
<p>正常操作系统一般都是用鸵鸟办法，就是不管死锁，出现了就 reboot</p>
<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h2><p><img src="/img/mac/image-20220318095606638.png" srcset="/img/loading.gif" lazyload alt="image-20220318095606638"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/img/mac/image-20220318095722807.png" srcset="/img/loading.gif" lazyload alt="image-20220318095722807"></p>
<p>间接通信和直接通信</p>
<p><img src="/img/mac/image-20220318095809696.png" srcset="/img/loading.gif" lazyload alt="image-20220318095809696"></p>
<p>左边类似于发邮件，邮件先投递到邮局，再转交。</p>
<p><img src="/img/mac/image-20220318095918007.png" srcset="/img/loading.gif" lazyload alt="image-20220318095918007"></p>
<p>通信链路的建立需要操作系统来完成</p>
<p><img src="/img/mac/image-20220318100018653.png" srcset="/img/loading.gif" lazyload alt="image-20220318100018653"></p>
<p><img src="/img/mac/image-20220318100111196.png" srcset="/img/loading.gif" lazyload alt="image-20220318100111196"></p>
<p>从发送的路径来看可以分为直接和间接</p>
<p>阻塞，发消息的时候发送者进入 block，知道消息被接受；接受时，接受者阻塞直到这个消息是 available 的</p>
<p>非阻塞，sender 发送消息并且能持续执行；</p>
<p><img src="/img/mac/image-20220318100249506.png" srcset="/img/loading.gif" lazyload alt="image-20220318100249506"></p>
<p>通信链路缓冲</p>
<p>发送的数据有一个缓存，当缓存的容量有三种以下情况</p>
<p><img src="/img/mac/image-20220318100616756.png" srcset="/img/loading.gif" lazyload alt="image-20220318100616756"></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>signal 类似于硬件的中断机制，由软件打断当前正在运行的应用程序</p>
<p><img src="/img/mac/image-20220318100932053.png" srcset="/img/loading.gif" lazyload alt="image-20220318100932053"></p>
<p>catch：产生哪个信号，做哪种响应</p>
<p>信号一般只起通知作用，不传输数据。</p>
<p>具体实现</p>
<p><img src="/img/mac/image-20220318101523946.png" srcset="/img/loading.gif" lazyload alt="image-20220318101523946"></p>
<p>应用程序先注册针对某个信号的 handle 给 os，当产生对应的信号后，会让该应用程序调用对应的信号处理函数；</p>
<p>当 os 收到信号时，他运行在内核态；当要返回用户态去执行相应信号的那个应用程序时，他返回的点是调用信号处理函数的地方，这是通过修改应用程序的调用堆栈实现的。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是用来数据交换的，是很早的进程间通信机制。</p>
<p>其实很像 linux 的管道符</p>
<p>把管道符前面的结果作为管道符后面的输入</p>
<p>把输出重定向为管道，不是原来的 stdout</p>
<p><img src="/img/mac/image-20220318102720762.png" srcset="/img/loading.gif" lazyload alt="image-20220318102720762"></p>
<p>管道实际上就是内核中的一个 buffer</p>
<p>shell 是 ls 和 more 的父进程，子进程可以继承一些父进程的资源</p>
<p>​</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>和管道的区别</p>
<p>管道其实是父进程帮子进程建立好的通道</p>
<p>如果没有父子关系，就无法正常运作。</p>
<p>管道里的数据是一种字节流，没有结构化的表示形式。</p>
<p>这两种在消息队列里都可以解决</p>
<p>没有父子关系，字符流等等。。。</p>
<p><img src="/img/mac/image-20220318103559456.png" srcset="/img/loading.gif" lazyload alt="image-20220318103559456"></p>
<h3 id="共享空间"><a href="#共享空间" class="headerlink" title="共享空间"></a>共享空间</h3><p>操作系统创建的共享区域，每个进程都可以读和写，但是需要同步互斥来保证其安全性。</p>
<p><img src="/img/mac/image-20220318103707853.png" srcset="/img/loading.gif" lazyload alt="image-20220318103707853"></p>
<p><img src="/img/mac/image-20220318103942389.png" srcset="/img/loading.gif" lazyload alt="image-20220318103942389"></p>
<p>不同的逻辑地址映射同一块物理地址空间。</p>
<h1 id="第十二课-文件系统"><a href="#第十二课-文件系统" class="headerlink" title="第十二课 文件系统"></a>第十二课 文件系统</h1><p><img src="/img/mac/image-20220318105155526.png" srcset="/img/loading.gif" lazyload alt="image-20220318105155526"></p>
<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/img/mac/image-20220318105337112.png" srcset="/img/loading.gif" lazyload alt="image-20220318105337112"></p>
<h3 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h3><p>定义</p>
<p><img src="/img/mac/image-20220318105918029.png" srcset="/img/loading.gif" lazyload alt="image-20220318105918029"></p>
<p>很多地方都存在文件系统；存储的最小粒度都是文件。创建、删除、读写的也都是文件。</p>
<p>硬盘眼中的文件</p>
<p><img src="/img/mac/image-20220318110131277.png" srcset="/img/loading.gif" lazyload alt="image-20220318110131277"></p>
<p>文件和块</p>
<p><img src="/img/mac/image-20220318110346598.png" srcset="/img/loading.gif" lazyload alt="image-20220318110346598"></p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p><img src="/img/mac/image-20220318110513636.png" srcset="/img/loading.gif" lazyload alt="image-20220318110513636"></p>
<p>文件使用模式：这个 f 就是文件描述符，是一个整数。也是打开文件表的索引。</p>
<p><img src="/img/mac/image-20220318110749255.png" srcset="/img/loading.gif" lazyload alt="image-20220318110749255"></p>
<p>文件打开计数：只有没有进程在使用文件时，才能把文件从内存中抹去。</p>
<p>访问权限：每个程序对这个文件是只读还是其他的。</p>
<p><img src="/img/mac/image-20220318111130240.png" srcset="/img/loading.gif" lazyload alt="image-20220318111130240"></p>
<p>磁盘访问的基本单位是一个扇区</p>
<p><img src="/img/mac/image-20220318111402627.png" srcset="/img/loading.gif" lazyload alt="image-20220318111402627"></p>
<p>用户看到的是一个抽象的一维空间，操作系统看到的是一个个块。</p>
<p><img src="/img/mac/image-20220318111457035.png" srcset="/img/loading.gif" lazyload alt="image-20220318111457035"></p>
<p>文件结构</p>
<p><img src="/img/mac/image-20220318111908089.png" srcset="/img/loading.gif" lazyload alt="image-20220318111908089"></p>
<p>这些结构由应用程序来识别，操作系统只以一种简洁的/统一的方式来理解他们（一串普通的字节流)</p>
<p>访问控制</p>
<p>linux 读写执行等等</p>
<p><img src="/img/mac/image-20220318112110916.png" srcset="/img/loading.gif" lazyload alt="image-20220318112110916"></p>
<p>语义</p>
<p>一个用户对用户的写入对其他人是否可见</p>
<p><img src="/img/mac/image-20220318112505107.png" srcset="/img/loading.gif" lazyload alt="image-20220318112505107"></p>
<p>确保写同一块内容有同步互斥机制。</p>
<p>锁：以文件为锁，或者以文件的某一块作为锁，可以有不同粒度的实现。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="/img/mac/image-20220318112853605.png" srcset="/img/loading.gif" lazyload alt="image-20220318112853605"></p>
<p>对目录有哪些操作</p>
<p><img src="/img/mac/image-20220318112953652.png" srcset="/img/loading.gif" lazyload alt="image-20220318112953652"></p>
<p>目录里的文件怎么存？</p>
<p>数组/链表/hash</p>
<p><img src="/img/mac/image-20220318113125505.png" srcset="/img/loading.gif" lazyload alt="image-20220318113125505"></p>
<p>路径遍历</p>
<p><img src="/img/mac/image-20220318113203969.png" srcset="/img/loading.gif" lazyload alt="image-20220318113203969"></p>
<p>挂载</p>
<p><img src="/img/mac/image-20220318113457887.png" srcset="/img/loading.gif" lazyload alt="image-20220318113457887"></p>
<p>不同类型的文件系统要挂在不同的目录。挂载点在用户看来是一个目录，代表了根的起始位置。</p>
<h3 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h3><p><img src="/img/mac/image-20220318113943889.png" srcset="/img/loading.gif" lazyload alt="image-20220318113943889"></p>
<p>软连接：一个文件的内容存的是另一个文件的路径名</p>
<p><img src="/img/mac/image-20220318114246021.png" srcset="/img/loading.gif" lazyload alt="image-20220318114246021"></p>
<p>删除了一个有别名的文件 yinyong，只是他的文件引用数量减少了 1，并没有完全删除，这种方式可以用 backpointers 来实现。</p>
<p>潜在风险</p>
<p><img src="/img/mac/image-20220318114811727.png" srcset="/img/loading.gif" lazyload alt="image-20220318114811727"></p>
<h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><p><img src="/img/mac/image-20220318144114875.png" srcset="/img/loading.gif" lazyload alt="image-20220318144114875"></p>
<p>日志文件系统：保证内容一致性的问题，防止因掉电而丢失数据等。如 mysql 的 redolog 和 undolog。</p>
<p>其他文件系统没有过多的深入了解。</p>
<p>想更多的了解可以查看维基百科。</p>
<p>分布式文件系统</p>
<p><img src="/img/mac/image-20220318144733701.png" srcset="/img/loading.gif" lazyload alt="image-20220318144733701"></p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>站在实现的角度来理解文件系统</p>
<p><img src="/img/mac/image-20220318145038802.png" srcset="/img/loading.gif" lazyload alt="image-20220318145038802"></p>
<p>屏蔽应用程序对不同的文件系统的差异性，只提供了文件系统 api，这些 api 其实就是简单的 read write ， 但是应用程序看到这些就足够了。</p>
<p>另一个角度，文件系统有可能是不同的形式，如 network io，虽然底层存在差异，但是通过虚拟文件系统，可以屏蔽这些不一致。</p>
<p><img src="/img/mac/image-20220318145640781.png" srcset="/img/loading.gif" lazyload alt="image-20220318145640781"></p>
<p>文件系统、文件、目录的元数据</p>
<p><img src="/img/mac/image-20220318150037321.png" srcset="/img/loading.gif" lazyload alt="image-20220318150037321"></p>
<p><img src="/img/mac/image-20220318150235386.png" srcset="/img/loading.gif" lazyload alt="image-20220318150235386"></p>
<p>三个块都会映射到磁盘中的扇区</p>
<p><img src="/img/mac/image-20220318150337122.png" srcset="/img/loading.gif" lazyload alt="image-20220318150337122"></p>
<p>我们什么时候把文件系统加载到内存中？</p>
<p><img src="/img/mac/image-20220318150427738.png" srcset="/img/loading.gif" lazyload alt="image-20220318150427738"></p>
<h2 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h2><p>把常用的数据缓冲到内存，加快查询速度。</p>
<p><img src="/img/mac/image-20220318150715435.png" srcset="/img/loading.gif" lazyload alt="image-20220318150715435"></p>
<p><img src="/img/mac/image-20220318150849097.png" srcset="/img/loading.gif" lazyload alt="image-20220318150849097"></p>
<p>类似于页替换算法</p>
<p><img src="/img/mac/image-20220318151007899.png" srcset="/img/loading.gif" lazyload alt="image-20220318151007899"></p>
<h2 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h2><p>把文件控制块的内容读到内存中</p>
<p>根据 f= read（），找到对应的文件表</p>
<p><img src="/img/mac/image-20220318151306935.png" srcset="/img/loading.gif" lazyload alt="image-20220318151306935"></p>
<p>找到对应的文件后，根据一个 offset，来确定要对文件中的哪一块进行读或者写。</p>
<p>offset 经过转换变成 disk 的一个扇区内的编号，文件系统把具体的数据读到内存中来。</p>
<p><img src="/img/mac/image-20220318151731931.png" srcset="/img/loading.gif" lazyload alt="image-20220318151731931"></p>
<p>一些保护机制</p>
<p><img src="/img/mac/image-20220318151811608.png" srcset="/img/loading.gif" lazyload alt="image-20220318151811608"></p>
<h2 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h2><p><img src="/img/mac/image-20220318151935490.png" srcset="/img/loading.gif" lazyload alt="image-20220318151935490"></p>
<p><img src="/img/mac/image-20220318152020907.png" srcset="/img/loading.gif" lazyload alt="image-20220318152020907"></p>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p><img src="/img/mac/image-20220318152131908.png" srcset="/img/loading.gif" lazyload alt="image-20220318152131908"></p>
<p>如果要对文件做扩展，而后面已经有文件了，那开销挺大。</p>
<p>分配策略可以参考内存的最佳适配，最差适配，首次适配等等。</p>
<h3 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h3><p><img src="/img/mac/image-20220318152643126.png" srcset="/img/loading.gif" lazyload alt="image-20220318152643126"></p>
<p>不能高效的进行随机访问。</p>
<h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>指向这些文件的数据放在哪个索引数据块</p>
<p><img src="/img/mac/image-20220318152833224.png" srcset="/img/loading.gif" lazyload alt="image-20220318152833224"></p>
<p>大文件的索引分配</p>
<p>将索引分级等</p>
<p><img src="/img/mac/image-20220318153053760.png" srcset="/img/loading.gif" lazyload alt="image-20220318153053760"></p>
<p>早期 unix 的索引分级</p>
<p><img src="/img/mac/image-20220318153314140.png" srcset="/img/loading.gif" lazyload alt="image-20220318153314140"></p>
<p><img src="/img/mac/image-20220318153338618.png" srcset="/img/loading.gif" lazyload alt="image-20220318153338618"></p>
<h2 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h2><p><img src="/img/mac/image-20220318153648848.png" srcset="/img/loading.gif" lazyload alt="image-20220318153648848"></p>
<p>安全性的保证</p>
<p><img src="/img/mac/image-20220318153824536.png" srcset="/img/loading.gif" lazyload alt="image-20220318153824536"></p>
<p>其他形式：</p>
<p><img src="/img/mac/image-20220318153925945.png" srcset="/img/loading.gif" lazyload alt="image-20220318153925945"></p>
<h2 id="多磁盘管理"><a href="#多磁盘管理" class="headerlink" title="多磁盘管理"></a>多磁盘管理</h2><p><img src="/img/mac/image-20220318154232176.png" srcset="/img/loading.gif" lazyload alt="image-20220318154232176"></p>
<p><img src="/img/mac/image-20220318154349159.png" srcset="/img/loading.gif" lazyload alt="image-20220318154349159"></p>
<p><img src="/img/mac/image-20220318154517682.png" srcset="/img/loading.gif" lazyload alt="image-20220318154517682"></p>
<p>软 raid，操作系统位于磁盘之上进行磁盘管理。</p>
<p>硬 raid，将磁盘管理置入芯片中。</p>
<p>Raid0:</p>
<p><img src="/img/mac/image-20220318154844102.png" srcset="/img/loading.gif" lazyload alt="image-20220318154844102"></p>
<p>把不同的数据放在不同的硬盘上，把这些数据并行的读取出来。</p>
<p>raid1:</p>
<p><img src="/img/mac/image-20220318154947692.png" srcset="/img/loading.gif" lazyload alt="image-20220318154947692"></p>
<p>Raid4:</p>
<p><img src="/img/mac/image-20220318155130911.png" srcset="/img/loading.gif" lazyload alt="image-20220318155130911"></p>
<p>用四个盘来进行并行，用一个盘来进行故障恢复。</p>
<p>瓶颈：故障恢复盘的读写非常频繁。</p>
<p>raid5:</p>
<p>保证了高可靠性，还提高了效率。</p>
<p>将奇偶校验分散到每个盘中</p>
<p><img src="/img/mac/image-20220318155431242.png" srcset="/img/loading.gif" lazyload alt="image-20220318155431242"></p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p><img src="/img/mac/image-20220318155827444.png" srcset="/img/loading.gif" lazyload alt="image-20220318155827444"></p>
<p><img src="/img/mac/image-20220318155950645.png" srcset="/img/loading.gif" lazyload alt="image-20220318155950645"></p>
<p>访问时间 = 寻道时间+旋转延迟时间+数据访问时间</p>
<p><img src="/img/mac/image-20220318160226944.png" srcset="/img/loading.gif" lazyload alt="image-20220318160226944"></p>
<p>随机 io 效率很低，因为要不停的寻道</p>
<p>fifo 的磁盘访问</p>
<p><img src="/img/mac/image-20220318160422893.png" srcset="/img/loading.gif" lazyload alt="image-20220318160422893"></p>
<p>简单，但是效率低</p>
<p><img src="/img/mac/image-20220318160518959.png" srcset="/img/loading.gif" lazyload alt="image-20220318160518959"></p>
<p>短服务优先</p>
<p><img src="/img/mac/image-20220318160553156.png" srcset="/img/loading.gif" lazyload alt="image-20220318160553156"></p>
<p>有可能导致饥饿现象，让磁头在一小块区域打转，有不公平性</p>
<p>电梯</p>
<p>磁头走到头，再走到尾</p>
<p><img src="/img/mac/image-20220318160750317.png" srcset="/img/loading.gif" lazyload alt="image-20220318160750317"></p>
<p>上面是两种方向，优化成仅在一种方向上扫描</p>
<p><img src="/img/mac/image-20220318160956174.png" srcset="/img/loading.gif" lazyload alt="image-20220318160956174"></p>
<p>走到一条路上最后的请求点</p>
<p><img src="/img/mac/image-20220318161130204.png" srcset="/img/loading.gif" lazyload alt="image-20220318161130204"></p>
<p><img src="/img/mac/image-20220318161255596.png" srcset="/img/loading.gif" lazyload alt="image-20220318161255596"></p>
<p><img src="/img/mac/image-20220318161355144.png" srcset="/img/loading.gif" lazyload alt="image-20220318161355144"></p>
<p>理解就好，实际情况跟这些完全不一样。</p>
<div class="code-wrapper"><pre><code class="hljs">1. *
</code></pre></div>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/os/">os</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/os/">os</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/12/JUC-1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JUC-1</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/11/hello-world/">
                        <span class="hidden-mobile">我的第一篇博客</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
