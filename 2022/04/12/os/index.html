

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bloo">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1uW411f72n?spm_id_from&#x3D;333.337.search-card.all.click，主要是对图做一些必要的解释，也许对你没有参考价值。。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-1">
<meta property="og:url" content="https://bloofcx.github.io/2022/04/12/os/index.html">
<meta property="og:site_name" content="Bloo">
<meta property="og:description" content="参考https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1uW411f72n?spm_id_from&#x3D;333.337.search-card.all.click，主要是对图做一些必要的解释，也许对你没有参考价值。。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314101541245.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314101702771.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314102014485.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314100629747.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314095722816.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314101327083.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314103806052.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314105742354.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314110510820.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314112645043.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314112823551.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314112916863.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314113334784.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314113712026.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314114124892.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314114350433.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314114700639.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314115723694.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314185910289.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190108570.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190325342.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190601181.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314190746834.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314185630289.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314191904592.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314192233279.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314192425671.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314192743746.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314193111494.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314193313426.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314193627988.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314194436384.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195201347.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195618170.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195742024.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314195837235.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200013810.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200259134.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200333132.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200523542.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314200559358.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314201008316.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314201033083.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314201309131.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202303944.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202337631.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202419821.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202502565.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202745466.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314202821052.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314203014295.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314203133547.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220314203451738.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315101750899.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315101830624.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102008501.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102313425.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102541329.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315102912248.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315103100186.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315103420007.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315103911075.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315104409112.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315104752933.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315105928232.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315110207423.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315110548448.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315110744311.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111139608.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111243805.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111540912.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315111755175.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315112622166.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315113008700.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315113244873.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315113708077.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114149061.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114343276.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114439108.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315114834832.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315115032588.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315115442930.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315115539550.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315140720888.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315140905840.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315141118766.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315141835271.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315141858679.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315142116822.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315142545605.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315142902768.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315143032359.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315153217040.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315144019183.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315144313435.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315144936056.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315145213412.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150017680.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150225932.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150444209.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150759529.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315150904269.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151306909.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151326311.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151547725.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151852730.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315151938981.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315152247073.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315152559378.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315153722011.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315154106879.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315154712009.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315155748580.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315160450793.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315160927016.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161141452.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161416331.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161656419.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161842043.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315161954935.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315162336046.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315162614428.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315163836144.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315163945697.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164208803.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164331593.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164545591.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315164828959.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315165622326.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315184540203.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315184709513.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315184849983.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315185637612.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315190028579.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315190220994.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315190459458.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191212264.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191508500.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191834893.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315191939659.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315192455070.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315192751422.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193451486.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193645495.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193735471.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193836928.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315193949135.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194216137.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194710456.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194837246.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315194938881.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195043941.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195132996.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195340624.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220315195402683.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316104711131.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316104833846.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316104929457.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105109329.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105202344.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105421244.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316105846558.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110104720.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110225989.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110446729.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110815007.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316110958953.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111059671.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111213808.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111321169.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111402830.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111613746.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316111849951.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316112319233.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316112357397.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316112943929.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113557923.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113706630.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113941988.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316113417809.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114047677.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114323630.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114516719.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316114732929.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316115003158.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316115157753.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143325894.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143400299.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143447159.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316141202432.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316141359910.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316142449864.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143133176.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143650881.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316143953869.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316144140317.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316144211754.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316144400307.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316145011673.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316145619754.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220316145756774.png">
<meta property="article:published_time" content="2022-04-12T14:24:14.000Z">
<meta property="article:modified_time" content="2022-04-12T14:49:52.648Z">
<meta property="article:author" content="Bloo">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://bloofcx.github.io/img/mac/image-20220314101541245.png">
  
  
  <title>操作系统-1 - Bloo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"bloofcx.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bloo | LongMayTheSunShine</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统-1">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-12 22:24" pubdate>
        April 12, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.3k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      69 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统-1</h1>
            
            <div class="markdown-body">
              <h1 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h1><h2 id="从用户角度来看"><a href="#从用户角度来看" class="headerlink" title="从用户角度来看"></a>从用户角度来看</h2><p><img src="/img/mac/image-20220314101541245.png" srcset="/img/loading.gif" lazyload alt="image-20220314101541245"></p>
<h2 id="操作系统的层次架构"><a href="#操作系统的层次架构" class="headerlink" title="操作系统的层次架构"></a>操作系统的层次架构</h2><p><img src="/img/mac/image-20220314101702771.png" srcset="/img/loading.gif" lazyload alt="image-20220314101702771"></p>
<h2 id="os-kernel-和-shell"><a href="#os-kernel-和-shell" class="headerlink" title="os kernel 和 shell"></a>os kernel 和 shell</h2><p><img src="/img/mac/image-20220314102014485.png" srcset="/img/loading.gif" lazyload alt="image-20220314102014485"></p>
<p>shell 可以理解为操作系统提供的对外进行管理的接口。我们要学习的是操作系统的 kernel。</p>
<h2 id="kernel-要管理的硬件"><a href="#kernel-要管理的硬件" class="headerlink" title="kernel 要管理的硬件"></a>kernel 要管理的硬件</h2><p><img src="/img/mac/image-20220314100629747.png" srcset="/img/loading.gif" lazyload alt="image-20220314100629747"></p>
<h2 id="os-Kernel-的特征"><a href="#os-Kernel-的特征" class="headerlink" title="os Kernel 的特征"></a>os Kernel 的特征</h2><ul>
<li>并行：一个时间点上有多个程序执行，一般要求多核 cpu。但是 kernel 的特征是并发。并发是一段时间内有多个程序执行。</li>
<li>虚拟：操作系统将 cpu 抽象成进程，将磁盘抽象成文件，将内存抽象成地址空间。</li>
</ul>
<p><img src="/img/mac/image-20220314095722816.png" srcset="/img/loading.gif" lazyload alt="image-20220314095722816"></p>
<ul>
<li>异步：需要保证结果相同，1+1 一定也是等于 2 的。</li>
<li><img src="/img/mac/image-20220314101327083.png" srcset="/img/loading.gif" lazyload alt="image-20220314101327083"></li>
</ul>
<h2 id="操作系统需要从更高的角度来学习。"><a href="#操作系统需要从更高的角度来学习。" class="headerlink" title="操作系统需要从更高的角度来学习。"></a>操作系统需要从更高的角度来学习。</h2><p><img src="/img/mac/image-20220314103806052.png" srcset="/img/loading.gif" lazyload alt="image-20220314103806052"></p>
<h2 id="调度线程，多道程序设计，分时操作的基本介绍"><a href="#调度线程，多道程序设计，分时操作的基本介绍" class="headerlink" title="调度线程，多道程序设计，分时操作的基本介绍"></a>调度线程，多道程序设计，分时操作的基本介绍</h2><p>我们知道，io 的效率远远低于 cpu 的效率，当 cpu read disk 的时候，可以去执行其他程序。这是多道程序设计。</p>
<p><img src="/img/mac/image-20220314105742354.png" srcset="/img/loading.gif" lazyload alt="image-20220314105742354"></p>
<p>分时操作的时间，把每个程序持有时间片的时间大大减少，如千分之一秒，随后不断的打断程序。</p>
<p>分时操作的好处：</p>
<p><img src="/img/mac/image-20220314110510820.png" srcset="/img/loading.gif" lazyload alt="image-20220314110510820"></p>
<h1 id="第二课-启动，中断，异常和系统调用"><a href="#第二课-启动，中断，异常和系统调用" class="headerlink" title="第二课-启动，中断，异常和系统调用"></a>第二课-启动，中断，异常和系统调用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>Bootloader 的作用:加载 os 到内存中</p>
<p>bios 是用来对一些硬件的处理</p>
<p><img src="/img/mac/image-20220314112645043.png" srcset="/img/loading.gif" lazyload alt="image-20220314112645043"></p>
<h3 id="启动的过程"><a href="#启动的过程" class="headerlink" title="启动的过程"></a>启动的过程</h3><p>x86 架构中，bios 从如图所示的这个地址开始执行</p>
<p><img src="/img/mac/image-20220314112823551.png" srcset="/img/loading.gif" lazyload alt="image-20220314112823551"></p>
<p>Bios 自检，加载硬件驱动</p>
<p><img src="/img/mac/image-20220314112916863.png" srcset="/img/loading.gif" lazyload alt="image-20220314112916863"></p>
<p>自检后，将 boot loader 从硬盘的第一个扇区加载到内存。boot loader 又接着把 os 从硬盘加载到内存中。</p>
<p><img src="/img/mac/image-20220314113334784.png" srcset="/img/loading.gif" lazyload alt="image-20220314113334784"></p>
<h2 id="系统调用，中断，异常"><a href="#系统调用，中断，异常" class="headerlink" title="系统调用，中断，异常"></a>系统调用，中断，异常</h2><h3 id="os-分别与硬件和程序打交道有以下几种形式："><a href="#os-分别与硬件和程序打交道有以下几种形式：" class="headerlink" title="os 分别与硬件和程序打交道有以下几种形式："></a>os 分别与硬件和程序打交道有以下几种形式：</h3><ul>
<li>对硬件采用中断</li>
<li>对应用程序采用系统调用和异常</li>
</ul>
<h3 id="他们的定义："><a href="#他们的定义：" class="headerlink" title="他们的定义："></a>他们的定义：</h3><p>异常是应用程序意想不到的行为，或者是恶意程序，又或是程序的资源得不到满足，这都应该被操作系统及时发现；</p>
<p><img src="/img/mac/image-20220314113712026.png" srcset="/img/loading.gif" lazyload alt="image-20220314113712026"></p>
<h3 id="为什么应用程序不能直接和硬件打交道？"><a href="#为什么应用程序不能直接和硬件打交道？" class="headerlink" title="为什么应用程序不能直接和硬件打交道？"></a>为什么应用程序不能直接和硬件打交道？</h3><p>应用程序可能不被信任；操作系统封装了对 device 的操作，只开放接口，不用关注硬件的细节；</p>
<p><img src="/img/mac/image-20220314114124892.png" srcset="/img/loading.gif" lazyload alt="image-20220314114124892"></p>
<h3 id="系统调用-中断-异常的特点和差异"><a href="#系统调用-中断-异常的特点和差异" class="headerlink" title="系统调用/中断/异常的特点和差异"></a>系统调用/中断/异常的特点和差异</h3><ul>
<li>产生的源头不同</li>
</ul>
<p><img src="/img/mac/image-20220314114350433.png" srcset="/img/loading.gif" lazyload alt="image-20220314114350433"></p>
<ul>
<li>处理时间</li>
</ul>
<p>异步是当事件产生的时候，应用程序根本不知道什么时候会产生；</p>
<p>异常是同步的，异常的指令触发了系统调用的请求，指令的位置是一个同步的时间点，是同步的；</p>
<p>系统调用中，返回结果的这个时间可能是同步（应用程序等待结果）；也可能是异步（应用程序接着去干其他事，然后 os 会发一个异步的消息告诉应用程序我事干完了）；请求调用的这个时间点是同步的。</p>
<p><img src="/img/mac/image-20220314114700639.png" srcset="/img/loading.gif" lazyload alt="image-20220314114700639"></p>
<ul>
<li>响应</li>
</ul>
<p><img src="/img/mac/image-20220314115723694.png" srcset="/img/loading.gif" lazyload alt="image-20220314115723694"></p>
<h3 id="中断和异常的处理机制"><a href="#中断和异常的处理机制" class="headerlink" title="中断和异常的处理机制"></a>中断和异常的处理机制</h3><h4 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h4><p><img src="/img/mac/image-20220314185910289.png" srcset="/img/loading.gif" lazyload alt="image-20220314185910289"></p>
<p>cpu 根据这个标记能够生成一个中断号，将其发给 os，os 根据中断号来进行处理。</p>
<p><img src="/img/mac/image-20220314190108570.png" srcset="/img/loading.gif" lazyload alt="image-20220314190108570"></p>
<p>可以看到对程序是透明的。</p>
<h4 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h4><p><img src="/img/mac/image-20220314190325342.png" srcset="/img/loading.gif" lazyload alt="image-20220314190325342"></p>
<p>发生异常后，也会产生一个异常编号，和上面中断的情况是类似的。如果异常处理中是重新执行异常指令，那么这个行为对程序来说也是透明的。</p>
<h3 id="系统调用的执行过程"><a href="#系统调用的执行过程" class="headerlink" title="系统调用的执行过程"></a>系统调用的执行过程</h3><p>简单的例子：os 开放一个接口给程序。</p>
<p><img src="/img/mac/image-20220314190601181.png" srcset="/img/loading.gif" lazyload alt="image-20220314190601181"></p>
<p><img src="/img/mac/image-20220314190746834.png" srcset="/img/loading.gif" lazyload alt="image-20220314190746834"></p>
<p><img src="/img/mac/image-20220314185630289.png" srcset="/img/loading.gif" lazyload alt="image-20220314185630289"></p>
<p>app 应用程序通过 library code 直接或者间接访问系统调用的接口，同时完成用户态转变内核态。</p>
<p>用户态：无法执行特权指令和 io 指令，无法控制计算机系统。</p>
<p>内核态：可以执行任意一个 os 指令。</p>
<p>开销：因为要完成堆栈的切换和特权级的转换，所以调用操作系统接口比普通函数的执行开销要更大。</p>
<h2 id="跨越操作系统边界的开销"><a href="#跨越操作系统边界的开销" class="headerlink" title="跨越操作系统边界的开销"></a>跨越操作系统边界的开销</h2><p><img src="/img/mac/image-20220314191904592.png" srcset="/img/loading.gif" lazyload alt="image-20220314191904592"></p>
<p>保证了应用程序在安全可靠的环境中执行，开销是值得的。</p>
<h1 id="第三课-操作系统管理物理内存"><a href="#第三课-操作系统管理物理内存" class="headerlink" title="第三课 操作系统管理物理内存"></a>第三课 操作系统管理物理内存</h1><h2 id="计算机体系结构-内存分层体系"><a href="#计算机体系结构-内存分层体系" class="headerlink" title="计算机体系结构/内存分层体系"></a>计算机体系结构/内存分层体系</h2><p><img src="/img/mac/image-20220314192233279.png" srcset="/img/loading.gif" lazyload alt="image-20220314192233279"></p>
<p>cpu 要访问的指令在什么地方</p>
<ul>
<li><p>L1 L2 Cache - cpu 内部。缓存小，高速</p>
</li>
<li><p>主存 速度相对 cache 慢，内存大</p>
</li>
</ul>
<p><img src="/img/mac/image-20220314192425671.png" srcset="/img/loading.gif" lazyload alt="image-20220314192425671"></p>
<p>操作系统内核做的事情-4 个。</p>
<p><img src="/img/mac/image-20220314192743746.png" srcset="/img/loading.gif" lazyload alt="image-20220314192743746"></p>
<p>内存不够的时候，会把不常用的数据临时的放在磁盘上，变成虚拟内存。</p>
<p><img src="/img/mac/image-20220314193111494.png" srcset="/img/loading.gif" lazyload alt="image-20220314193111494"></p>
<h2 id="地址空间-amp-地址生成"><a href="#地址空间-amp-地址生成" class="headerlink" title="地址空间&amp;地址生成"></a>地址空间&amp;地址生成</h2><h3 id="地址空间定义"><a href="#地址空间定义" class="headerlink" title="地址空间定义"></a>地址空间定义</h3><p>物理地址空间，主存上相应的位置</p>
<p>逻辑地址空间-&gt;应用程序看到的一个一维的地址空间，是易于访问的。</p>
<p>操作系统：逻辑地址空间会由 os 映射到物理地址空间上。</p>
<p><img src="/img/mac/image-20220314193313426.png" srcset="/img/loading.gif" lazyload alt="image-20220314193313426"></p>
<h3 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h3><h4 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h4><p>c 程序，汇编中函数的位置，变量的名字就是逻辑地址。他是一个便于用户理解的地址。</p>
<p><img src="/img/mac/image-20220314193627988.png" srcset="/img/loading.gif" lazyload alt="image-20220314193627988"></p>
<p>.o 文件中，把逻辑地址改为相对从 0 开始的地址。链接过程把多个.o 文件的合成一个.exe 文件。放在硬盘中的 exe 还要通过 loader 程序加载到内存中，图中最后一个图还有一个相应的偏移量。到这里为止都还是逻辑地址，是应用程序看到的地址。</p>
<p>总结：编译器把基于符号的地址空间变成基于逻辑地址的地址空间，操作系统可以进一步完成逻辑地址到物理地址的映射。</p>
<h4 id="物理地址生成"><a href="#物理地址生成" class="headerlink" title="物理地址生成"></a>物理地址生成</h4><p>1:cpu 把指令取出来，他的 ALU 部件需要参数，所以把指令中的逻辑地址交给 MMU。</p>
<p>2:MMU 根据地址转换表来查逻辑地址对应的物理地址，如果有那就返回；</p>
<p>3:如果没有，就会去内存中的 map 中找，如果找到了，cpu 就给主存发信息表示我要某个物理地址的内容，</p>
<p>4:内存把该内容通过总线传给 cpu。</p>
<p>操作系统在其中的作用：在这四步之前，生成逻辑地址和物理地址转换表。</p>
<p><img src="/img/mac/image-20220314194436384.png" srcset="/img/loading.gif" lazyload alt="image-20220314194436384"></p>
<h3 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h3><p><img src="/img/mac/image-20220314195201347.png" srcset="/img/loading.gif" lazyload alt="image-20220314195201347"></p>
<p>操作系统确保每一个程序可以访问的地址空间，包括起始地址和长度，如果超过这块空间，就会报 system memory error</p>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><img src="/img/mac/image-20220314195618170.png" srcset="/img/loading.gif" lazyload alt="image-20220314195618170"></p>
<p><img src="/img/mac/image-20220314195742024.png" srcset="/img/loading.gif" lazyload alt="image-20220314195742024"></p>
<h4 id="首次适配算法"><a href="#首次适配算法" class="headerlink" title="首次适配算法"></a>首次适配算法</h4><p><img src="/img/mac/image-20220314195837235.png" srcset="/img/loading.gif" lazyload alt="image-20220314195837235"></p>
<p>可用空闲空间分别是 1k 2k 500 bytes</p>
<p><img src="/img/mac/image-20220314200013810.png" srcset="/img/loading.gif" lazyload alt="image-20220314200013810"></p>
<p>优点</p>
<ul>
<li>简单</li>
<li>易于产生更大空闲块，向着地址空间的结尾</li>
</ul>
<p>劣势</p>
<ul>
<li>外部碎片 多次使用之后更为明显</li>
<li>不确定性</li>
</ul>
<h4 id="最优适配算法"><a href="#最优适配算法" class="headerlink" title="最优适配算法"></a>最优适配算法</h4><p><img src="/img/mac/image-20220314200259134.png" srcset="/img/loading.gif" lazyload alt="image-20220314200259134"></p>
<p>可以看出，空闲的 100 很难再被使用到了。</p>
<p><img src="/img/mac/image-20220314200333132.png" srcset="/img/loading.gif" lazyload alt="image-20220314200333132"></p>
<h4 id="最差适配算法"><a href="#最差适配算法" class="headerlink" title="最差适配算法"></a>最差适配算法</h4><p><img src="/img/mac/image-20220314200523542.png" srcset="/img/loading.gif" lazyload alt="image-20220314200523542"></p>
<p><img src="/img/mac/image-20220314200559358.png" srcset="/img/loading.gif" lazyload alt="image-20220314200559358"></p>
<p>三个算法总结：三个算法里，没有最好的。每个应用程序不同，需求也不同，是随机的可变的。不论哪种算法，都会产生内/外碎片。</p>
<p>这三种的办法产生的碎片如何处理？下面介绍 2 种</p>
<h4 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h4><p><img src="/img/mac/image-20220314201008316.png" srcset="/img/loading.gif" lazyload alt="image-20220314201008316"></p>
<p>紧致的方式，把内存空间压缩</p>
<p><img src="/img/mac/image-20220314201033083.png" srcset="/img/loading.gif" lazyload alt="image-20220314201033083"></p>
<p>什么时候做这个行为？</p>
<p>把程序从一个地方挪到另一个地方。</p>
<p>开销如何？</p>
<p>频繁的拷贝，开销是很大的。</p>
<h4 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h4><p><img src="/img/mac/image-20220314201309131.png" srcset="/img/loading.gif" lazyload alt="image-20220314201309131"></p>
<p>这时 p3 需要更多的内存，把 p4 所占的 memory 暂时放到 disk 上，让 p3 正常执行。</p>
<p>问题</p>
<p>把哪一个程序换出去？</p>
<p>什么时候换入换出？</p>
<p>开销？</p>
<p>换入换出是以一个程序为粒度，开销也是很大的。</p>
<h1 id="第四课-非连续内存管理"><a href="#第四课-非连续内存管理" class="headerlink" title="第四课 非连续内存管理"></a>第四课 非连续内存管理</h1><h2 id="为什么需要非连续内存"><a href="#为什么需要非连续内存" class="headerlink" title="为什么需要非连续内存"></a>为什么需要非连续内存</h2><p><img src="/img/mac/image-20220314202303944.png" srcset="/img/loading.gif" lazyload alt="image-20220314202303944"></p>
<p><img src="/img/mac/image-20220314202337631.png" srcset="/img/loading.gif" lazyload alt="image-20220314202337631"></p>
<p>解决内外碎片等等。</p>
<p><img src="/img/mac/image-20220314202419821.png" srcset="/img/loading.gif" lazyload alt="image-20220314202419821"></p>
<p>软件的开销较大，考虑硬件。</p>
<h2 id="如何管理非连续内存"><a href="#如何管理非连续内存" class="headerlink" title="如何管理非连续内存"></a>如何管理非连续内存</h2><p><img src="/img/mac/image-20220314202502565.png" srcset="/img/loading.gif" lazyload alt="image-20220314202502565"></p>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h4><p><img src="/img/mac/image-20220314202745466.png" srcset="/img/loading.gif" lazyload alt="image-20220314202745466"></p>
<p>应用程序自己往往也会有多个不同的逻辑段。</p>
<p>比如 jvm 中，也有 heap，stack，native stack，pc register，method area 多个不同的段。</p>
<p>可以把他们相应的分离出来。</p>
<p><img src="/img/mac/image-20220314202821052.png" srcset="/img/loading.gif" lazyload alt="image-20220314202821052"></p>
<p>左边是连续的虚拟地址，右边是</p>
<p>不连续的物理地址。</p>
<p><img src="/img/mac/image-20220314203014295.png" srcset="/img/loading.gif" lazyload alt="image-20220314203014295"></p>
<h4 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><p>段访问机制，用硬件来实现</p>
<p><img src="/img/mac/image-20220314203133547.png" srcset="/img/loading.gif" lazyload alt="image-20220314203133547"></p>
<p>从一维的逻辑地址空间通过段访问机制映射到不同的物理地址中去。而这些物理地址是由不同的段组成的。</p>
<p>硬件实现方案</p>
<p><img src="/img/mac/image-20220314203451738.png" srcset="/img/loading.gif" lazyload alt="image-20220314203451738"></p>
<p>其中段号就等于段表的索引，即 segment num。段表中包含了物理地址的起始位置和长度，从而确定相应的段在物理地址中的哪一块，如果不在合法的范围内，cpu 就会报一个异常让操作系统来 kill 或者重新执行该指令。</p>
<p>其中关键的是，这个段表就是由操作系统来生成的。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>目前主流的机制，分段已经用的很少了。现在往往都是以分页的形式来解决非连续内存管理。</p>
<h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>页的大小往往是固定不变的。</p>
<p><img src="/img/mac/image-20220315101750899.png" srcset="/img/loading.gif" lazyload alt="image-20220315101750899"></p>
<p>逻辑页和物理页的大小是相等的。</p>
<p><img src="/img/mac/image-20220315101830624.png" srcset="/img/loading.gif" lazyload alt="image-20220315101830624"></p>
<h5 id="物理地址页帧"><a href="#物理地址页帧" class="headerlink" title="物理地址页帧"></a>物理地址页帧</h5><p><img src="/img/mac/image-20220315102008501.png" srcset="/img/loading.gif" lazyload alt="image-20220315102008501"></p>
<p>9bit 是页帧内的偏移，7 个 bit 是帧号的大小</p>
<p><img src="/img/mac/image-20220315102313425.png" srcset="/img/loading.gif" lazyload alt="image-20220315102313425"></p>
<h5 id="逻辑地址页-page"><a href="#逻辑地址页-page" class="headerlink" title="逻辑地址页 page"></a>逻辑地址页 page</h5><p><img src="/img/mac/image-20220315102541329.png" srcset="/img/loading.gif" lazyload alt="image-20220315102541329"></p>
<p>计算过程和物理地址是一样的。</p>
<h4 id="页寻址方案"><a href="#页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案</h4><p>页号作为索引查找 page table 页表，page table 里面的内容是帧号。</p>
<p>得到帧号后，再加上偏移地址就能得到物理地址。</p>
<p>类似的，页表也是由操作系统来生成的。</p>
<p><img src="/img/mac/image-20220315102912248.png" srcset="/img/loading.gif" lazyload alt="image-20220315102912248"></p>
<p>注：逻辑地址的页和页帧大小一致，但逻辑地址更大，后面会介绍虚拟内存来解决二者大小不一致问题。</p>
<p><img src="/img/mac/image-20220315103100186.png" srcset="/img/loading.gif" lazyload alt="image-20220315103100186"></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="页表-pagetable-的结构和优化"><a href="#页表-pagetable-的结构和优化" class="headerlink" title="页表 pagetable 的结构和优化"></a>页表 pagetable 的结构和优化</h3><p><img src="/img/mac/image-20220315103420007.png" srcset="/img/loading.gif" lazyload alt="image-20220315103420007"></p>
<p>其中 flags 包括这个物理页帧是否存在，是否写过读过等。后面会再具体介绍。</p>
<p>逻辑地址空间有 16bit，64kb，而物理地址只有 32kb。所以，物理页帧无法和逻辑页一一对应。</p>
<p>resident bit 为 0 表示对应的物理页帧在内存中不存在，如果被 cpu 访问了会报异常。</p>
<p><img src="/img/mac/image-20220315103911075.png" srcset="/img/loading.gif" lazyload alt="image-20220315103911075"></p>
<p>页表还存在的问题：</p>
<p>1.空间，越小越好</p>
<p>2.时间，越快越好</p>
<p>如果页表太大，cpu cache 放不下，将会放在内存中，造成 2 次内存访问</p>
<p>间接访问，也是解决空间问题，类似于索引机制。</p>
<p><img src="/img/mac/image-20220315104409112.png" srcset="/img/loading.gif" lazyload alt="image-20220315104409112"></p>
<h4 id="性能优化之时间：tlb"><a href="#性能优化之时间：tlb" class="headerlink" title="性能优化之时间：tlb"></a>性能优化之时间：tlb</h4><p><img src="/img/mac/image-20220315104752933.png" srcset="/img/loading.gif" lazyload alt="image-20220315104752933"></p>
<p>Tlb 存在于 cpu 上的 mmu 内存访问单元</p>
<p>他是一个 key value 的快表。</p>
<p>存的是 p 和 f，对应的是页号和帧号。</p>
<p>如果 tlb 命中，返回。</p>
<p>如果 tlb miss 未命中，查 pagetable，将其放入 tlb，返回。x86 架构中，这个行为是硬件自身完成的；mips 架构是由操作系统来完成，也就是软件支撑。</p>
<h4 id="性能优化之空间：二级页表"><a href="#性能优化之空间：二级页表" class="headerlink" title="性能优化之空间：二级页表"></a>性能优化之空间：二级页表</h4><p>一级页表存的是第二级页表的起始地址，这个地址再跟 p2 进行相加作为索引去二级页表中查找相应的值，得到 frame number。</p>
<p><img src="/img/mac/image-20220315105928232.png" srcset="/img/loading.gif" lazyload alt="image-20220315105928232"></p>
<p>多次查找开销不是很大吗？</p>
<p>一级页表中，如果 resident 标志位为 0，二级页表中根本不需要存在。这就省了很多空间，尤其是在多级页表的情况下。</p>
<p>推广到多级页表：</p>
<p><img src="/img/mac/image-20220315110207423.png" srcset="/img/loading.gif" lazyload alt="image-20220315110207423"></p>
<p>典型的以时间换取空间。</p>
<h4 id="性能优化之空间：反向页表"><a href="#性能优化之空间：反向页表" class="headerlink" title="性能优化之空间：反向页表"></a>性能优化之空间：反向页表</h4><p>因为之前介绍的页表的大小均和逻辑地址大小挂钩，但是逻辑地址比较大，也就造成了页表很大。</p>
<p>有没有办法让页表和物理地址挂钩？让索引变成帧号，内容成为页号。</p>
<p><img src="/img/mac/image-20220315110548448.png" srcset="/img/loading.gif" lazyload alt="image-20220315110548448"></p>
<p>需要解决的问题，我们 cpu 得到的是逻辑页号，怎么解决和帧号的对应。</p>
<p>页寄存器</p>
<p><img src="/img/mac/image-20220315110744311.png" srcset="/img/loading.gif" lazyload alt="image-20220315110744311"></p>
<p>关联内存</p>
<p><img src="/img/mac/image-20220315111139608.png" srcset="/img/loading.gif" lazyload alt="image-20220315111139608"></p>
<p><img src="/img/mac/image-20220315111243805.png" srcset="/img/loading.gif" lazyload alt="image-20220315111243805"></p>
<p>哈希 table</p>
<p><img src="/img/mac/image-20220315111540912.png" srcset="/img/loading.gif" lazyload alt="image-20220315111540912"></p>
<p>存在 hash 碰撞问题</p>
<p><img src="/img/mac/image-20220315111755175.png" srcset="/img/loading.gif" lazyload alt="image-20220315111755175"></p>
<h1 id="第五课-虚拟内存"><a href="#第五课-虚拟内存" class="headerlink" title="第五课 虚拟内存"></a>第五课 虚拟内存</h1><p><img src="/img/mac/image-20220315112622166.png" srcset="/img/loading.gif" lazyload alt="image-20220315112622166"></p>
<p>越快的存储器离 cpu 越近。</p>
<p><img src="/img/mac/image-20220315113008700.png" srcset="/img/loading.gif" lazyload alt="image-20220315113008700"></p>
<p><img src="/img/mac/image-20220315113244873.png" srcset="/img/loading.gif" lazyload alt="image-20220315113244873"></p>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>覆盖：把常用的代码放到内存中，不用的先放到硬盘中；需要的时候再拿出，进行一个覆盖。</p>
<p>早期微软的 dos 系统就是采用覆盖技术 80 - 90 年代。</p>
<p><img src="/img/mac/image-20220315113708077.png" srcset="/img/loading.gif" lazyload alt="image-20220315113708077"></p>
<p>没有相关调用关系的代码块先放到硬盘。a-b,a-c 的例子。</p>
<p><img src="/img/mac/image-20220315114149061.png" srcset="/img/loading.gif" lazyload alt="image-20220315114149061"></p>
<p>另一种调用关系、覆盖方法：</p>
<p>可以看到，通过程序员的安排，把空间用到极致。</p>
<p><img src="/img/mac/image-20220315114343276.png" srcset="/img/loading.gif" lazyload alt="image-20220315114343276"></p>
<p>缺点：</p>
<p>覆盖关系不好确定</p>
<p>频繁换入换出开销大</p>
<p><img src="/img/mac/image-20220315114439108.png" srcset="/img/loading.gif" lazyload alt="image-20220315114439108"></p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>unix 早期提出的方法。</p>
<p>交换：把不常用的程序放到硬盘里，把内存空间让出来，让正在运行的程序有更大的内存可以使用。<img src="/img/mac/image-20220315114834832.png" srcset="/img/loading.gif" lazyload alt="image-20220315114834832"></p>
<p><img src="/img/mac/image-20220315115032588.png" srcset="/img/loading.gif" lazyload alt="image-20220315115032588"></p>
<p>实现过程中的问题：</p>
<p><img src="/img/mac/image-20220315115442930.png" srcset="/img/loading.gif" lazyload alt="image-20220315115442930"></p>
<p>重定位：可能换出的那个时候的地址已经被占用了，换入的时候地址又要重新考虑</p>
<p>覆盖和交换的比较：</p>
<p><img src="/img/mac/image-20220315115539550.png" srcset="/img/loading.gif" lazyload alt="image-20220315115539550"></p>
<h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2><p>虚拟内存管理技术。</p>
<p>前面介绍的覆盖和交换都存在一些弊端。</p>
<p>一个增加程序员负担，一个粒度太大导致开销大。</p>
<p><img src="/img/mac/image-20220315140720888.png" srcset="/img/loading.gif" lazyload alt="image-20220315140720888"></p>
<p>让粒度更小，并且带有覆盖的特征。</p>
<p><img src="/img/mac/image-20220315140905840.png" srcset="/img/loading.gif" lazyload alt="image-20220315140905840"></p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>为了让内存管理完全依赖于 os，需要程序带有局部性。</p>
<p><img src="/img/mac/image-20220315141118766.png" srcset="/img/loading.gif" lazyload alt="image-20220315141118766"></p>
<p><img src="/img/mac/image-20220315141835271.png" srcset="/img/loading.gif" lazyload alt="image-20220315141835271"></p>
<p>一个例子：每页大小 4k,内存也定为 4k。1024 * 4byte = 4k</p>
<p><img src="/img/mac/image-20220315141858679.png" srcset="/img/loading.gif" lazyload alt="image-20220315141858679"></p>
<p>缺页异常：要频繁的把每个页都读取到内存中。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>操作系统可以在分段和分页的基础之上，来进行虚存管理</p>
<p><img src="/img/mac/image-20220315142116822.png" srcset="/img/loading.gif" lazyload alt="image-20220315142116822"></p>
<h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p><img src="/img/mac/image-20220315142545605.png" srcset="/img/loading.gif" lazyload alt="image-20220315142545605"></p>
<p>程序是感觉不到内存的具体大小的，处理过程都给 os 来执行，程序会感受到自己可用的空间是足够的。</p>
<p>交换的粒度相对于交换技术来说更小。</p>
<p>换入换出的机制，可能 os 会把虚拟地址空间中连续的代码换出。</p>
<h3 id="虚拟页式内存管理"><a href="#虚拟页式内存管理" class="headerlink" title="虚拟页式内存管理"></a>虚拟页式内存管理</h3><p><img src="/img/mac/image-20220315142902768.png" srcset="/img/loading.gif" lazyload alt="image-20220315142902768"></p>
<p>其中 resident 在接下来的管理有关键作用。</p>
<p><img src="/img/mac/image-20220315143032359.png" srcset="/img/loading.gif" lazyload alt="image-20220315143032359"></p>
<p>上图的请求调用机制就是由 resident bit 来实现的。</p>
<p>页面置换：需要一些算法，把不常用的页帧换出，后面介绍。</p>
<p>页表结构再深入</p>
<p><img src="/img/mac/image-20220315153217040.png" srcset="/img/loading.gif" lazyload alt="image-20220315153217040"></p>
<p>修改位：代表这个页是否被写过。被写过后内存和磁盘的数据是不一致的，需要刷盘。</p>
<p>驻留位：resident，已经介绍过。</p>
<p>Mov reg,0</p>
<p>0 对应的页帧是 2，通过计算公式</p>
<p>2*页大小 4k + 偏移 = 8192，得到对应的物理地址 8192。</p>
<p>mov reg 32768，对应第 8 位，驻留位是 0 的情况，发生缺页中断。需要操作系统把页从外存中调入。</p>
<p><img src="/img/mac/image-20220315144019183.png" srcset="/img/loading.gif" lazyload alt="image-20220315144019183"></p>
<p>缺页中断执行流程：</p>
<p><img src="/img/mac/image-20220315144313435.png" srcset="/img/loading.gif" lazyload alt="image-20220315144313435"></p>
<p>内存的各个段在外存中的存储形式：后备存储</p>
<p><img src="/img/mac/image-20220315144936056.png" srcset="/img/loading.gif" lazyload alt="image-20220315144936056"></p>
<h3 id="虚拟内存性能"><a href="#虚拟内存性能" class="headerlink" title="虚拟内存性能"></a>虚拟内存性能</h3><p><img src="/img/mac/image-20220315145213412.png" srcset="/img/loading.gif" lazyload alt="image-20220315145213412"></p>
<p>p ： 缺页的比例</p>
<p>q ： 进行了写操作的页</p>
<p>1+q：因为是脏页要写入磁盘，又要多访问一次磁盘。</p>
<p>如果程序有局部性原理，产生缺页的情况就会大大减少，让效率更高。</p>
<h1 id="第六课-页面置换算法"><a href="#第六课-页面置换算法" class="headerlink" title="第六课 页面置换算法"></a>第六课 页面置换算法</h1><h2 id="功能目标"><a href="#功能目标" class="headerlink" title="功能目标"></a>功能目标</h2><p>磁盘 io 的开销是比较高的，尽量少换入换出。</p>
<p><img src="/img/mac/image-20220315150017680.png" srcset="/img/loading.gif" lazyload alt="image-20220315150017680"></p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>我们可以直接不考虑偏移，因为要研究的页的换入换出，只考虑页号。</p>
<p><img src="/img/mac/image-20220315150225932.png" srcset="/img/loading.gif" lazyload alt="image-20220315150225932"></p>
<h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换"><a href="#最优页面置换" class="headerlink" title="最优页面置换"></a>最优页面置换</h3><p>不太现实，但是可以作为其他算法的评判标准。其他算法越逼近他，效果就越好。</p>
<p><img src="/img/mac/image-20220315150444209.png" srcset="/img/loading.gif" lazyload alt="image-20220315150444209"></p>
<p>Requests：当前时间轴下要访问的页</p>
<p>总共有四个页帧，五个页，所以会发生页替换。</p>
<p>第一次访问 e 的时候发生缺页，需要用算法计算。</p>
<p><img src="/img/mac/image-20220315150759529.png" srcset="/img/loading.gif" lazyload alt="image-20220315150759529"></p>
<h3 id="先进先出算法-fifo"><a href="#先进先出算法-fifo" class="headerlink" title="先进先出算法 fifo"></a>先进先出算法 fifo</h3><p>belady 现象，你给他的物理页帧越多，反而缺页情况也越多。</p>
<p><img src="/img/mac/image-20220315150904269.png" srcset="/img/loading.gif" lazyload alt="image-20220315150904269"></p>
<p><img src="/img/mac/image-20220315151306909.png" srcset="/img/loading.gif" lazyload alt="image-20220315151306909"></p>
<p><img src="/img/mac/image-20220315151326311.png" srcset="/img/loading.gif" lazyload alt="image-20220315151326311"></p>
<p>实现简单，但缺页次数多。</p>
<h3 id="最近最久未使用算法-lru"><a href="#最近最久未使用算法-lru" class="headerlink" title="最近最久未使用算法 lru"></a>最近最久未使用算法 lru</h3><p>least recently used</p>
<p>他是根据过去很长时间都没访问过的页面，来推测未来。最优页面置换是根据未来来推测未来。</p>
<p><img src="/img/mac/image-20220315151547725.png" srcset="/img/loading.gif" lazyload alt="image-20220315151547725"></p>
<p>实验过程：</p>
<p><img src="/img/mac/image-20220315151852730.png" srcset="/img/loading.gif" lazyload alt="image-20220315151852730"></p>
<p><img src="/img/mac/image-20220315151938981.png" srcset="/img/loading.gif" lazyload alt="image-20220315151938981"></p>
<p>lru 维护各个页面的使用时间：</p>
<p>链表 - 头插法，最近使用的成为链首，每次剔除的时候选择链尾。</p>
<p>栈，最近使用的页压入栈中，每次剔除的时候从栈尾中弹出。</p>
<p><img src="/img/mac/image-20220315152247073.png" srcset="/img/loading.gif" lazyload alt="image-20220315152247073"></p>
<p>虽然解决缺页效果不错，但是开销比较大，因为每次都要遍历链表或者栈看看页帧是否在里面。</p>
<p><img src="/img/mac/image-20220315152559378.png" srcset="/img/loading.gif" lazyload alt="image-20220315152559378"></p>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>访问位 置 1 是由硬件来完成的，但是软件可以对其修改。</p>
<p>当页帧最近被访问过，访问位置 1。</p>
<p><img src="/img/mac/image-20220315153722011.png" srcset="/img/loading.gif" lazyload alt="image-20220315153722011"></p>
<p>环形链表的维护：</p>
<p><img src="/img/mac/image-20220315154106879.png" srcset="/img/loading.gif" lazyload alt="image-20220315154106879"></p>
<p>当发生了缺页，从当前指针开始遍历，如果是访问位是 1，就将其变 0；直到找到访问位为 0 的页，将其替换。</p>
<p>实验过程：</p>
<p><img src="/img/mac/image-20220315154712009.png" srcset="/img/loading.gif" lazyload alt="image-20220315154712009"></p>
<h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p>在 clock 的基础上，多判断一个 dirty bit（是否写过该页）</p>
<p><img src="/img/mac/image-20220315155748580.png" srcset="/img/loading.gif" lazyload alt="image-20220315155748580"></p>
<p>两个 bit，四种情况。</p>
<p>如果写入过某个页，两个 bit 都会变成 1；第一次遍历到这个页的时候变成 0 1，第二次再变成 0 0；再下一次 replace。</p>
<p>所以被写入过的页，被换出的机会更少；只读的页，会更快的被换出。所以叫做二次机会法。</p>
<p>实验过程：10 表示 used bit = 1，dirty bit = 0；</p>
<p><img src="/img/mac/image-20220315160450793.png" srcset="/img/loading.gif" lazyload alt="image-20220315160450793"></p>
<h3 id="最不常用算法-lfu"><a href="#最不常用算法-lfu" class="headerlink" title="最不常用算法 lfu"></a>最不常用算法 lfu</h3><p>least frequently used</p>
<p>lfu 和 lru 的区别：一个是访问次数，一个是多久未访问。</p>
<p><img src="/img/mac/image-20220315160927016.png" srcset="/img/loading.gif" lazyload alt="image-20220315160927016"></p>
<p>问题：一个页面在进程开始时用的很多，但以后就不再使用了。</p>
<p>解决方法：定期把次数寄存器右移一位。就是除以 2。</p>
<p>实验过程：</p>
<p><img src="/img/mac/image-20220315161141452.png" srcset="/img/loading.gif" lazyload alt="image-20220315161141452"></p>
<h3 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h3><p><img src="/img/mac/image-20220315161416331.png" srcset="/img/loading.gif" lazyload alt="image-20220315161416331"></p>
<p>head：当前在内存中要被淘汰的页。</p>
<p><img src="/img/mac/image-20220315161656419.png" srcset="/img/loading.gif" lazyload alt="image-20220315161656419"></p>
<p><img src="/img/mac/image-20220315161842043.png" srcset="/img/loading.gif" lazyload alt="image-20220315161842043"></p>
<p>同样的访问序列，加大了页帧，产生的缺页反而更多，被一个叫 belady 的科学家发现。</p>
<p>采用 lru 算法就不会产生 belady</p>
<p><img src="/img/mac/image-20220315161954935.png" srcset="/img/loading.gif" lazyload alt="image-20220315161954935"></p>
<p>为什么呢？</p>
<p>lru 满足栈算法，你给他资源越多，他的缺页越少。具体内容自行 google 或翻阅《操作系统概述》。</p>
<p><img src="/img/mac/image-20220315162336046.png" srcset="/img/loading.gif" lazyload alt="image-20220315162336046"></p>
<p><img src="/img/mac/image-20220315162614428.png" srcset="/img/loading.gif" lazyload alt="image-20220315162614428"></p>
<p>clock 算法只用了 1bit，思路是模仿 lru，但开销更小。</p>
<h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><p>上面的算法都是针对一个进程的局部置换算法。并且用的都是固定物理页帧。</p>
<p>我们希望通过动态页帧来最大程度减少缺页的发生</p>
<p><img src="/img/mac/image-20220315163836144.png" srcset="/img/loading.gif" lazyload alt="image-20220315163836144"></p>
<p>不同的页帧的效果差别是很大的，能否动态调整？</p>
<h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p><img src="/img/mac/image-20220315163945697.png" srcset="/img/loading.gif" lazyload alt="image-20220315163945697"></p>
<p>前面的局部置换算法全部基于程序的局部性原理。</p>
<p>定义：</p>
<p>工作集窗口类似于滑动窗口</p>
<p><img src="/img/mac/image-20220315164208803.png" srcset="/img/loading.gif" lazyload alt="image-20220315164208803"></p>
<p>例子</p>
<p><img src="/img/mac/image-20220315164331593.png" srcset="/img/loading.gif" lazyload alt="image-20220315164331593"></p>
<p>可以看到，滑动集对页进行了去重操作。</p>
<p><img src="/img/mac/image-20220315164545591.png" srcset="/img/loading.gif" lazyload alt="image-20220315164545591"></p>
<p>工作集表示的是程序进行的时候要访问的页是哪些，这些页可能在内存中，也可能不在内存中。</p>
<p>常驻集表示在内存中有哪些页。</p>
<p>我们希望工作集和常驻集尽量重合，以减少缺页。</p>
<p><img src="/img/mac/image-20220315164828959.png" srcset="/img/loading.gif" lazyload alt="image-20220315164828959"></p>
<p>给不同的应用程序以不同的常驻集，来减少缺页。</p>
<h3 id="两个全局页面置换算法"><a href="#两个全局页面置换算法" class="headerlink" title="两个全局页面置换算法"></a>两个全局页面置换算法</h3><h4 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h4><p>工作集是随着时间进行移动的滑动窗口，不在滑动窗口（工作集）内的就换出去。具体图示在上方的图。</p>
<p>实验过程：</p>
<p>这个可以动手画一下，光看可能不够清晰。</p>
<p><img src="/img/mac/image-20220315165622326.png" srcset="/img/loading.gif" lazyload alt="image-20220315165622326"></p>
<p>在物理内存中放的页参考的是工作集窗口</p>
<h3 id="缺页率页面置换算法"><a href="#缺页率页面置换算法" class="headerlink" title="缺页率页面置换算法"></a>缺页率页面置换算法</h3><p>缺页率：缺页次数/内存访问次数<img src="/img/mac/image-20220315184540203.png" srcset="/img/loading.gif" lazyload alt="image-20220315184540203"></p>
<p>缺页率算法实现</p>
<p><img src="/img/mac/image-20220315184709513.png" srcset="/img/loading.gif" lazyload alt="image-20220315184709513"></p>
<p>缺页率高和低的计算</p>
<p>计算这次缺失和上次缺失的时间进行相减。如果值大于某个阈值，说明缺页率比较低，相应的可以减少工作集。如果小于某个阈值，说明缺页率高。</p>
<p><img src="/img/mac/image-20220315184849983.png" srcset="/img/loading.gif" lazyload alt="image-20220315184849983"></p>
<p>实验过程：图有点糊， t current - t last &gt; 2</p>
<p><img src="/img/mac/image-20220315185637612.png" srcset="/img/loading.gif" lazyload alt="image-20220315185637612"></p>
<p>两个算法发生的时机是不一样的，缺页率算法是在中断发生时发生。</p>
<h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><p><img src="/img/mac/image-20220315190028579.png" srcset="/img/loading.gif" lazyload alt="image-20220315190028579"></p>
<p>cpu 利用率是 y 轴：尽量不把 cpu 用于换入换出。</p>
<p>开启的进程数是 x 轴：</p>
<p><img src="/img/mac/image-20220315190220994.png" srcset="/img/loading.gif" lazyload alt="image-20220315190220994"></p>
<p>解决：尽量让平均页缺失时间等于页缺失服务时间，让尽量跑更多的进程的情况下，还保持 cpu 高利用率。</p>
<p><img src="/img/mac/image-20220315190459458.png" srcset="/img/loading.gif" lazyload alt="image-20220315190459458"></p>
<h1 id="第七课-进程管理"><a href="#第七课-进程管理" class="headerlink" title="第七课-进程管理"></a>第七课-进程管理</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>进程代表着运行着的程序的执行过程，消耗着各种资源如 cpu，内存，网络，io 等。</p>
<p><img src="/img/mac/image-20220315191212264.png" srcset="/img/loading.gif" lazyload alt="image-20220315191212264"></p>
<p><img src="/img/mac/image-20220315191508500.png" srcset="/img/loading.gif" lazyload alt="image-20220315191508500">代码编译后成为可执行文件，只有当操作系统把可执行文件调入内存中执行起来，所谓执行就是 cpu 调用其中的一条条指令，完成不同的功能，这个过程是动态的执行过程，这个执行过程就是<strong>进程</strong>。和静态的可执行文件是不同的。</p>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p><img src="/img/mac/image-20220315191834893.png" srcset="/img/loading.gif" lazyload alt="image-20220315191834893"></p>
<p>进程和程序的联系：</p>
<p>程序的代码限制了进程产生的功能。</p>
<p><img src="/img/mac/image-20220315191939659.png" srcset="/img/loading.gif" lazyload alt="image-20220315191939659"></p>
<p>进程与程序的区别：</p>
<p>核心态：某些行为只能 os 才能完成（如读取文件）；os 代表进程在内存中完成这些行为</p>
<p>用户态：仅仅执行程序写的代码</p>
<p><img src="/img/mac/image-20220315192455070.png" srcset="/img/loading.gif" lazyload alt="image-20220315192455070"></p>
<p>类比，便于理解：</p>
<p><img src="/img/mac/image-20220315192751422.png" srcset="/img/loading.gif" lazyload alt="image-20220315192751422"></p>
<h2 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h2><p>动态性 包括进程创建、切换、结束</p>
<p>并行：在一个时刻有多个进程执行，需要多核 cpu 支撑</p>
<p>并发：在一段短时间内有多个进程执行</p>
<p>独立性：可以给每个进程分配几个独立的页表，在内存管理方面予以支持。</p>
<p>制约性</p>
<p><img src="/img/mac/image-20220315193451486.png" srcset="/img/loading.gif" lazyload alt="image-20220315193451486"></p>
<h2 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h2><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p><img src="/img/mac/image-20220315193645495.png" srcset="/img/loading.gif" lazyload alt="image-20220315193645495"></p>
<p>进程控制块可以作为进程存在的唯一标识。</p>
<p><img src="/img/mac/image-20220315193735471.png" srcset="/img/loading.gif" lazyload alt="image-20220315193735471"></p>
<p><img src="/img/mac/image-20220315193836928.png" srcset="/img/loading.gif" lazyload alt="image-20220315193836928"></p>
<h3 id="pcb-含有的信息"><a href="#pcb-含有的信息" class="headerlink" title="pcb 含有的信息"></a>pcb 含有的信息</h3><p><img src="/img/mac/image-20220315193949135.png" srcset="/img/loading.gif" lazyload alt="image-20220315193949135"></p>
<p>处理机即 cpu</p>
<p>控制进程处于哪个状态，运行等待或者就绪等其他情况，描述进程的执行现状。</p>
<p><img src="/img/mac/image-20220315194216137.png" srcset="/img/loading.gif" lazyload alt="image-20220315194216137"></p>
<p>数据结构连接信息：如进程 a 创建了进程 b，a 就是 b 的父进程。</p>
<h3 id="pcb-的组织方式"><a href="#pcb-的组织方式" class="headerlink" title="pcb 的组织方式"></a>pcb 的组织方式</h3><p>链表：可以更好地完成动态的插入和删除</p>
<p>如果没有频繁的创建和删除，可以考虑索引</p>
<p><img src="/img/mac/image-20220315194710456.png" srcset="/img/loading.gif" lazyload alt="image-20220315194710456"></p>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><p>创建-运行-等待-唤醒-结束</p>
<p><img src="/img/mac/image-20220315194837246.png" srcset="/img/loading.gif" lazyload alt="image-20220315194837246"></p>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>有下图三种情况</p>
<p>系统初始化：先创建一个 init 进程，init 再创建其他进程</p>
<p><img src="/img/mac/image-20220315194938881.png" srcset="/img/loading.gif" lazyload alt="image-20220315194938881"></p>
<h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p><img src="/img/mac/image-20220315195043941.png" srcset="/img/loading.gif" lazyload alt="image-20220315195043941"></p>
<h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待 / 阻塞"></a>进程等待 / 阻塞</h4><p><img src="/img/mac/image-20220315195132996.png" srcset="/img/loading.gif" lazyload alt="image-20220315195132996"></p>
<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>等待的事件到达了，进入就绪态，等待操作系统调度，让 cpu 去执行</p>
<p><img src="/img/mac/image-20220315195340624.png" srcset="/img/loading.gif" lazyload alt="image-20220315195340624"></p>
<h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p><img src="/img/mac/image-20220315195402683.png" srcset="/img/loading.gif" lazyload alt="image-20220315195402683"></p>
<h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><img src="/img/mac/image-20220316104711131.png" srcset="/img/loading.gif" lazyload alt="image-20220316104711131"></p>
<p>三个主要的基本状态和其他的基本状态：</p>
<p><img src="/img/mac/image-20220316104833846.png" srcset="/img/loading.gif" lazyload alt="image-20220316104833846"></p>
<p><img src="/img/mac/image-20220316104929457.png" srcset="/img/loading.gif" lazyload alt="image-20220316104929457"></p>
<p>Running -&gt; ready ：给每个进程分配一个小的时间片，让每个进程都有机会执行</p>
<p><img src="/img/mac/image-20220316105109329.png" srcset="/img/loading.gif" lazyload alt="image-20220316105109329"></p>
<p>不会持续很久，pcb 的创建是很快的。</p>
<p><img src="/img/mac/image-20220316105202344.png" srcset="/img/loading.gif" lazyload alt="image-20220316105202344"></p>
<p>操作系统来完成，os 管理着一个时钟，对应的管理时间片。</p>
<p><img src="/img/mac/image-20220316105421244.png" srcset="/img/loading.gif" lazyload alt="image-20220316105421244"></p>
<p>事件还没有产生，对应的资源没得到满足。</p>
<p>阻塞时 事件来了，或者资源满足了，就从阻塞态进入就绪态，这也是操作系统来完成的状态转换。</p>
<h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p><img src="/img/mac/image-20220316105846558.png" srcset="/img/loading.gif" lazyload alt="image-20220316105846558"></p>
<p><img src="/img/mac/image-20220316110104720.png" srcset="/img/loading.gif" lazyload alt="image-20220316110104720"></p>
<p>阻塞挂起时，进程的资源得到了满足，成为就绪挂起。</p>
<p><img src="/img/mac/image-20220316110225989.png" srcset="/img/loading.gif" lazyload alt="image-20220316110225989"></p>
<p>操作系统维护状态队列</p>
<p><img src="/img/mac/image-20220316110446729.png" srcset="/img/loading.gif" lazyload alt="image-20220316110446729"></p>
<p><img src="/img/mac/image-20220316110815007.png" srcset="/img/loading.gif" lazyload alt="image-20220316110815007"></p>
<p>多个就绪队列，这几个队列的优先级不同。</p>
<p>事件 1 满足后，将等待事件 1 的进程转为就绪状态。</p>
<h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p><img src="/img/mac/image-20220316110958953.png" srcset="/img/loading.gif" lazyload alt="image-20220316110958953"></p>
<h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程</h3><p>编写一个 mp3</p>
<p><img src="/img/mac/image-20220316111059671.png" srcset="/img/loading.gif" lazyload alt="image-20220316111059671"></p>
<p>可能 read 的地方阻塞了，导致声音断断续续。</p>
<p><img src="/img/mac/image-20220316111213808.png" srcset="/img/loading.gif" lazyload alt="image-20220316111213808"></p>
<p>多进程的问题：并发的开销….</p>
<p><img src="/img/mac/image-20220316111321169.png" srcset="/img/loading.gif" lazyload alt="image-20220316111321169"></p>
<p><img src="/img/mac/image-20220316111402830.png" srcset="/img/loading.gif" lazyload alt="image-20220316111402830"></p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>进程当中的一条执行流程</p>
<p>从两个方面重新理解进程</p>
<p>资源管理+线程</p>
<p><img src="/img/mac/image-20220316111613746.png" srcset="/img/loading.gif" lazyload alt="image-20220316111613746"></p>
<p>多个线程共享进程所拥有的资源，可以直接访问进程的代码，资源，文件等等。</p>
<p><img src="/img/mac/image-20220316111849951.png" srcset="/img/loading.gif" lazyload alt="image-20220316111849951"></p>
<p>什么时候用进程，什么时候用线程？</p>
<p>打开浏览器的网页，现在一般是进程，如果用线程，一旦这个网页有问题，会导致其他的网页也崩溃。</p>
<p>高精度计算里可以用线程实现，如天气预报，空气动力学计算等等</p>
<p><img src="/img/mac/image-20220316112319233.png" srcset="/img/loading.gif" lazyload alt="image-20220316112319233"></p>
<p>线程的资源共享和独占</p>
<p>code data files 共享，stack · pcgister 独占</p>
<p>复习 jvm：heap，method area 中资源线程共享，stack，pc register 线程独占</p>
<p><img src="/img/mac/image-20220316112357397.png" srcset="/img/loading.gif" lazyload alt="image-20220316112357397"></p>
<p>线程与进程的比较</p>
<p><img src="/img/mac/image-20220316112943929.png" srcset="/img/loading.gif" lazyload alt="image-20220316112943929"></p>
<p>进程的创建时还要进行资源的管理，而线程直接使用进程的资源，所以时间短。</p>
<p>线程的切换：线程切换不需要进行页的切换，而进程需要，从而要更改页表/tlb 等结构。</p>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>操作系统看不到的，由用户线程库来管理</p>
<p>用户线程的 tcb 操作系统是看不到的，线程的调度和管理由线程库函数管理。</p>
<p><img src="/img/mac/image-20220316113557923.png" srcset="/img/loading.gif" lazyload alt="image-20220316113557923"></p>
<p><img src="/img/mac/image-20220316113706630.png" srcset="/img/loading.gif" lazyload alt="image-20220316113706630"></p>
<p>用户线程缺点：</p>
<p><img src="/img/mac/image-20220316113941988.png" srcset="/img/loading.gif" lazyload alt="image-20220316113941988"></p>
<h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>操作系统管理的线程</p>
<p>tcb 是放在内核中的</p>
<h4 id="用户线程和内核线程的对应关系"><a href="#用户线程和内核线程的对应关系" class="headerlink" title="用户线程和内核线程的对应关系"></a>用户线程和内核线程的对应关系</h4><p><img src="/img/mac/image-20220316113417809.png" srcset="/img/loading.gif" lazyload alt="image-20220316113417809"></p>
<p><img src="/img/mac/image-20220316114047677.png" srcset="/img/loading.gif" lazyload alt="image-20220316114047677"></p>
<p>cpu 调度单位成了线程，进程主要完成资源的管理。 pcb 统一管理 tcb。</p>
<p><img src="/img/mac/image-20220316114323630.png" srcset="/img/loading.gif" lazyload alt="image-20220316114323630"></p>
<h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p><img src="/img/mac/image-20220316114516719.png" srcset="/img/loading.gif" lazyload alt="image-20220316114516719"></p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>context switch</p>
<p>进程的上下文切换</p>
<p>进程的上下文切换换的是寄存器，如 pc register ， 栈指针等。</p>
<p><img src="/img/mac/image-20220316114732929.png" srcset="/img/loading.gif" lazyload alt="image-20220316114732929"></p>
<p>切换时，将进程的当前状态（上下文）保存到 pcb 中的某一块中。再将要执行的进程的 pcb 中取出它对应的上下文。</p>
<p><img src="/img/mac/image-20220316115003158.png" srcset="/img/loading.gif" lazyload alt="image-20220316115003158"></p>
<p><img src="/img/mac/image-20220316115157753.png" srcset="/img/loading.gif" lazyload alt="image-20220316115157753"></p>
<p>僵尸队列：后续介绍。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>windows 和 unix 进程创建的系统调用</p>
<p><img src="/img/mac/image-20220316143325894.png" srcset="/img/loading.gif" lazyload alt="image-20220316143325894"></p>
<p><img src="/img/mac/image-20220316143400299.png" srcset="/img/loading.gif" lazyload alt="image-20220316143400299"></p>
<p><img src="/img/mac/image-20220316143447159.png" srcset="/img/loading.gif" lazyload alt="image-20220316143447159"></p>
<p>fork 的地址空间复制</p>
<p><img src="/img/mac/image-20220316141202432.png" srcset="/img/loading.gif" lazyload alt="image-20220316141202432"></p>
<p><img src="/img/mac/image-20220316141359910.png" srcset="/img/loading.gif" lazyload alt="image-20220316141359910"></p>
<p>通过 if else 让子父进程执行的代码不一致。</p>
<p>空闲进程的创建</p>
<p><img src="/img/mac/image-20220316142449864.png" srcset="/img/loading.gif" lazyload alt="image-20220316142449864"></p>
<p><img src="/img/mac/image-20220316143133176.png" srcset="/img/loading.gif" lazyload alt="image-20220316143133176">让创建和加载在一个系统调用中完成，或者使用写时复制，用的时候再进行。</p>
<h3 id="加载和执行过程"><a href="#加载和执行过程" class="headerlink" title="加载和执行过程"></a>加载和执行过程</h3><p><img src="/img/mac/image-20220316143650881.png" srcset="/img/loading.gif" lazyload alt="image-20220316143650881"></p>
<p>如果 exec 系统调用执行成功的话，why would i execute 不会输出。因为原先的代码块已经被改写了。</p>
<p><img src="/img/mac/image-20220316143953869.png" srcset="/img/loading.gif" lazyload alt="image-20220316143953869"></p>
<p>fork 先创建新的地址空间，子进程先完全复制父进程的内存空间，当 exec 执行完后，子进程才执行不同的程序</p>
<p><img src="/img/mac/image-20220316144140317.png" srcset="/img/loading.gif" lazyload alt="image-20220316144140317"></p>
<p>可以看到进程本身的堆栈代码段都变化了。</p>
<p><img src="/img/mac/image-20220316144211754.png" srcset="/img/loading.gif" lazyload alt="image-20220316144211754"></p>
<p>fork 开销很大：</p>
<p>待优化的地方，复制的这个过程是可以被优化的，因为 exec 执行完后子进程都要修改掉。</p>
<p><img src="/img/mac/image-20220316144400307.png" srcset="/img/loading.gif" lazyload alt="image-20220316144400307"></p>
<p>写时复制：当父进程执行 fork 时，不复制全部的数据，只进行元数据如页表等必要数据的复制。 当父进程或子进程对某一地址单元进行写的时候，会触发一个异常，让操作系统把触发异常的页复制成两份，进行按需写的操作。这是很高效的。</p>
<h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>我们看到上面的 else 语句块中，父进程总是会调用一个 wait()</p>
<p><img src="/img/mac/image-20220316145011673.png" srcset="/img/loading.gif" lazyload alt="image-20220316145011673"></p>
<p>父进程得到子进程的 exit 消息后，且父进程在 wait，父进程帮助子进程把它的 PCB 在内存中释放掉。</p>
<p>僵尸状态：要死还不死的状态</p>
<p>子进程调用 exit 后其实已经没法正常工作，只等着被父进程回收。</p>
<p><img src="/img/mac/image-20220316145619754.png" srcset="/img/loading.gif" lazyload alt="image-20220316145619754"></p>
<p>如果父进程没有在 wait，那么会有 root 根进程代替父进程进行回收僵尸进程。</p>
<p><img src="/img/mac/image-20220316145756774.png" srcset="/img/loading.gif" lazyload alt="image-20220316145756774"></p>
<p>执行 exec 时，进程可能处于不同的状态</p>
<p>调用 exec 时-&gt; running</p>
<p>加载运行程序-&gt; ready</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/os/">os</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/os/">os</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/12/JUC-1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JUC-1</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/11/hello-world/">
                        <span class="hidden-mobile">我的第一篇博客</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
