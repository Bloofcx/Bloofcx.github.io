

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bloo">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考黑马程序员满一航老师的JUC课程。">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC-1">
<meta property="og:url" content="https://bloofcx.github.io/2022/04/12/JUC-1/index.html">
<meta property="og:site_name" content="Bloo">
<meta property="og:description" content="参考黑马程序员满一航老师的JUC课程。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325153008819.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325153427913.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325153634829.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325165859927.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325173135494.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325174451100.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325163450536.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325175849680.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220325193527073.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326091814627.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326104711247.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326144719280.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326145415282.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326152408704.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326154904240.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326153829444.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326155700103.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326155918003.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326172244396.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220326193820238.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220327092609476.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220327104117360.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220327113320087.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220327173020587.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220327173031893.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220328142549030.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220328151206165.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220328154056508.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220328161638346.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220328161423924.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220328162318395.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220328171654735.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329101713577.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329111538879.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329111457024.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329112339269.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329113043453.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329114825181.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329151110499.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220329151831542.png">
<meta property="article:published_time" content="2022-04-12T14:34:15.000Z">
<meta property="article:modified_time" content="2022-04-12T14:36:59.797Z">
<meta property="article:author" content="Bloo">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://bloofcx.github.io/img/mac/image-20220325153008819.png">
  
  
  <title>JUC-1 - Bloo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"bloofcx.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bloo | LongMayTheSunShine</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JUC-1">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-12 22:34" pubdate>
        April 12, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      41k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      346 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JUC-1</h1>
            
            <div class="markdown-body">
              <h1 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序中的代码编译成可执行文件，可执行文件到内存中，执行其代码，这是动态的过程，称进程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个线程就是一个指令流，将一条条指令交给 cpu 执行。</p>
<p>线程为最小调度单位，进程像是一个资源管理的平台。</p>
<p>一个进程内的多个线程可以去访问共享资源，但是自己的栈和程序计数器之类的是线程独占的。</p>
<p>线程的上下文切换比进程上下文切换低。因为进程切换，相较于线程需要更改 cpu 寄存器等其他内容，开销比线程大。</p>
<h3 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 并行"></a>并发 并行</h3><p>单核 cpu 下，微观串行，宏观并行。</p>
<p>并发 一段时间内执行多个线程</p>
<p>并行 一个时间点执行多个线程/进程；并行需要多核 cpu 的支撑。</p>
<p>一般情况下，<strong>并发和并行同时发生</strong>。因为线程数可能远远大于 cpu 核心数。</p>
<h3 id="应用之异步调用"><a href="#应用之异步调用" class="headerlink" title="应用之异步调用"></a>应用之异步调用</h3><p>需要等待结果返回（阻塞）才能继续运行，同步。Async</p>
<p>不需要等待结果返回，就能继续运行。（异步）sync</p>
<p>例如，读取磁盘文件操作是同步的，假设耗费 5s，那么在一个线程下肯定会发生阻塞。</p>
<p>如果使用 java 的多线程方法，另开一个线程用于读取文件，这样就能避免阻塞主线程。</p>
<p>io 操作下，<strong>线程不占用 cpu</strong>，但是线程也不工作，会进入<strong>阻塞直到 io 结束</strong>，所以后面有异步 io 和非阻塞 io。</p>
<h3 id="应用之提高效率"><a href="#应用之提高效率" class="headerlink" title="应用之提高效率"></a>应用之提高效率</h3><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs">计算1 10ms<br>计算2 11ms<br>计算3 9ms<br>汇总 1ms<br></code></pre></td></tr></table></figure>

<p>如果是<strong>单核</strong>cpu，则一共需 31ms</p>
<p>如果是<strong>多核 cpu</strong>，三个计算<strong>并行</strong>执行，只需要 12ms</p>
<h1 id="二、java-线程"><a href="#二、java-线程" class="headerlink" title="二、java 线程"></a>二、java 线程</h1><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="方法一，直接使用-Thread"><a href="#方法一，直接使用-Thread" class="headerlink" title="方法一，直接使用 Thread"></a>方法一，直接使用 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><br>  &#125;<br>&#125;; <span class="hljs-comment">//匿名类，实际是创建了thread的子类；仅仅是创建了线程</span><br><br>t.setName(<span class="hljs-string">&quot;t1&quot;</span>);<span class="hljs-comment">//指定线程名称</span><br><br>t.start(); <span class="hljs-comment">//启动线程</span><br></code></pre></td></tr></table></figure>

<h3 id="方法二，使用-Runnable-配合-Thread"><a href="#方法二，使用-Runnable-配合-Thread" class="headerlink" title="方法二，使用 Runnable 配合 Thread"></a>方法二，使用 Runnable 配合 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//要执行的任务</span><br> &#125;<br>&#125;;<br><br><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable,<span class="hljs-string">&quot;t&quot;</span>);<br><br>t.start();<span class="hljs-comment">//启动线程</span><br></code></pre></td></tr></table></figure>

<h3 id="lambda-表达式精简"><a href="#lambda-表达式精简" class="headerlink" title="lambda  表达式精简"></a>lambda  表达式精简</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;I am lambda&quot;</span>);<br><br><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable,<span class="hljs-string">&quot;task&quot;</span>);<br><br>t.start();<span class="hljs-comment">//启动线程</span><br></code></pre></td></tr></table></figure>

<p>函数式接口 Runnable</p>
<p><strong>结论：推荐使用 Runnable 接口，一是配合线程池；二是优先使用组合关系而不是继承</strong></p>
<h3 id="方法三，FutureTask-配合-Thread"><a href="#方法三，FutureTask-配合-Thread" class="headerlink" title="方法三，FutureTask 配合 Thread"></a>方法三，FutureTask 配合 Thread</h3><p>FutureTask 可以用 get 方法来获取任务的执行结果。获取结果是通过实现 Callable 接口来实现的。</p>
<p>get 方法将等待结果返回；如果任务以及完成，那么 get 会立刻返回结果；否则将会进入阻塞直到任务进入完成状态，然后返回结果或者抛出异常。</p>
<h2 id="linux-查看-java-进程"><a href="#linux-查看-java-进程" class="headerlink" title="linux 查看 java 进程"></a>linux 查看 java 进程</h2><ul>
<li><p>top 查看耗费 cpu 的进程</p>
</li>
<li><p>ps -ef | grep java</p>
</li>
<li><p>jps</p>
</li>
<li><p>kill (进程号) 杀死进程</p>
</li>
<li><p>用 top 查看线程信息：</p>
<p>top -H -p (pid)</p>
<p>-H 表示查看线程信息，-p 是线程号</p>
</li>
<li><p>jstack (pid) 也是查看线程信息，虽然它能展示更详细的 java 线程信息，但是只是快照，是某个时刻的。</p>
</li>
<li><p>jconsole 图形化界面，能够连接到某个 java 进程。也能通过远程连接接到另一个服务器的 java 进程。</p>
</li>
</ul>
<h2 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h2><p>cpu 不再执行当前线程的代码，执行另一个线程的代码</p>
<ul>
<li>线程时间片用完</li>
<li>垃圾回收</li>
</ul>
<p>工作线程暂停，垃圾回收线程工作</p>
<ul>
<li>更高优先级线程需要运行</li>
<li>线程自己调用 sleep yield wait join park synchronized lock</li>
</ul>
<p>上下文切换时，由操作系统来记录当前的状态。</p>
<p>java 中对应的概念就是<strong>程序计数器</strong>。</p>
<ul>
<li>状态包括栈帧信息，局部变量，操作数栈，返回地址等。</li>
</ul>
<p><img src="/img/mac/image-20220325153008819.png" srcset="/img/loading.gif" lazyload alt="image-20220325153008819"></p>
<ul>
<li>频繁的上下文切换会影响性能。</li>
</ul>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="/img/mac/image-20220325153427913.png" srcset="/img/loading.gif" lazyload alt="image-20220325153427913"></p>
<p><img src="/img/mac/image-20220325153634829.png" srcset="/img/loading.gif" lazyload alt="image-20220325153634829"></p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>start 方法让线程进入就绪态，里面的代码不一定会直接运行（由操作系统决定）；只能调用一次。</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>线程启动后调用的方法</p>
<h3 id="join-join-long-n"><a href="#join-join-long-n" class="headerlink" title="join() / join(long n)"></a>join() / join(long n)</h3><p>请配合<strong>应用之同步</strong>食用</p>
<p>等待线程运行结束，谁调用 join，就等待谁运行结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">在main线程中，调用t1.join();<br>那么main线程就在此阻塞等待t1线程结束。<br><br>t1.join();<br><br></code></pre></td></tr></table></figure>

<h3 id="getState"><a href="#getState" class="headerlink" title="getState()"></a>getState()</h3><p>获取当前线程的状态信息。</p>
<p>java 中的线程有 6 个状态,具体移步六种状态。</p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>请配合**应用之防止 CPU 占用 100%**一起食用</p>
<p>放弃当前线程对时间片的使用</p>
<ul>
<li><p>让当前线程从 RUNNING 状态进入 TIMED_WAITING 状态（有时限的等待状态）</p>
</li>
<li><p>其他线程可以使用<strong>正在睡眠的线程的 interrupt 方法打断正在睡眠的线程</strong>，这时 sleep 方法会抛出 InterruptedException 异常。</p>
</li>
<li><p>睡眠结束后的线程未必立刻得到执行</p>
</li>
</ul>
<p>理解：睡眠结束后，只是进入<strong>就绪状态</strong>，得到 cpu 的时间片才能执行它的代码。</p>
<ul>
<li>建议用 TimeUnit 的 sleep 方法代替 Thread 的 sleep 以<strong>获得更好的可读性</strong></li>
</ul>
<h3 id="yield-（让出-谦让）"><a href="#yield-（让出-谦让）" class="headerlink" title="yield （让出/谦让）"></a>yield （让出/谦让）</h3><ul>
<li><p>调用 yield 让当前线程从运行状态进入就绪状态，然后调度执行其他线程</p>
</li>
<li><p>具体的实现依赖于 os 的任务调度器</p>
</li>
</ul>
<h3 id="线程的打断"><a href="#线程的打断" class="headerlink" title="线程的打断"></a>线程的打断</h3><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p>打断 sleep wait join 的线程，也就是可以打断 timed wait 状态的线程。让其由 timed wait 状态变为就绪态。同时<strong>将其打断标记置为 false</strong>。</p>
<p>打断正常运行的线程，不会干扰它的正常运行，<strong>只是将其打断标记置为了 true</strong>。</p>
<p>join 的底层原理其实就是 wait。</p>
<h4 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted"></a>isInterrupted</h4><p><strong>正常线程被打断</strong>过后，打断标记被置为 true；</p>
<p><strong>被阻塞的线程</strong>被打断后，打断标记变成了 false</p>
<h4 id="static-interrupted"><a href="#static-interrupted" class="headerlink" title="static interrupted"></a>static interrupted</h4><p>于 isInterrupted 的区别是</p>
<p>判断完以后，会清除打断标记。</p>
<h4 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br> LockSupport.park();<br>&#125;)<br>sleep(<span class="hljs-number">1</span>);<br>t1.start();<br>t1.interrupt();<br></code></pre></td></tr></table></figure>

<p>需注意的是，如果一个线程当前打断标记为真的时候，park 方法会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br> LockSupport.park();<br> LockSupport.park();<br>&#125;)<br>sleep(<span class="hljs-number">1</span>);<br>t1.start();<br>t1.interrupt();<br></code></pre></td></tr></table></figure>

<p>所以 park 一般配合 interrupted 使用。static interrupted 会在判断完后清除打断标记。</p>
<h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p>在一个线程 t1 中<u>优雅</u>的终止 t2 线程</p>
<h4 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h4><p>使用 t2.stop()杀死 t2</p>
<ul>
<li>如果 t2 线程锁住了共享资源，那么它被杀死后就再也没有机会释放锁</li>
</ul>
<p>使用 system.exit()直接退出线程所在的进程。</p>
<h4 id="具体应用-监控记录"><a href="#具体应用-监控记录" class="headerlink" title="具体应用 - 监控记录"></a>具体应用 - 监控记录</h4><p><img src="/img/mac/image-20220325165859927.png" srcset="/img/loading.gif" lazyload alt="image-20220325165859927"></p>
<p>如果正常执行被打断，打断标记会变成 true；如果在睡眠的时候被打断，会抛出异常，并且将打断标记变成 false。这时我们要处理异常并且将打断标记置为 true（重新打断），从而执行料理后事。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><br>             <span class="hljs-comment">//如果当前打断标记为true ， 结束</span><br>               <span class="hljs-keyword">if</span> (thread.isInterrupted())&#123;<br>                   log.debug(<span class="hljs-string">&quot;该线程被打断，现在是善后工作&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>               <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-comment">//正常工作</span><br>                   Thread.sleep(<span class="hljs-number">1000</span>);<br>                   log.debug(<span class="hljs-string">&quot;执行监控&quot;</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   log.debug(<span class="hljs-string">&quot;在睡眠时被打断，需要重新打断&quot;</span>);<br>                   thread.interrupt();<br>               &#125;<br>           &#125;<br>        &#125;,<span class="hljs-string">&quot;thread1&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        thread.interrupt();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">termination</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();<br>        termination.start();<br>        Thread.sleep(<span class="hljs-number">1500</span>);<br>        termination.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><h4 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority"></a>setPriority</h4><p>线程的优先级默认 5</p>
<ul>
<li>如果 cpu 忙，那么优先级高的线程会获得更多时间片；但 cpu 闲时，优先级几乎无作用。</li>
<li>线程优先级会提示调度器优先调用该线程，但仅仅是提示。</li>
</ul>
<h3 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h3><p>过时方法。不多介绍。容易破坏同步代码块，造成死锁。</p>
<p>stop</p>
<p>suspend</p>
<p>resume</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>默认情况下，java 进程需要等待所有线程都运行结束，才会结束。</p>
<p>有一种特殊的线程叫守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没执行完，也强制结束。</p>
<h4 id="setDaemon-true"><a href="#setDaemon-true" class="headerlink" title="setDaemon(true)"></a>setDaemon(true)</h4><p>将调用此方法的线程设置为守护线程。</p>
<h4 id="守护线程实例"><a href="#守护线程实例" class="headerlink" title="守护线程实例"></a>守护线程实例</h4><ul>
<li><strong>垃圾回收器线程</strong>就是守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程。这两个线程是用来接收请求和分发线程的请求。</li>
</ul>
<h3 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h3><p>从<strong>操作系统</strong>层面来描述</p>
<p><img src="/img/mac/image-20220325173135494.png" srcset="/img/loading.gif" lazyload alt="image-20220325173135494"></p>
<ul>
<li><p>初始：仅在语言层面创建了线程对象，还未与操作系统线程关联。</p>
</li>
<li><p>就绪：该线程已于操作系统关联，并且可由 cpu 调度执行</p>
</li>
<li><p>运行：获取了 cpu 时间片，正在执行的线程。时间片用完后进入就绪态。</p>
</li>
<li><p>阻塞态：当一个线程请求某种资源，或者发起请求给 os（如读取文件），这时线程实际上用不到 cpu，这时会发生线程上下文切换，随后该线程进入阻塞态。待得到资源得到满足，由操作系统对其进行唤醒，进入就绪态。</p>
</li>
<li><p>终止：线程执行完毕，生命周期结束。</p>
</li>
</ul>
<h3 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h3><p><img src="/img/mac/image-20220325174451100.png" srcset="/img/loading.gif" lazyload alt="image-20220325174451100"></p>
<p>根据 Thread.State 枚举，分为六种状态。</p>
<ul>
<li>NEW:刚被创建的线程，但是还没有被调用 start 方法；对应 os 层面的初始状态</li>
<li>RUNNABLE：涵盖了<strong>操作系统</strong>层面的<strong>就绪态，运行状态，阻塞状态</strong>（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行状态。）</li>
<li>WAITING：join 方法对应的等待状态，<strong>没有时限</strong>的等待。</li>
<li>BLOCKED：拿不到锁的状态。</li>
<li>TIMED_WAITING：sleep 方法对应的状态，一种<strong>有时限的等待</strong>；</li>
<li>TERMINATED：对应 os 的终止状态</li>
</ul>
<p>测试代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<h2 id="应用之防止-CPU-占用-100"><a href="#应用之防止-CPU-占用-100" class="headerlink" title="应用之防止 CPU 占用 100%"></a>应用之防止 CPU 占用 100%</h2><h3 id="sleep-实现"><a href="#sleep-实现" class="headerlink" title="sleep 实现"></a>sleep 实现</h3><p>防止 while true 中空转浪费 cpu</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-comment">//要抛异常</span><br>  Thread.sleep(<span class="hljs-number">50</span>);<br>  <span class="hljs-comment">//do other ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可以使用 wait 或条件变量达到类似效果</li>
<li>不同的是 wait 和条件变量需要加锁和唤醒。</li>
<li>sleep 适用于无需锁同步场景</li>
</ul>
<h2 id="应用之同步"><a href="#应用之同步" class="headerlink" title="应用之同步"></a>应用之同步</h2><ul>
<li>需要等待结果返回才能继续运行，同步</li>
<li>不需要等待结果返回也能继续运行，异步</li>
</ul>
<h3 id="使用-join-实现同步"><a href="#使用-join-实现同步" class="headerlink" title="使用 join 实现同步"></a>使用 join 实现同步</h3><p><img src="/img/mac/image-20220325163450536.png" srcset="/img/loading.gif" lazyload alt="image-20220325163450536"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;t1 sleep 1s...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            r = <span class="hljs-number">10</span>;<br>            log.debug(<span class="hljs-string">&quot;t1 over...&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;t2 sleep 2s...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            r = <span class="hljs-number">20</span>;<br>            log.debug(<span class="hljs-string">&quot;t2 over...&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        t1.start();<br>        t2.start();<br>        t1.join(); <span class="hljs-comment">//等待t1执行完毕</span><br>        t2.join();<span class="hljs-comment">//等待t2执行完毕</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        log.debug(<span class="hljs-string">&quot;r = &#123;&#125;,cost = &#123;&#125;ms&quot;</span>,r,end-start);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        TimeUnit.SECONDS.sleep(time);<br><br></code></pre></td></tr></table></figure>

<p>等待 t1 运行完毕的同时，t2 也在并行的运行。</p>
<p>所以总共耗时 2s。</p>
<h3 id="有时限的-join-实现有时限的同步"><a href="#有时限的-join-实现有时限的同步" class="headerlink" title="有时限的 join 实现有时限的同步"></a>有时限的 join 实现有时限的同步</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">　　t1.join(<span class="hljs-number">1500</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h2 id="应用之统筹"><a href="#应用之统筹" class="headerlink" title="应用之统筹"></a>应用之统筹</h2><h3 id="烧水泡茶之-join"><a href="#烧水泡茶之-join" class="headerlink" title="烧水泡茶之 join"></a>烧水泡茶之 join</h3><p><img src="/img/mac/image-20220325175849680.png" srcset="/img/loading.gif" lazyload alt="image-20220325175849680"></p>
<p>如果让四个人（四个线程）做这四件事，太浪费。</p>
<p>让两个线程来做即可。</p>
<ul>
<li>第一个线程</li>
</ul>
<p>洗水壶 1 分钟 -&gt; 烧开水 15 分钟</p>
<ul>
<li>第二个线程</li>
</ul>
<p>洗茶壶，洗茶杯，拿茶叶 4 分钟</p>
<ul>
<li>最后，泡茶。用 join 实现。</li>
</ul>
<p><strong>拓展</strong>：最后泡茶的时候，我们只能指定两个线程其中之一来做。我们的代码最好能适应两个线程都能执行泡茶的这个行为。这步留着后面进一步学习来实现。</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p><img src="/img/mac/image-20220325193527073.png" srcset="/img/loading.gif" lazyload alt="image-20220325193527073"></p>
<h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="共享的问题"><a href="#共享的问题" class="headerlink" title="共享的问题"></a>共享的问题</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul>
<li><p>如果多个线程<strong>读取</strong>共享资源，是不会有问题的</p>
</li>
<li><p>多个线程对共享资源进行读写操作，就会出问题</p>
</li>
<li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//临界区</span><br>  i++;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>多个线程在临界区内执行，由于代码的执行序列不恰当而出现不正确的结果，称为竞态条件。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>为了避免临界区的竞态条件发生，可以用 synchronized 解决。</p>
<p>synchronized 是阻塞式的解决方案，是采用<strong>互斥</strong>的方式解决</p>
<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后顺序不同，需要一个线程等待其他线程运行到某个点</li>
</ul>
<p>互斥和同步都可以用 synchronized 解决</p>
<p>持有锁的对象，依旧会正常进行时间片的切换，但是没有锁的对象无法进入临界区。</p>
<p><img src="/img/mac/image-20220326091814627.png" srcset="/img/loading.gif" lazyload alt="image-20220326091814627"></p>
<p>synchronized 是用对象锁保证了<strong>临界区内代码的原子性</strong>，原子的意思就是代码是不可分割的，是一块整体。</p>
<ul>
<li><p>synchronized 加在非 static 成员方法上，等价于锁住 this 对象；</p>
</li>
<li><p>synchronized 加在 static 成员方法上，等价于锁住当前类的 Class 对象。</p>
</li>
</ul>
<h2 id="变量的线程安全"><a href="#变量的线程安全" class="headerlink" title="变量的线程安全"></a>变量的线程安全</h2><h3 id="成员变量和静态变量"><a href="#成员变量和静态变量" class="headerlink" title="成员变量和静态变量"></a>成员变量和静态变量</h3><ul>
<li><p>如果它们没有被共享，则线程安全</p>
</li>
<li><p>如果被共享了，根据它们的状态能否被改变</p>
<ul>
<li>如果只有读，线程安全</li>
<li>如果有读写，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
<li><p>分析</p>
<p>成员变量需要考虑线程安全。</p>
</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeThread</span>()</span>&#123;<br>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li><p>局部变量是线程安全的</p>
</li>
<li><p>局部变量引用的对象未必线程安全</p>
<ul>
<li>如果该对象没有逃离方法的作用范围，则它是安全的</li>
<li>如果该对象逃离了方法的作用范围，如 return，则需要考虑线程安全</li>
</ul>
</li>
<li><p>局部变量线程安全分析</p>
</li>
</ul>
<p>基本类型变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  i++;<br>&#125;<br>如果多个线程调用这个方法，局部变量i会在每个线程的栈帧内存中创建多份，不存在共享<br></code></pre></td></tr></table></figure>

<p>引用类型对象</p>
<h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul>
<li><p>String</p>
</li>
<li><p>Integer 等包装类</p>
</li>
<li><p>StringBuffer</p>
</li>
<li><p>Random</p>
</li>
<li><p>Vector</p>
</li>
<li><p>Hashtable</p>
</li>
<li><p>juc 包下的类</p>
</li>
</ul>
<p>说明：</p>
<ol>
<li>这里的线程安全是指，多个线程调用它们<strong>同一个实例</strong>的某个方法时，是线程安全的。</li>
<li>它们的每个方法是原子的</li>
<li><strong>注意</strong>它们多个方法的组合不是原子的</li>
</ol>
<p>分析：它们只是方法内部是原子性的，但是组合并不是原子性的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><br><br><span class="hljs-comment">//如果多个线程执行这段代码，还是会有线程安全问题</span><br><span class="hljs-keyword">if</span>(table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-literal">null</span>)&#123;<br>  table.put(<span class="hljs-string">&quot;key&quot;</span>,value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220326104711247.png" srcset="/img/loading.gif" lazyload alt="image-20220326104711247"></p>
<h2 id="不可变类的线程安全"><a href="#不可变类的线程安全" class="headerlink" title="不可变类的线程安全"></a>不可变类的线程安全</h2><p>String / Integer 等都是不可变类，因为其内部状态不可改变。</p>
<p>如 String 类的 substring 方法，它并没有改变自身的 value 字符数组，它只直接创建了一个新的对象。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>具体情况具体分析，成员变量等。</p>
<h2 id="习题-卖票"><a href="#习题-卖票" class="headerlink" title="习题-卖票"></a>习题-卖票</h2><p>开启 1k 个线程进行卖票。</p>
<h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>找到临界区，就是对共享变量进行读写操作的代码块。</p>
<p>还要进行组合问题的考虑。</p>
<h2 id="习题-转账"><a href="#习题-转账" class="headerlink" title="习题-转账"></a>习题-转账</h2><p>两个人开两个线程多次转账。</p>
<h2 id="Monitor-管程-重量级锁-10"><a href="#Monitor-管程-重量级锁-10" class="headerlink" title="Monitor 管程-重量级锁 10"></a>Monitor 管程-重量级锁 10</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>如果使用 synchronized 给对象上重量级锁，该对象的对象头中的 mark word 就有<strong>指向操作系统的 monitor 对象</strong>的指针。</p>
<p>具体底层实现：将 Mark word 里面的<strong>标志位由 01 改成 10</strong>，并且将<strong>其他位全部改成指向 monitor 对象的指针。</strong></p>
<p>即图中倒数第二行</p>
<p><img src="/img/mac/image-20220326144719280.png" srcset="/img/loading.gif" lazyload alt="image-20220326144719280"></p>
<h3 id="图例分析"><a href="#图例分析" class="headerlink" title="图例分析"></a>图例分析</h3><ul>
<li><p>一个线程 t1 想进入临界区</p>
</li>
<li><p>此时 owner 已经是 t2 了，所以 t1 会进入 BLOCKED 状态，并且进入等待队列 EntryList</p>
</li>
</ul>
<p><img src="/img/mac/image-20220326145415282.png" srcset="/img/loading.gif" lazyload alt="image-20220326145415282"></p>
<ul>
<li>图中的 waitset 里的线程是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面在学习 wait - notify 时具体分析。</li>
</ul>
<h3 id="synchronized-字节码"><a href="#synchronized-字节码" class="headerlink" title="synchronized 字节码"></a>synchronized 字节码</h3><p>《深入理解 Java 虚拟机》p259</p>
<p>monitorenter 指令：将锁对象的 markword 改成指向 monitor 的指针。</p>
<p>不论是否有异常，monitorexit 和 monitorenter 指令总是一一对应。</p>
<h2 id="轻量级锁-00"><a href="#轻量级锁-00" class="headerlink" title="轻量级锁 00"></a>轻量级锁 00</h2><p>场景：一个对象虽然有多线程访问，但是多线程<strong>访问的时间是错开的（没有竞争）</strong>，可以用轻量级锁优化。</p>
<p>轻量级锁<strong>对使用者透明</strong>，<strong>语法仍是 synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            method2();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>每个线程的栈帧都会包含一个<strong>锁记录 Lock Record</strong>，内部可以存储<strong>锁对象的 markword</strong>和<strong>锁对象的地址</strong>。</p>
<p><img src="/img/mac/image-20220326152408704.png" srcset="/img/loading.gif" lazyload alt="image-20220326152408704"></p>
<ul>
<li><p>进入 synchronized 后</p>
</li>
<li><p><strong>如果 cas 替换成功</strong>（需要上锁对象原先标志位为 01，表示未锁定），<strong>对象头中存储了 Lock Record 地址和状态 00</strong>，表示由该线程给对象加锁</p>
</li>
</ul>
<p><img src="/img/mac/image-20220326154904240.png" srcset="/img/loading.gif" lazyload alt="image-20220326154904240"></p>
<ul>
<li><p><strong>如果 cas 失败</strong>，有两种情况</p>
<ul>
<li>锁重入</li>
</ul>
<p>在上面例子中，一个线程先请求<strong>未被持有的锁</strong>给 lock，<strong>jvm 会记录下锁的持有者（线程），同时将计数值置为 1</strong>；随后这个线程<strong>再次请求获取同样的锁</strong>，计数值就再+1。<strong>当线程退出同步代码块时，计数值会相应递减直到 0。</strong></p>
<p>锁重入底层：会再添加一条 Lock Record 作为重入的计数；当解锁时，如果有取值为 null 的锁记录，表示有重入。</p>
<p><img src="/img/mac/image-20220326153829444.png" srcset="/img/loading.gif" lazyload alt="image-20220326153829444"></p>
<ul>
<li>锁膨胀</li>
</ul>
<p>如果另一条线程也想获取锁，此时轻量级锁将升级为重量级锁。Mark word 中的标志位变为<strong>10</strong>，<strong>表示重量级锁</strong>。同时为 obj 申请 monitor 锁，<strong>让 obj 的 Markword 指向 monitor</strong>。然后另一条线程进入 monitor 的 EntryList,进入 BLOCKED 状态。</p>
</li>
<li><p>退出同步代码块时，如果锁记录不为 null，<strong>使用 cas 将 Mark word 的值恢复给对象头</strong></p>
<ul>
<li>成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<p>存疑，cas？一种乐观锁的思想，后面介绍。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><strong>重量级锁竞争时，可以使用自旋来优化</strong>。如果当前线程自旋成功（持锁线程释放了锁），就可以避免阻塞，<strong>避免线程上下文切换带来的开销</strong>。</p>
<p>自旋（让线程不进入阻塞，而是先忙等）；</p>
<p>自旋需要占 CPU,只有<strong>多核 cpu</strong>才好用</p>
<p>jdk6 中引入了<strong>自适应自旋</strong></p>
<p><strong>自旋重试成功的情况</strong></p>
<p><img src="/img/mac/image-20220326155700103.png" srcset="/img/loading.gif" lazyload alt="image-20220326155700103"></p>
<p><strong>自旋重试失败的情况</strong></p>
<p><img src="/img/mac/image-20220326155918003.png" srcset="/img/loading.gif" lazyload alt="image-20220326155918003"></p>
<h2 id="偏向锁-101"><a href="#偏向锁-101" class="headerlink" title="偏向锁 101"></a>偏向锁 101</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>《深入理解 java 虚拟机》第 3 版 p484</p>
<p>解决轻量级锁在<strong>没有竞争的时候</strong>，<strong>每次重入仍然需要执行 CAS 操作</strong>尝试替换 Mark word，虽然这个 CAS 必定失败。导致 Lock Record 中的取值为 null。<strong>如果有竞争的话，就升级为重量级锁了</strong>。</p>
<p>偏向，就是**偏向第一个获取锁的<u>线程</u>**。如果该锁一直没有被其他线程获取，则持有偏向锁的线程永远不需要再进行同步。</p>
<p>只有第一次使用 CAS<strong>将线程 ID 设置到对象的 Mark word 头</strong>，之后再获取锁时检查这个线程的 ID，如果是自己的就表示没有竞争，无需重新 CAS。</p>
<p>启用偏向锁的 Mark word：</p>
<p>标志位为 01，但是偏向模式 biased_lock=1。<strong>即 Mark word 的后三位为 101</strong>。</p>
<p>优先级：偏向锁&gt;轻量级锁</p>
<p>（禁用偏向锁）</p>
<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p><strong>轻量级锁</strong>中，Mark word 的信息存放在线程栈帧内的锁记录中。</p>
<p>当<strong>第一次调用对象的 hashCode</strong>时，才会给对象头中的 Mark word 相应的 31 位赋值，<strong>此时还会禁用对象的偏向锁</strong>。</p>
<p>原因，偏向锁模式下，对象头中的 Mark word 中要存储线程 ID，这需要大量的存储空间，以至于 hashcode 没地方存，所以导致偏向锁的禁用。</p>
<h4 id="其他线程使用对象"><a href="#其他线程使用对象" class="headerlink" title="其他线程使用对象"></a>其他线程使用对象</h4><p>当有其他线程使用偏向锁对象时，会<strong>将偏向锁升级为轻量级锁</strong>。当然，持锁线程和其他线程必须是<strong>非竞争关系</strong>。否则会升级成<strong>重量级锁</strong>。</p>
<h4 id="调用-wait-notify"><a href="#调用-wait-notify" class="headerlink" title="调用 wait/notify"></a>调用 wait/notify</h4><p>因为 wait/notify 只有重量级锁才有。</p>
<h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>这里的批量，是让一批对象全部进行重新偏向，而不是撤销偏向升级轻量级锁</p>
<p>当 jvm 对一个线程<strong>撤销偏向锁，升级成轻量级锁</strong>这个行为达到一个阈值（20 次）时，就会思考之前是不是偏向了一个错的线程。</p>
<p>所以它干脆不撤销了，去偏向另外一个新的线程。</p>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁超过 40 次后，jvm 会觉得自己确实偏向错了，根本就不该进行偏向。</p>
<p>所以会让整个类的所有对象都会变为不可偏向的。即便是后来新建的对象。</p>
<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>  x++;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span>(o)&#123;<br> x++;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>即时编译器发现加锁的对象不会逃离方法，也就是它的作用域被限制在方法内部，其他线程无法访问到 o，所以这里虽然有锁，但是可以被安全的消除。</p>
<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><p><img src="/img/mac/image-20220326172244396.png" srcset="/img/loading.gif" lazyload alt="image-20220326172244396"></p>
<ul>
<li><strong>Owner 线程</strong>发现条件不满足，<strong>调用 wait 方法</strong>，即可进入 WaitSet 变成 WAITING 状态</li>
<li>BLOCKED 和 WAITING 线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在<strong>owner 线程调用 notify 或 notifyall 方法时唤醒</strong>，但唤醒后并不重新获得锁，<strong>仍需进入 EntryList 进行竞争</strong></li>
</ul>
<h3 id="api-介绍"><a href="#api-介绍" class="headerlink" title="api 介绍"></a>api 介绍</h3><p><strong>线程必须先获得锁</strong>，<strong>必须是成为 monitor 中的 owner 才能调用下面三个方法</strong></p>
<p>具体实现也就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(obj)&#123;<br>   obj.wait();<br>   obj.notify();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>obj.wait() ：owner 线程进入 wait set;进入等待直到被 notify</li>
<li>obj.wait(long timeout) ：timeout 时间走完后还没有被唤醒，就自动结束等待。</li>
<li>obj.notify()：从 wait set 中唤醒一个</li>
<li>obj.notifyAll() ： 唤醒 wait set 全部的线程</li>
</ul>
<h2 id="wait-notify-正确使用"><a href="#wait-notify-正确使用" class="headerlink" title="wait notify 正确使用"></a>wait notify 正确使用</h2><h3 id="wait（long-n）-和-sleep（long-n）的区别"><a href="#wait（long-n）-和-sleep（long-n）的区别" class="headerlink" title="wait（long n） 和 sleep（long n）的区别"></a>wait（long n） 和 sleep（long n）的区别</h3><ol>
<li>sleep 是 Thread 的静态方法，而 wait 是 object 的方法</li>
<li>sleep 不需要强制和 synchronized 配合使用</li>
<li><strong>sleep 在睡眠的同时，不会释放对象锁，会带着锁睡觉</strong>；但是<strong>wait</strong>在等待时<strong>会释放对象锁</strong></li>
<li>共同点：它们的状态都是 TIMED_WAITING</li>
</ol>
<p>注：synchronized 锁住的对象一般加上 final</p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>如果 notify 叫醒了一个不是我们想要的线程，怎么处理？</p>
<p>notify 的条件用 while 代替 if</p>
<p>实例：点烟和送外卖</p>
<p>总结，</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">synchronized</span>(lock)&#123;<br><br><span class="hljs-built_in">while</span>(条件不成立)&#123;<br>   lock<span class="hljs-selector-class">.wait</span>();<br>&#125;<br>   <span class="hljs-comment">//干活</span><br>&#125;<br><br>另一个线程，用lock<span class="hljs-selector-class">.notifyAll</span>唤醒对象，解决虚假唤醒问题。<br></code></pre></td></tr></table></figure>

<h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p>用在<strong>一个线程等待另一个线程的执行结果</strong>，Guarded Suspension</p>
<p><img src="/img/mac/image-20220326193820238.png" srcset="/img/loading.gif" lazyload alt="image-20220326193820238"></p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程，那么要使用消息队列</li>
<li>JDK 中 join 到实现，future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>  <span class="hljs-keyword">private</span> Object response;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>      <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">this</span>.wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>      <span class="hljs-built_in">this</span>.response = response;<br>      <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="增加超时"><a href="#增加超时" class="headerlink" title="增加超时"></a>增加超时</h3><p>记录等待的开始时间和经历时间。等待一定的时间后，计算经历的时间，如果大于某个值，退出循环。 <strong>记得解决虚假唤醒问题！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span>&#123;<br><br><br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>           <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>           <span class="hljs-type">long</span> <span class="hljs-variable">passTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passTime;<br>               <span class="hljs-comment">//应该等待的时间小于0了，break，退出等待</span><br>               <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-built_in">this</span>.wait(waitTime);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>             passTime = System.currentTimeMillis() - startTime;<br>           &#125;<br><br>           <span class="hljs-keyword">return</span> response;<br>       &#125;<br><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span>&#123;<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>           <span class="hljs-built_in">this</span>.response = response;<br>           <span class="hljs-built_in">this</span>.notifyAll();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="join-原理"><a href="#join-原理" class="headerlink" title="join 原理"></a>join 原理</h3><p>保护性暂停模式的具体实现；跟有时限的保护性暂停逻辑基本一样。</p>
<h3 id="解耦生产和消费"><a href="#解耦生产和消费" class="headerlink" title="解耦生产和消费"></a>解耦生产和消费</h3><p>一个邮箱和多个 guarded object，一个居民类，一个邮递员类。</p>
<p><img src="/img/mac/image-20220327092609476.png" srcset="/img/loading.gif" lazyload alt="image-20220327092609476"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.mailbox&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailBox</span>&#123;<br><br>    <span class="hljs-comment">//邮箱 设为线程安全的hashtable</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,GuardedObject2&gt; box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span>&#123;<br>        id ++;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject2 <span class="hljs-title function_">createGuardedObj</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> generateId();<br>        <span class="hljs-type">GuardedObject2</span> <span class="hljs-variable">guarded</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject2</span>(i);<br>        box.put(i,guarded);<br>        log.debug(<span class="hljs-string">&quot;创建了一个guarded，&#123;&#125;&quot;</span>,i);<br>        <span class="hljs-keyword">return</span> guarded;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject2 <span class="hljs-title function_">getGuardedObj</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> box.remove(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getKeySet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> box.keySet();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//等待接受者</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.person&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject2</span> <span class="hljs-variable">guardedObj</span> <span class="hljs-operator">=</span> MailBox.createGuardedObj();<br><br>        <span class="hljs-comment">//居民要拿一封信</span><br>        log.debug(<span class="hljs-string">&quot;居民在5s内想要收信&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> guardedObj.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;居民收到信&#123;&#125;&quot;</span>,o);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.postman&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Postman</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String mail)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.mail = mail;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject2</span> <span class="hljs-variable">guardedObj</span> <span class="hljs-operator">=</span> MailBox.getGuardedObj(id);<br>        guardedObj.complete(mail);<br>        log.debug(<span class="hljs-string">&quot;信件&#123;&#125;完成投递&quot;</span>,id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h2><p>在上面的介绍中，产生结果和消费结果线程一一对应，一个居民就要一个邮递员。</p>
<ul>
<li>与前面的保护性暂停不同，<strong>不需要产生结果和消费结果的线程一一对应</strong></li>
<li>消息队列可以用来平衡生产和消费的线程资源</li>
<li><strong>生产者仅负责产生结果数据，不关心数据如何处理，而消费者专心处理结果数据</strong></li>
<li>消息队列有容量限制，满了就不会再加入数据，空时不再消耗数据</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="/img/mac/image-20220327104117360.png" srcset="/img/loading.gif" lazyload alt="image-20220327104117360"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 异步模式生产消费 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">messageQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                messageQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id,<span class="hljs-string">&quot;msg&quot;</span>+id));<br>            &#125;).start();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                messageQueue.take();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.messageQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span>&#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-comment">//队列满了，就去wait</span><br>            <span class="hljs-keyword">while</span> (queue.size() &gt;= capcity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满，添加消息失败&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;添加消息成功&quot;</span>);<br>            queue.addLast(message);<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-comment">//队列空了，去wait</span><br>            <span class="hljs-keyword">while</span> (queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空，获取消息失败&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;获取消息成功&#123;&#125;&quot;</span>,m.getMsg());<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String msg;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="实现消息队列类"><a href="#实现消息队列类" class="headerlink" title="实现消息队列类"></a>实现消息队列类</h3><p>rabbitmq 等，是<strong>进程间通信</strong>。而这里的消息队列，是<strong>java 线程间通信</strong>，注意区别。</p>
<ol>
<li>把 Message 对象设计成线程安全的类，需要有 id 和消息的内容（final，状态不可变）</li>
<li>消息队列里面的集合选择，双向队列 linkedlist。</li>
<li>capacity 容量规定；</li>
<li>获取消息 take 和存入消息 put 的实现；给谁上锁？条件变量不满足怎么办，唤醒？</li>
</ol>
<h2 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park&amp;Unpark"></a>Park&amp;Unpark</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>LockSupport.park()暂停当前线程</li>
<li>LockSupport.unpark(Thread t)恢复 t 线程的运行</li>
</ul>
<p>注：park 下的<strong>线程状态是 WAIT</strong>，<strong>是无时限的等待</strong></p>
<p>如果先执行了 unpark() , 再执行 park，则线程<strong>不会如预期一样进行阻塞 WAIT</strong></p>
<p><strong>结论</strong>：unpark 可以在线程暂停前执行，也可以在线程暂停后执行，对应线程都不会阻塞</p>
<h3 id="与-wait-amp-notify-比较"><a href="#与-wait-amp-notify-比较" class="headerlink" title="与 wait&amp;notify 比较"></a>与 wait&amp;notify 比较</h3><ul>
<li><p>Wait&amp;notify 必须配合 object monitor 一起使用</p>
</li>
<li><p>park&amp;unpack 是<strong>以线程为单位进行唤醒</strong>；notify 是随机唤醒一个线程，没有那么<strong>精确</strong></p>
</li>
<li><p>基本介绍中最后一段</p>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>线程底层用 c 代码写了一个 Paker 类。里面有 cond, mutex, counter 属性。类比成旅行者，带着一个帐篷和干粮。</p>
<p>分别是等待队列，互斥锁，信号量。</p>
<h4 id="情况-1-先-park-后-unpark"><a href="#情况-1-先-park-后-unpark" class="headerlink" title="情况 1-先 park 后 unpark"></a>情况 1-先 park 后 unpark</h4><ol>
<li>调用 park 时，如果 counter=0 ，获得 mutex 互斥锁；</li>
<li>线程进入 cond 等待队列阻塞；</li>
<li>设置 counter = 0</li>
<li>调用 unpark，设置 counter =1</li>
<li>唤醒阻塞队列中的线程</li>
<li>线程恢复运行</li>
<li>设置 counter 为 0</li>
</ol>
<h4 id="情况-2-先-unpark-后-park"><a href="#情况-2-先-unpark-后-park" class="headerlink" title="情况 2-先 unpark 后 park"></a>情况 2-先 unpark 后 park</h4><ol>
<li>调用 unpark，设置 counter=1</li>
<li>调用 park，检查到 counter=1</li>
<li>线程无需阻塞，继续运行</li>
<li>设置 counter=0</li>
</ol>
<h2 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h2><p>双向箭头表示可以互相转换。</p>
<p><img src="/img/mac/image-20220327113320087.png" srcset="/img/loading.gif" lazyload alt="image-20220327113320087"></p>
<ul>
<li>1:调用 start 方法，从 NEW 进入 RUNNABLE</li>
<li>2:调用 wait&amp;notify 可以在 RUNNABLE 和 WAITING 之间进行转换<ul>
<li>调用 obj.wait 方法从 runnable 进 waiting</li>
<li>obj.notify &amp; notifyAll &amp; t.interrupt<ul>
<li>竞争锁成功：t 线程从 waiting 进入 runnable 状态</li>
<li>竞争锁失败，t 线程从 waiting 进入 blocked 状态</li>
</ul>
</li>
</ul>
</li>
<li>3:调用 t.join 方法，<strong>让调用 join 方法的线程等待 t 线程运行完毕</strong>。当前线程从 runnable 进入 waiting；t 线程运行结束，或调用了<strong>当前线程的 interrupt</strong>，当前线程从 waiting 进入 runnable</li>
<li>4:当前线程调用 Locksupport.park()方法会让当前线程从 runnable 进入 waiting；调用 LockSupport.unpark(目标线程)或调用当前线程的 interrupt，会让目标线程从 waiting 进入 runnable</li>
<li>5:带时限的 wait&amp;notify，参考情况 2，区别是有超时时间和在 runnable 与 timed waiting 之间转换</li>
<li>6:带时限的 join 参考情况 3，同上</li>
<li>7:带时限的 park 参考情况 4，同上</li>
<li>8: 调用了 thread.sleep 方法。</li>
<li>9:获取锁时竞争失败，线程从 Runnable 变为 blocked；持锁线程退出同步代码块，当前线程竞争成功后，从 blocked 转为 runnable</li>
<li>10:所有代码执行完毕，进入 TERMINATRED</li>
</ul>
<h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p>之前介绍的都是<strong>单把锁</strong>出现的问题。</p>
<p>小明和小红都要学习和睡觉，如果就一个房间（一把锁），它们的并发度很低。</p>
<p>解决：使用多个房间（多把锁），studyroom 和 bed room</p>
<ul>
<li><p>好处：增强并发度</p>
</li>
<li><p>坏处：如果一个线程要获取多把锁，容易出现<strong>死锁</strong></p>
</li>
</ul>
<h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个线程各自持有一个锁，却都想获取对方的锁，就没法接着运行。</p>
<h4 id="死锁定位"><a href="#死锁定位" class="headerlink" title="死锁定位"></a>死锁定位</h4><p>方法一：通过 <strong>jps</strong> 和 <strong>jstack</strong>进行定位</p>
<p>jps 查看进程</p>
<p>jstack 用来抓取进程快照</p>
<p>方法二：使用<strong>jconsole</strong></p>
<h4 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h4><p>五个哲学家，五根筷子</p>
<p>Philosopher 类 / Chopstick 类</p>
<p>演示死锁，使用 jconsole 进行检测</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 哲学家就餐 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c1,c2,<span class="hljs-string">&quot;cx1&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c2,c3,<span class="hljs-string">&quot;cx2&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c3,c4,<span class="hljs-string">&quot;cx3&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c4,c5,<span class="hljs-string">&quot;cx4&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c5,c1,<span class="hljs-string">&quot;cx5&quot;</span>);<br>        p1.start();<br>        p2.start();<br>        p3.start();<br>        p4.start();<br>        p5.start();<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>&#125;<br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopstick left;<br>    <span class="hljs-keyword">private</span> Chopstick right;<br>    <span class="hljs-keyword">private</span> String name;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;eating .. &quot;</span>,name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>两个线程不断的改变对方的结束条件，从而导致谁也无法结束。</p>
<p>与死锁的区别：死锁是两个线程都在<strong>阻塞</strong>，<strong>无法继续运行</strong>；而活锁仍然占用 cpu</p>
<p>解决：<strong>尝试增加一些随机的睡眠时间</strong>。</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><h4 id="顺序加锁解决死锁"><a href="#顺序加锁解决死锁" class="headerlink" title="顺序加锁解决死锁"></a>顺序加锁解决死锁</h4><p>先看一个<strong>顺序加锁</strong>解决死锁的案例</p>
<p>线程 1 先获取锁 A,线程 2 也获取锁 A，线程 2 会进入阻塞直到线程 1 释放锁 A。</p>
<p>在哲学家就餐中，如果五个人的筷子都是按顺序获取的，就不会有死锁。</p>
<p>但是，虽然没有死锁，会引出另一种问题，就是<strong>饥饿</strong>。</p>
<p>将死锁情况下的最后一个哲学家的持有筷子改为 c1 c5，就没有死锁发生，但是会发现，最后一个哲学家基本吃不上饭，</p>
<p>这就发生了饥饿。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 哲学家就餐 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c1,c2,<span class="hljs-string">&quot;cx1&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c2,c3,<span class="hljs-string">&quot;cx2&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c3,c4,<span class="hljs-string">&quot;cx3&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c4,c5,<span class="hljs-string">&quot;cx4&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c1,c5,<span class="hljs-string">&quot;cx5&quot;</span>);<br>        p1.start();<br>        p2.start();<br>        p3.start();<br>        p4.start();<br>        p5.start();<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>&#125;<br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopstick left;<br>    <span class="hljs-keyword">private</span> Chopstick right;<br>    <span class="hljs-keyword">private</span> String name;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;eating .. &quot;</span>,name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock 可重入锁"></a>ReentrantLock 可重入锁</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>相对于 synchronized，其特点</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁（解决饥饿）；<strong>线程先到先得，而不是随机争抢</strong>，但是并发度低</li>
<li>支持多个条件变量</li>
</ul>
<p>与 synchronized 一样，ReentrantLock 支持重入</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁</span><br>reentrantlock.lock();<br><br><span class="hljs-keyword">try</span>&#123;<br> <span class="hljs-comment">//临界区</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">//释放锁</span><br>  reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>synchronized 的锁实际上是 monitor 对象。</p>
<p>而 ReentrantLock 本身就是锁对象</p>
<p>演示可重入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 可重入 &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            method2();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>这里就与 synchronized 不同，reentrant lock 可打断</p>
<p>由其他线程调用 interrupt 的来打断，是被动的放弃锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果没有竞争，那么此方法会获取lock锁</span><br>         <span class="hljs-comment">//如果有竞争,进入阻塞队列，可以被其他线程用interrupt方法打断</span><br>                lock.lockInterruptibly();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                log.debug(<span class="hljs-string">&quot;未获取到锁，return&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;成功获取锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br><br>        lock.lock();<br>        t1.start();<br>        t1.interrupt();<br></code></pre></td></tr></table></figure>

<p>可以打断，也是一种防止死锁的手段。</p>
<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>这是主动放弃锁的方式；如果其他线程占有了锁，自己不会无限制的阻塞下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//尝试得到锁，如果已被占有就return false</span><br>                <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS))&#123;<br>                    log.debug(<span class="hljs-string">&quot;未获得锁&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>            <span class="hljs-comment">//得到锁了也要释放</span><br>            <span class="hljs-keyword">try</span> &#123;<br>               log.debug(<span class="hljs-string">&quot;获得锁&quot;</span>);<br>           &#125;<span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>           &#125;<br><br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        log.debug(<span class="hljs-string">&quot;main 上锁&quot;</span>);<br>        lock.lock();<br><br>        t1.start();<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;main 释放锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>tryLock 返回的是 bool 值，得到锁就返回 true</p>
<p>tryLock 也可以带参数，表示尝试获取锁等待的时间。同时在等待的时候也会被打断。被打断的逻辑与之前基本一致。</p>
<h4 id="锁超时解决哲学家吃饭"><a href="#锁超时解决哲学家吃饭" class="headerlink" title="锁超时解决哲学家吃饭"></a>锁超时解决哲学家吃饭</h4><ol>
<li><p>筷子是锁，所以筷子继承 ReentrantLock</p>
</li>
<li><p>核心思想：用 tryLock 获取锁，获取不到也不拿着另一把干等着；两把锁获取到了，吃饭，把锁释放掉</p>
</li>
<li><p>为什么能解决？因为当一个哲学家拿起左手筷子后，拿右手筷子失败了，他会把左手筷子释放掉。而不是带着左手筷子死等。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>&#125;<br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopstick left;<br>    <span class="hljs-keyword">private</span> Chopstick right;<br>    <span class="hljs-keyword">private</span> String name;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-keyword">if</span>(left.tryLock())&#123;<br>              <span class="hljs-keyword">try</span>&#123;<br>                  <span class="hljs-keyword">if</span> (right.tryLock())&#123;<br>                      <span class="hljs-keyword">try</span> &#123;<br>                          eat();<br>                      &#125;<span class="hljs-keyword">finally</span> &#123;<br>                          right.unlock();<br>                      &#125;<br>                  &#125;<br>              &#125;<span class="hljs-keyword">finally</span> &#123;<br>                  left.unlock();<br>              &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;eating .. &quot;</span>,name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock 默认是不公平锁；可以<strong>在构造方法中</strong>指定。</p>
<p>公平的意思是<strong>阻塞队列中先入队的线程</strong>先获得锁。</p>
<p>这里先不讲，公平锁一般没有必要，<strong>会降低并发度</strong>，后面分析原理时学习。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量</p>
<p>而 reelock<strong>支持多条件变量</strong>，也就是支持多间”休息室“，不同的条件变量有独属于自己的“休息室”</p>
<p>这样的好处是<strong>不用再使用</strong>notifyall 进行<strong>虚假唤醒</strong>然后重新循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-comment">//创建一个条件变量</span><br>lock.newCondition();<br>lock.lock();<br><span class="hljs-comment">// 去等待</span><br>condition1.await();<br><span class="hljs-comment">//叫醒condition1中的一个线程</span><br>condition1.signal();<br><span class="hljs-comment">//叫醒condition1中的全部线程</span><br>condition1.signalAll();<br></code></pre></td></tr></table></figure>

<p><strong>使用流程</strong></p>
<ul>
<li>使用 await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 condition 等待</li>
<li>await 的线程被唤醒（或打断，超时），重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<h4 id="条件变量使用例子"><a href="#条件变量使用例子" class="headerlink" title="条件变量使用例子"></a>条件变量使用例子</h4><ol>
<li>以 room 为锁</li>
<li>创建等烟和等外卖的休息室（条件变量）；两个 condition</li>
<li>依旧是循环判断条件变量有没有满足</li>
<li>区别在于<strong>不会被虚假唤醒</strong></li>
</ol>
<h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><p><strong>控制线程的运行次序</strong></p>
<h3 id="控制次序"><a href="#控制次序" class="headerlink" title="控制次序"></a>控制次序</h3><h4 id="方式一-wait-amp-notify-的正确姿势"><a href="#方式一-wait-amp-notify-的正确姿势" class="headerlink" title="方式一 wait&amp;notify 的正确姿势"></a>方式一 wait&amp;notify 的正确姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> canGo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">while</span> (canGo == <span class="hljs-literal">false</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br><br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                canGo = <span class="hljs-literal">true</span>;<br>                lock.notifyAll();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="方式二-park-amp-unpark"><a href="#方式二-park-amp-unpark" class="headerlink" title="方式二 park&amp;unpark"></a>方式二 park&amp;unpark</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">//Thread.sleep(2000);</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                LockSupport.unpark(t1);<br><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br></code></pre></td></tr></table></figure>

<h4 id="方式三-reentrantlock-的-await-amp-signal"><a href="#方式三-reentrantlock-的-await-amp-signal" class="headerlink" title="方式三 reentrantlock 的 await&amp;signal"></a>方式三 reentrantlock 的 await&amp;signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">static</span> Condition condition;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        condition = lock.newCondition();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>               lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                condition.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">//Thread.sleep(2000);</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br><br><br>                <span class="hljs-keyword">try</span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                    condition.signalAll();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="交替执行"><a href="#交替执行" class="headerlink" title="交替执行"></a>交替执行</h3><p>线程一输出 5 个 a，线程 2 输出 5 个 b，线程 3 输出 5 个 c，想要输出 abcabcabcabcabc？</p>
<p>解决：需要<strong>等待标记</strong>和<strong>下一个标记</strong></p>
<h4 id="方式一-wait-amp-notify"><a href="#方式一-wait-amp-notify" class="headerlink" title="方式一 wait&amp;notify"></a>方式一 wait&amp;notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify</span> <span class="hljs-variable">waitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> waitFlag,<span class="hljs-type">int</span> nextFlag)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>                <span class="hljs-keyword">while</span>(flag != waitFlag)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="方式二-await-amp-signal"><a href="#方式二-await-amp-signal" class="headerlink" title="方式二 await&amp;signal"></a>方式二 await&amp;signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">aw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> aw.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> aw.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> aw.newCondition();<br>        t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            aw.print(<span class="hljs-string">&quot;a&quot;</span>,a,b);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            aw.print(<span class="hljs-string">&quot;b&quot;</span>,b,c);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>        t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            aw.print(<span class="hljs-string">&quot;c&quot;</span>,c,a);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        aw.lock();<br>        a.signal();<br>        aw.unlock();<br>    &#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNum)</span>&#123;<br>        <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition now, Condition next)</span>&#123;<br>       lock();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                now.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.print(str);<br>            next.signal();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="方式三-park-amp-unpark"><a href="#方式三-park-amp-unpark" class="headerlink" title="方式三 park&amp;unpark"></a>方式三 park&amp;unpark</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ParkUnpark</span> <span class="hljs-variable">waitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParkUnpark</span>(<span class="hljs-number">5</span>);<br>         t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;b&quot;</span>,t3);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>         t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;a&quot;</span>,t2);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>         t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;c&quot;</span>,t1);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>);<br><br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        LockSupport.unpark(t1);<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkUnpark</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParkUnpark</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,Thread thread)</span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br><br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(thread);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220327173020587.png" srcset="/img/loading.gif" lazyload alt="image-20220327173020587"></p>
<p><img src="/img/mac/image-20220327173031893.png" srcset="/img/loading.gif" lazyload alt="image-20220327173031893"></p>
<h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h2><p>jmm 定义了主存和工作内存等抽象概念。</p>
<ul>
<li><p>主存，静态成员变量等<strong>共享的数据</strong></p>
</li>
<li><p>工作内存，每个线程私有的变量。</p>
</li>
</ul>
<p>底层对应了 cpu 寄存器、缓存、硬件内存、cpu 优化等。</p>
<ul>
<li>原子性：保证指令不会受到线程上下文切换的影响</li>
<li>可见性：保证指令不会受到 cpu 缓存的影响</li>
<li>有序性：保证指令不会受到 cpu 并行优化的影响</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (flag)&#123;<br><br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;can print?&quot;</span>);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        flag = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>初始状态，t 线程刚开始从主存读取了 run 的值到工作内存。</li>
<li>因为 t 线程要频繁的从主内存中读取 run 的值，<strong>即时编译器会将 run 的值缓存至自己工作内存中的高速缓存中</strong>。减少对主存中 run 的访问，提高效率。</li>
<li>1 秒后，main 线程修改了 run 的值，并同步至主存，而<strong>t 线程是从自己工作内存中的高速缓存中</strong>读取这个变量的值，结果永远是旧值。</li>
</ol>
<h3 id="volatile-解决可见性"><a href="#volatile-解决可见性" class="headerlink" title="volatile 解决可见性"></a>volatile 解决可见性</h3><p>它只能修饰<strong>成员变量</strong>和<strong>静态成员变量</strong></p>
<p>被这个关键字修饰的值就不<strong>能再从缓存中读取</strong>，必须<strong>从主存中获取</strong>。</p>
<p>解决退不出的循环：可以用 volatile，也可以用 synchronized。把对共享变量的修改放在 synchronized 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用synchronized解决</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                    <span class="hljs-keyword">if</span> (!flag)&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;can print?&quot;</span>);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a>可见性 vs 原子性</h3><p><strong>volatile 适合一个线程修改</strong>共享变量，<strong>多个线程读取</strong>共享变量的情况。</p>
<p><strong>volatile 只能保证多个线程看到最新值</strong>，但不能保证指令交错，也就是<strong>不能保证原子性，只能保证可见性</strong>。</p>
<p>以一个线程 i++，一个 i–为例。</p>
<p><img src="/img/mac/image-20220328142549030.png" srcset="/img/loading.gif" lazyload alt="image-20220328142549030"></p>
<p>volatile 只能保证 getstatic 读取的是最新值，但不一定是修改后的值。</p>
<p><strong>synchronized</strong>语句<strong>既可以保证代码块内的原子性，又可以保证代码块内变量的可见性</strong>，但其缺点是 synchronized 是重量级锁,性能低。</p>
<h2 id="改进两阶段终止模式"><a href="#改进两阶段终止模式" class="headerlink" title="改进两阶段终止模式"></a>改进两阶段终止模式</h2><p>设置一个 stop 标记，由打断线程将其置为 true；</p>
<p>符合仅一个线程修改，将其用 volatile 修饰，保证可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (stop)&#123;<br>                    log.debug(<span class="hljs-string">&quot;现在是善后工作&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;执行监控&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.debug(<span class="hljs-string">&quot;在睡眠时被打断，为了更快的善后&quot;</span>);<br>                &#125;<br>            &#125;<br><br><br>        &#125;,<span class="hljs-string">&quot;thread1&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        thread.interrupt();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="同步模式之犹豫-Balking-模式"><a href="#同步模式之犹豫-Balking-模式" class="headerlink" title="同步模式之犹豫 Balking 模式"></a>同步模式之犹豫 Balking 模式</h2><p>用在一个线程发现<strong>另一个线程或本线程已经做了某一件相同的事</strong>，那么<strong>本线程就无需再做了，直接返回</strong>。</p>
<p>如何保证一个方法只运行一次，再运行一次就返回？</p>
<p>以两阶段终止的 start 方法为例。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>前面说的监控是一个；</p>
<p>它还经常用来实现线程安全的单例。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>jvm 在不影响正确性的前提下，可以调整语句的执行顺序</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static int i<span class="hljs-comment">;</span><br>static int j<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<br><br>指令重排可能变成<br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<br>单线程下可能没问题<br>多线程情况下会出问题<br></code></pre></td></tr></table></figure>

<h3 id="指令重排优化"><a href="#指令重排优化" class="headerlink" title="指令重排优化"></a>指令重排优化</h3><p>cpu 会把多个指令的不同部分并发的执行，来提高吞吐量。</p>
<p>执行一条指令的过程：<strong>取指令-指令译码-执行指令-内存访问-数据写回。</strong></p>
<p>流水线技术并不能缩短单条指令的执行时间，但其变相的提高了指令的吞吐率</p>
<p><img src="/img/mac/image-20220328151206165.png" srcset="/img/loading.gif" lazyload alt="image-20220328151206165"></p>
<p>再来看 java 中的指令重排，其实是跟流水线一样的。这些指令的各个阶段可以通过重排序和组合来实现指令级并行。</p>
<p>指令重排的前提是，重排指令不能影响结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不能重排</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<h3 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>　<span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span>&#123;<br>　 <span class="hljs-keyword">if</span>(ready)&#123;<br>　  num = num + num;<br>　 &#125;<span class="hljs-keyword">else</span>&#123;<br>　  num = <span class="hljs-number">1</span>;<br>　 &#125;<br>　&#125;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span>&#123;<br>　<br>num= <span class="hljs-number">2</span>;<br>　ready = <span class="hljs-literal">true</span>;<br>　&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中，<strong>最后 num 的值有可能是 0</strong>！</p>
<p>是因为<strong>在 actor2 中 两段语句发生了重排</strong>，ready = true 先执行。 最后 num = 0+0；</p>
<h3 id="指令重排的禁用"><a href="#指令重排的禁用" class="headerlink" title="指令重排的禁用"></a>指令重排的禁用</h3><p>在 ready 上<strong>添加一个 volatile</strong>即可。</p>
<p>为什么不添加在 num 上？</p>
<p>因为加在 ready 上，能<strong>防止它之前的代码不会被重排序到他后面</strong>。<strong>原理是写屏障</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>　<span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span>&#123;<br>　 <span class="hljs-keyword">if</span>(ready)&#123;<br>　  num = num + num;<br>　 &#125;<span class="hljs-keyword">else</span>&#123;<br>　  num = <span class="hljs-number">1</span>;<br>　 &#125;<br>　&#125;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span>&#123;<br>　<br>num= <span class="hljs-number">2</span>;<br>　ready = <span class="hljs-literal">true</span>;<br>　&#125;<br></code></pre></td></tr></table></figure>

<h2 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h2><p>volatile 的实现原理是内存屏障</p>
<ul>
<li>对 volatile 变量的写指令会加入写屏障</li>
<li>对 volatile 变量的读指令会加入读屏障</li>
</ul>
<h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><ul>
<li>写屏障实例 保证在该屏障之前的，对<strong>共享变量的改动，都同步到主存当中</strong>；例子中就是<strong>ready 的值同步到主存，顺带将 num 的值也同步到主存中</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span>&#123;<br>　<br>   num= <span class="hljs-number">2</span>;<br>　ready = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">//写屏障</span><br>　&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>读屏障 保证在该屏障之后，对共享变量的读取，加载的是主存中最新的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span>&#123;<br>　 <span class="hljs-comment">//读屏障</span><br>　 <span class="hljs-keyword">if</span>(ready)&#123;<br>　  num = num + num;<br>　 &#125;<span class="hljs-keyword">else</span>&#123;<br>　  num = <span class="hljs-number">1</span>;<br>　 &#125;<br>　&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220328154056508.png" srcset="/img/loading.gif" lazyload alt="image-20220328154056508"></p>
<h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><ul>
<li>写屏障保证指令重排序时，不会将<strong>写屏障之前的代码排在写屏障之后</strong></li>
<li>读屏障会确保指令重排序时，<strong>不会将读屏障之后的代码排在读屏障前</strong></li>
</ul>
<h3 id="不能解决指令交错-原子性"><a href="#不能解决指令交错-原子性" class="headerlink" title="不能解决指令交错-原子性"></a>不能解决指令交错-原子性</h3><ul>
<li>写屏障<strong>仅仅是保证之后的读能够读取到最新值</strong>，但不能保证读跑到它前面去。</li>
<li><strong>有序性</strong>的保证也<strong>只是保证本线程相关代码不被重排序</strong></li>
</ul>
<h2 id="单例-double-check"><a href="#单例-double-check" class="headerlink" title="单例 double-check"></a>单例 double-check</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br>instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 instance 不加 volatile，上面的代码在多线程环境下还是有问题的。</p>
<p>第一个 if 语句使用了 instance，没有被 synchronized 保护，会发生<strong>指令重排</strong>问题。</p>
<p>getInstance 方法的字节码为：</p>
<p><img src="/img/mac/image-20220328161638346.png" srcset="/img/loading.gif" lazyload alt="image-20220328161638346"></p>
<ul>
<li>17 表示创建对象，将对象引用入栈</li>
<li>20 表示复制一份对象引用</li>
<li>21 表示根据引用地址，调用构造方法</li>
<li>24 表示利用一个对象引用，赋值给 static INSTANCE</li>
</ul>
<p>可能 jvm 会将其优化为<strong>先执行 24，后执行 21</strong>。这可能会进一步导致对象的构造方法还没有执行完毕就被 t2 线程拿到了单例对象。</p>
<p><img src="/img/mac/image-20220328161423924.png" srcset="/img/loading.gif" lazyload alt="image-20220328161423924"></p>
<p>关键在于 <strong>0：getstatic 这行代码在 monitor 控制之外</strong>，它可以越过 monitor 读取 INSTANCE 变量的值。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>你可能会疑惑为什么 synchronized 代码块里的对象还会发生重排序呢？</p>
<p>synchronized 代码块中的代码块依旧有可能是被重排序的。但是如果一个共享变量完全交给 synchronized 保护，那么就完全不会有原子性，可见性，有序性的问题。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>解决方法很简单。<strong>给 INSTANCE 加上 volatile</strong>即可。</p>
<p>从内存屏障进行分析重排序</p>
<p><strong>读屏障之后不发生重排，写屏障之前不发生重排</strong>。</p>
<p>t1 线程对共享变量进行赋值，同时带了写屏障。这就能保证 <strong>赋值和执行构造方法的两条指令不再发生重排序</strong>。所以不会有刚才的问题。</p>
<p><img src="/img/mac/image-20220328162318395.png" srcset="/img/loading.gif" lazyload alt="image-20220328162318395"></p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens before"></a>happens before</h2><p>happens before<strong>规定了对共享变量的写操作对其他线程的读可见</strong>，它是可见性与有序性的一套规则。</p>
<p>太多了，具体看笔记。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="balking-模式习题"><a href="#balking-模式习题" class="headerlink" title="balking 模式习题"></a>balking 模式习题</h3><h3 id="线程安全单例习题"><a href="#线程安全单例习题" class="headerlink" title="线程安全单例习题"></a>线程安全单例习题</h3><p>饿汉式：类加载时就会导致该单例对象创建</p>
<p>懒汉式：类加载时不会导致该单例对象被创建，首次使用该对象时才创建</p>
<h4 id="实验-1-饿汉式"><a href="#实验-1-饿汉式" class="headerlink" title="实验 1 饿汉式"></a>实验 1 饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;&#125;<br><br></code></pre></td></tr></table></figure>

<p>如果实现了序列化接口，还要做什么来防止反序列化破坏单例？</p>
<p>可以这么做：在单例类中加个方法；反序列化时就调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span>&#123;<br>　<span class="hljs-keyword">return</span> INSTANCE;<br>　&#125;<br></code></pre></td></tr></table></figure>

<p>将构造器设为私有能否防止反射创建新的实例？</p>
<p>不行，反射可以获得构造器并且把 setaAccessable 为 true。</p>
<p>饿汉式的初始化能否保证单例创建时的线程安全？</p>
<p>可以，由 jvm 保证线程安全。</p>
<p>为什么提供静态方法而不是 public？</p>
<p>可以使用懒惰式加载；更好的封装性；利用泛型等等。。</p>
<h4 id="实验-2-枚举"><a href="#实验-2-枚举" class="headerlink" title="实验 2 枚举"></a>实验 2 枚举</h4><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;<br> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>枚举如何限制实例个数？</p>
<p>创建时是否有并发问题？</p>
<p>枚举类的实例实际上就是静态成员变量。</p>
<p>public final static …</p>
<p>能否用反射破坏单例？</p>
<p>不行。</p>
<p>枚举能否被反序列化破坏单例？</p>
<p>枚举默认实现序列化接口。但是其在实现中可以避免被反序列化破坏单例。</p>
<p>枚举是懒汉还是饿汉？</p>
<p>静态变量，饿汉</p>
<p>如果希望加入一些单例创建时的初始化怎么做？</p>
<p>使用构造方法。</p>
<h4 id="实验-3-懒汉式-doublecheck"><a href="#实验-3-懒汉式-doublecheck" class="headerlink" title="实验 3 懒汉式-doublecheck"></a>实验 3 懒汉式-doublecheck</h4><p>为什么要加 volatile</p>
<p>解决<strong>synchronized 代码块里指令发生重排序</strong>问题，从而导致线程获取到了<strong>还没调用构造方法的引用</strong>。</p>
<p>为什么要第二次判断实例是否为空？</p>
<p>为了避免首次创建对象时的并发问题，如果没有这次判断。单例对象会被多次创建。</p>
<h4 id="实验-4-懒汉式静态内部类"><a href="#实验-4-懒汉式静态内部类" class="headerlink" title="实验 4 - 懒汉式静态内部类"></a>实验 4 - 懒汉式静态内部类</h4><p>为什么是懒汉？</p>
<p>类在被使用到才进行加载，对类进行加载，从而进行实例的初始化，所以是懒汉</p>
<p>创建时并发问题？</p>
<p>由 jvm 保证线程安全。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/img/mac/image-20220328171654735.png" srcset="/img/loading.gif" lazyload alt="image-20220328171654735"></p>
<h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><p>先看一个案例</p>
<p>一个账户 10000 元，</p>
<p>开 1000 个线程-10 元。账户金额是共享变量，我们知道 synchronized 对其进行保护即可。</p>
<p>但是先引入一下原子类，用无锁的方式保证并发。</p>
<h2 id="无锁实现对比有锁实现"><a href="#无锁实现对比有锁实现" class="headerlink" title="无锁实现对比有锁实现"></a>无锁实现对比有锁实现</h2><p>AtoInteger 套路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>　(<span class="hljs-literal">true</span>)&#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br> <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br> <span class="hljs-comment">//比较并设置</span><br> <span class="hljs-keyword">if</span>(balance.compareAndSet(prev,next))&#123;<br>    <span class="hljs-keyword">break</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CAS-与-volatile"><a href="#CAS-与-volatile" class="headerlink" title="CAS 与 volatile"></a>CAS 与 volatile</h2><h3 id="CAS-原理"><a href="#CAS-原理" class="headerlink" title="CAS 原理"></a>CAS 原理</h3><p>上例中关键的是 compareAndSet<strong>比较并交换</strong>。他简称就是 cas，cas 这个操作是原子的，由 cpu 来保证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>　(<span class="hljs-literal">true</span>)&#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br> <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br> <span class="hljs-comment">//比较并设置</span><br> <span class="hljs-keyword">if</span>(balance.compareAndSet(prev,next))&#123;<br>    <span class="hljs-keyword">break</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>balance.compareAndSet(prev,next)是将<strong>prev 参数和 balance 里维护的 value</strong>对比，如果值不一样就返回 false。</p>
<ul>
<li>CAS 的底层是 lock cmpxchg 指令，在单核和多核 cpu 下都能保证【比较-交换】的原子性</li>
<li>多核状态下，某个核执行到带 lock 的指令时，cpu 会让总线锁住，当这个核把此指令执行完毕再开启总线。 这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li>
</ul>
<h3 id="volatile-cas"><a href="#volatile-cas" class="headerlink" title="volatile-cas"></a>volatile-cas</h3><p>cas 操作<strong>必须配合</strong>volatile。每次 cas 需要保证读取到共享变量的最新值。</p>
<p>AtomicInteger 里面就维护了一个 volatile 修饰的共享变量 value。</p>
<h3 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h3><ul>
<li>无锁情况下，<strong>即使重试失败，线程仍然在运行</strong>；而 synchronized 会让线程进入阻塞状态，发生<strong>上下文切换</strong>，上下文切换的代价是很大的。</li>
<li>无锁情况下，因为线程要保持运行，需要多核 cpu 支持。让线程数小于 cpu 核心数，否则一样会发生上下文切换</li>
</ul>
<h3 id="cas-的特点"><a href="#cas-的特点" class="headerlink" title="cas 的特点"></a>cas 的特点</h3><ul>
<li>无锁并发，适用于线程数少，多核 cpu 的场景</li>
<li>cas 是基于乐观锁的思想；不怕别的线程来修改共享变量，就算改了，大不了就吃点亏重试</li>
<li>cas 体现的是无锁并发，无阻塞并发<ul>
<li>因为没有使用 synchronized，所以线程不会进入阻塞，是效率提升的因素之一</li>
<li>但如果竞争激烈，重试必然频繁发生，反而效率会受到影响。</li>
</ul>
</li>
</ul>
<h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ul>
<li>AtomicInteger</li>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
</ul>
<p>三者差不多，以 AtomicInteger 为例。</p>
<ul>
<li>compareAndSet 方法</li>
<li>incrementAndGet 自增并获取值等价于 ++i</li>
<li>getAndIncrement 先获取值后自增，等价于 i++</li>
<li>decrementAndGet –i 同上</li>
<li>getAndDecrement i–同上</li>
</ul>
<p>上面的操作都可以认为是原子的。利用 cas 保证安全性。后面的方法也一样。</p>
<ul>
<li>getAndAdd(5) 先获取后增加</li>
<li>addAndGet(5) 先增加后获取</li>
</ul>
<p>用这两个方法改进取款。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">不用之前的<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> + compareAndSet<br>直接<br>balance.addAndGet(-<span class="hljs-number">1</span>*amount);<br>结束<br></code></pre></td></tr></table></figure>

<ul>
<li>updateAndGet(IntUnaryOperation updateFunction)</li>
</ul>
<p>这个参数是什么？是一个<strong>函数式接口</strong>。<strong>里面的方法是一个 int 类型的参数（自身维护的 value 值），返回 int 类型的值（运算后得到的值）</strong>。</p>
<p>用这个方法可以实现乘除运算，同样保证原子操作。</p>
<h3 id="模拟-updateAndGet-原理"><a href="#模拟-updateAndGet-原理" class="headerlink" title="模拟 updateAndGet 原理"></a>模拟 updateAndGet 原理</h3><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> operator(prev);<br>  <span class="hljs-keyword">if</span>(balance.compareAndSet(prev,next))&#123;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>把上面的代码块模拟成方法</p>
<p>把<strong>对数值的操作当作接口</strong>传递进来。IntUnaryOperator, unary 是一元的意思，表示一个参数。</p>
<h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>如果想保护如 BigDecimal 等小数类型的原子性，可以用原子引用。</p>
<ul>
<li>AtoReference</li>
<li>AtoMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<h3 id="AtoReference"><a href="#AtoReference" class="headerlink" title="AtoReference"></a>AtoReference</h3><p>依旧以账户转账为例，金额用 bigdecimal，共享变量用 AtomicReference&lt;&gt;。</p>
<p>依旧是 compare and set 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicRefeAccount</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicRefeAccount</span><span class="hljs-params">(AtomicReference&lt;BigDecimal&gt; ato)</span>&#123;<br>        <span class="hljs-built_in">this</span>.balance = ato;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(prev);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev,next))&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>CAS 仅仅只是判断共享变量前后是否一致，但是能不能判断被其他线程修改过？</p>
<p><strong>并不能</strong></p>
<p>主线程想把 A 改成 C; 如果另外两个线程把 a 改成 b，又让 b 变回 a；主线程是无法感知到这一情况的，一样会把 a 改成 c。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicReference&lt;String&gt; ato = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;a&quot;</span>);<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>))&#123;<br>                    log.debug(<span class="hljs-string">&quot;a to b&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>))&#123;<br>                    log.debug(<span class="hljs-string">&quot;b to a&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;a to c&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>解决？</p>
<p>只要有其他线程动过了共享变量，那么自己的 cas 就算失败，<strong>仅仅比较值是不够的，需要添加一个<u>版本号</u></strong></p>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><ul>
<li>getStamp   获取版本号</li>
<li>compareAndSet 额外的两个参数，是之前的版本号和更新后的版本号（+1）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicStampedReference&lt;String&gt; ato = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">0</span>);<br><br><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>               <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>                   log.debug(<span class="hljs-string">&quot;a to b&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br><br>       &#125;).start();<br><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>               <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))&#123;<br>                   log.debug(<span class="hljs-string">&quot;b to a&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br><br>       &#125;).start();<br><br>       Sleeper.sleep(<span class="hljs-number">1</span>);<br>       <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>       log.debug(<span class="hljs-string">&quot;a to c&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="AtoMarkableReference"><a href="#AtoMarkableReference" class="headerlink" title="AtoMarkableReference"></a>AtoMarkableReference</h3><p>通过 AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，<strong>我们不关心被更改了几次，只关心是否被更改了</strong>。</p>
<p>就可以用<strong>AtoMarkableReference</strong>，用一个 bool 变量维护状态是否改变</p>
<p><img src="/img/mac/image-20220329101713577.png" srcset="/img/loading.gif" lazyload alt="image-20220329101713577"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>原子引用如 AtomicReference 修改的是引用本身，如果我们想引用里面的值。如数组，我们想修改数组里的元素。</p>
<p>则 Atomic reference 就不能进行对数组里面的值修改的保护。</p>
<p>由此引出原子数组。</p>
<h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><p>Supplier ： 无中生有，没有参数，一个结果</p>
<p>Function ： 一个参数，一个结果</p>
<p>BiFunction：两个参数，一个结果</p>
<p>Consumer： 一个参数，没有结果</p>
<p>BiConsumer： 两个参数，没有结果</p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>Test39.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>                    array -&gt; array.length,<br>                    (array,index)-&gt; array[index]++,<br>                    array -&gt; System.out.println(Arrays.toString(array))<br><br>            );<br>        &#125;<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>                    array -&gt; array.length(),<br>                    (array,index)-&gt; array.incrementAndGet(index),<br>                    array -&gt; System.out.println(array.toString())<br><br>            );<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    supplier : 提供数组</span><br><span class="hljs-comment">    function : 提供数组长度</span><br><span class="hljs-comment">    BiConsumer : 数组操作</span><br><span class="hljs-comment">    consumer : 打印数组</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; supplier,</span><br><span class="hljs-params">            Function&lt;T,Integer&gt; function,</span><br><span class="hljs-params">            BiConsumer&lt;T,Integer&gt; biConsumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; consumer</span><br><span class="hljs-params"></span><br><span class="hljs-params">    )</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> supplier.get();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> function.apply(array);<br>        List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//开10个线程，每个线程10000次累加 最后应该要有10个10000</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    biConsumer.accept(array,j%length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        list.forEach(thread -&gt; thread.start());<br>        list.forEach(thread -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.print((end-start)+<span class="hljs-string">&quot; &quot;</span>);<br>        consumer.accept(array);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><p>利用字段更新器，可以针对对象的某个域进行原子操作，<strong>只能配合 volatile 修饰的字段使用</strong>，否则出现异常。</p>
<ul>
<li>AtomicReferenceFieldUpdater</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">studnet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;san&quot;</span>);<br>AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>updater.compareAndSet(studnet,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;sisis&quot;</span>);<br>System.out.println(studnet);<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-keyword">volatile</span> String name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name= name;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><h3 id="基本介绍-amp-感受"><a href="#基本介绍-amp-感受" class="headerlink" title="基本介绍&amp;感受"></a>基本介绍&amp;感受</h3><ul>
<li>LongAdder</li>
<li>LongAccumulater</li>
</ul>
<p>Test41.java</p>
<p>Supplier 提供累加器对象</p>
<p>Consumer 执行累计操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>(),<br>                    adder -&gt; adder.increment(),<br>                    longAdder -&gt; System.out.println(longAdder.longValue())<br>            );<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>),<br>                    adder -&gt; adder.getAndIncrement(),<br>                    adder -&gt; System.out.println(adder.get())<br><br>            );<br>        &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>&lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; supplier,</span><br><span class="hljs-params">            Consumer&lt;T&gt; consumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; printConsumer</span><br><span class="hljs-params">    )</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> supplier.get();<br>        List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000000</span>; j++) &#123;<br>                    consumer.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br><br>        list.forEach(Thread::start);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Thread thread : list) &#123;<br>                thread.join();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.print(<span class="hljs-string">&quot;costTime:&quot;</span>+((end-start)/<span class="hljs-number">1000000</span>) +<span class="hljs-string">&quot;,&quot;</span>);<br>        printConsumer.accept(adder);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="性能提升的原因"><a href="#性能提升的原因" class="headerlink" title="性能提升的原因"></a>性能提升的原因</h3><ul>
<li>普通原子类</li>
</ul>
<p>多个线程对共享变量进行++操作，必然导致重试次数变多，导致性能下降</p>
<ul>
<li><p>累加器</p>
<p>在有竞争的时候，设置<strong>多个累加单元（</strong>多个共享变量），它们在累加时操作不同的共享变量（叫 cell），因此减少了 CAS 的重试，从而提高性能</p>
</li>
</ul>
<h3 id="LongAdder-源码"><a href="#LongAdder-源码" class="headerlink" title="LongAdder 源码"></a>LongAdder 源码</h3><p>//累加单元数组，懒惰初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br></code></pre></td></tr></table></figure>

<p>//基础值，如果没竞争，则累加这个域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br></code></pre></td></tr></table></figure>

<p>// 在 cells 创建或扩容时，置为 1，表示加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure>

<p>transient 表示不会被序列化</p>
<h4 id="用-CAS“加锁”-“解锁”"><a href="#用-CAS“加锁”-“解锁”" class="headerlink" title="用 CAS“加锁” “解锁”"></a>用 CAS“加锁” “解锁”</h4><p>LockCas.java</p>
<p>这就是 cellsBusy 的原理</p>
<h4 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h4><p>//防止缓存行伪共享</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span><br></code></pre></td></tr></table></figure>

<p>//最重要的方法，用来 cas 方式进行累加，cmp 表示旧值，val 新值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>什么是缓存行？</strong></p>
<p>cpu 有寄存器，一缓/二缓/三缓。再然后是内存。</p>
<p><img src="/img/mac/image-20220329111538879.png" srcset="/img/loading.gif" lazyload alt="image-20220329111538879"></p>
<p>cpu 读取数据的速度：</p>
<p><img src="/img/mac/image-20220329111457024.png" srcset="/img/loading.gif" lazyload alt="image-20220329111457024"></p>
<p>因为 cpu 和内存交互较慢，需要靠预读数据到缓存来提升效率。而<strong>缓存以缓存行为单位</strong>，每个缓存行对应着一块内存，一般是 64byte（8 个 long）。</p>
<p><strong>数据一致性问题</strong></p>
<p>如果<strong>一个核心对某个缓存行上的数据做了修改</strong>，会让其他核心<strong>对应的缓存行失效</strong>。cpu 要<strong>保证数据的一致性</strong>，必须要重新从内存中读取数据。</p>
<p>接着来看 cells 的具体实现</p>
<p>线程 1 和线程 2 的一个缓存行先从内存中读取 2 个 cell 对象，</p>
<p><img src="/img/mac/image-20220329112339269.png" srcset="/img/loading.gif" lazyload alt="image-20220329112339269"></p>
<p>因为 cell 是数组形式，在内存中是连续存储的，一个 cell 为 24 字节（16 字节对象头+8 字节的 value） ， 因此缓存行可以存下 2 个 cell 对象。</p>
<p>问题来了</p>
<ul>
<li>core-0 要修改 cell[0]</li>
<li>core-1 要修改 cell[1]</li>
</ul>
<p>无论谁修改成功，都会导致对方的 core 的缓存行失效，要重新去内存中读取，这就导致了性能的下降。</p>
<p>解决，让<strong>它们处于不同的缓存行</strong>。</p>
<p>将 cell[0]放在一个缓存行，将 cell[1]放在另一个缓存行。</p>
<p>@sun.misc.Contented 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>，从而<strong>让 cpu 将对象预读至缓存时占用不同的缓存行</strong>，这样不会造成对方的缓存行的失效。</p>
<p><img src="/img/mac/image-20220329113043453.png" srcset="/img/loading.gif" lazyload alt="image-20220329113043453"></p>
<p>再总结//防止缓存行伪共享</p>
<p>由于一个缓存行加入多个 cell 对象叫做伪共享，这个注解就是防止缓存行伪共享。</p>
<h4 id="原理之-add"><a href="#原理之-add" class="headerlink" title="原理之 add"></a>原理之 add</h4><p>先判断 cells 是否为空；</p>
<p>cells 为空：</p>
<ul>
<li>为基础累加值 cas base 累加；<ul>
<li>基础累加值累加成功，return；</li>
<li>基础累加值累加失败，进入 longAccumulate 方法；</li>
</ul>
</li>
</ul>
<p>cells 不为空 说明有竞争存在：</p>
<ul>
<li>判断当前线程有没有对应的 cell 已经被创建<ul>
<li>没创建，进入 longAccumulate 方法</li>
<li>创建了<ul>
<li>cas cell 累加<ul>
<li>成功，return；</li>
<li>失败，进入 longAccumulate 方法；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/mac/image-20220329114825181.png" srcset="/img/loading.gif" lazyload alt="image-20220329114825181"></p>
<p>源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<h4 id="原理之-longAccumulate"><a href="#原理之-longAccumulate" class="headerlink" title="原理之 longAccumulate"></a>原理之 longAccumulate</h4><ul>
<li>cells 不存在&amp;未加锁&amp;未新建，对应第二个和第三个大 elseif</li>
</ul>
<p><img src="/img/mac/image-20220329151110499.png" srcset="/img/loading.gif" lazyload alt="image-20220329151110499"></p>
<ul>
<li>cells 存在&amp;cell 没创建，对应第一个大 if</li>
</ul>
<p><img src="/img/mac/image-20220329151831542.png" srcset="/img/loading.gif" lazyload alt="image-20220329151831542"></p>
<ul>
<li>cells 存在&amp;cell 已创建</li>
</ul>
<h4 id="原理之-sum-方法"><a href="#原理之-sum-方法" class="headerlink" title="原理之 sum 方法"></a>原理之 sum 方法</h4><h2 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h2><h3 id="unsafe-获取"><a href="#unsafe-获取" class="headerlink" title="unsafe 获取"></a>unsafe 获取</h3><p>unsafe 对象提供了<strong>非常底层的，操作内存，操作线程的方法。</strong></p>
<p>unsafe 对象不能直接调用，<strong>只能通过反射获得</strong>。</p>
<p>我们要获得的 Unsafe.Class 的一个成员变量的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//因为是静态成员变量，所以不需要传入实例对象</span><br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> unsafe;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="unsafe-cas-操作"><a href="#unsafe-cas-操作" class="headerlink" title="unsafe cas 操作"></a>unsafe cas 操作</h3><ol>
<li>从 Teacher 类中获取域的偏移地址 objectFieldOffset</li>
<li>执行 cas 操作 compareAndSet</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> UnsafeUtil.getUnsafe();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(field);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>);<br>        unsafe.compareAndSwapObject(teacher,offset,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;zn&quot;</span>);<br>        System.out.println(teacher);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="模拟原子整数类"><a href="#模拟原子整数类" class="headerlink" title="模拟原子整数类"></a>模拟原子整数类</h3><p>// 1. 获取 unsafe 类，做成 util 包</p>
<p>//2.需要一个 value</p>
<p>//3.计算 value 对于类的偏移量</p>
<p>//4.实现 getVal 和 decrement 方法（compareAndSet）方法</p>
<p>最后，在减钱实例上测试一下。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/juc/">juc</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/juc/">juc</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/12/JUC-2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JUC-2</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/12/os/">
                        <span class="hidden-mobile">操作系统</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
