

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Bloo">
  <meta name="keywords" content="">
  
    <meta name="description" content="参考黑马程序员满一航老师的JUC课程。">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC-3">
<meta property="og:url" content="https://bloofcx.github.io/2022/04/12/JUC-3/index.html">
<meta property="og:site_name" content="Bloo">
<meta property="og:description" content="参考黑马程序员满一航老师的JUC课程。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401163718211.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401165050221.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401165153041.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401165451087.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401165722258.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401170148894.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401170628648.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401171550582.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401171559173.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401172327918.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401172459504.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401161242601.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401161407148.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401214307061.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401214953952.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220401215002290.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220402205614794.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220402210101028.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220403095448265.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220403095607289.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220403095641207.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220403095904419.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220403095917943.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220403100042714.png">
<meta property="og:image" content="https://bloofcx.github.io/img/mac/image-20220403102902582.png">
<meta property="article:published_time" content="2022-04-12T14:34:24.000Z">
<meta property="article:modified_time" content="2022-04-12T14:39:11.635Z">
<meta property="article:author" content="Bloo">
<meta property="article:tag" content="juc">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://bloofcx.github.io/img/mac/image-20220401163718211.png">
  
  
  <title>JUC-3 - Bloo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"bloofcx.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Bloo | LongMayTheSunShine</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JUC-3">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-12 22:34" pubdate>
        April 12, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      32k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      269 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JUC-3</h1>
            
            <div class="markdown-body">
              <div class="code-wrapper"><pre><code class="hljs">读写锁
</code></pre></div>
<h3 id="ReentrantReadWriterLock"><a href="#ReentrantReadWriterLock" class="headerlink" title="ReentrantReadWriterLock"></a>ReentrantReadWriterLock</h3><p><strong>基本介绍</strong></p>
<p>支持可重入的读写锁。</p>
<p>当读操作远远高于写操作时，这时候使用<strong>读写锁</strong>让<strong>读-读</strong>可以并发，提高性能。</p>
<p>类似于数据库中的 select … from … lock in share mode</p>
<p><strong>基本使用</strong></p>
<p>提供一个<strong>数据容器类</strong>内部分别使用读锁保护数据的 read（）方法，写锁保护数据的 write（）方法</p>
<p>n8/TestReadWriteLock.java</p>
<p>测试读写锁</p>
<p>读-读 不互斥/可并发</p>
<p>读-写 互斥</p>
<p>写-写 互斥</p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读-写</span><br><span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>        <span class="hljs-type">DataContainer</span> <span class="hljs-variable">container</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br>        container.setData(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        pool.execute(()-&gt;&#123;<br>            lock.readLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Sleeper.sleep(<span class="hljs-number">2</span>);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,container.getData());<br><br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.readLock().unlock();<br>            &#125;<br>        &#125;);<br><br>        pool.execute(()-&gt;&#123;<br>            lock.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;write begin&quot;</span>);<br>                container.setData(<span class="hljs-number">2</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.writeLock().unlock();<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：有读锁的情况再获取写锁，会导致写锁永久等待</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();<br><br><span class="hljs-keyword">try</span>&#123;<br>   w.lock();<br>   <span class="hljs-keyword">try</span>&#123;<br><br>   &#125;<span class="hljs-keyword">finally</span>&#123;<br>    w.unlock();<br>   &#125;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br> r.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">锁的降级：<br><span class="hljs-built_in">writeLock</span>()<span class="hljs-selector-class">.lock</span>();<br>rw1<span class="hljs-selector-class">.readLock</span>()<span class="hljs-selector-class">.lock</span>();<br><span class="hljs-built_in">wirteLock</span>()<span class="hljs-selector-class">.unlock</span>();<br>rw1<span class="hljs-selector-class">.readLock</span>()<span class="hljs-selector-class">.unlock</span>();<br></code></pre></td></tr></table></figure>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>读写锁用的是同一个 sync 同步器，因此等待队列，state 等也是同一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Sync sync;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>        sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>        readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);<br>        writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><p><strong>以 t1 线程上写锁，t2 线程上读锁为例</strong></p>
<p>t1 成功上锁，流程与 reentrantlock 加锁相比没有特殊之处，不同的是写锁状态占 state 的低 16 位，而读锁使用的是 state 的高 16 位。</p>
<p>先看加写锁 t1.w.lock()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">//写锁的lock方法</span><br>          <span class="hljs-comment">//进入acquire</span><br>           sync.acquire(<span class="hljs-number">1</span>);<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>进入 tryAcquire 查看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//进入try Acquire</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>c==0，见图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>         <span class="hljs-comment">// state 写锁状态占state的低16位，而读锁使用的是state的高16位。</span><br>          <span class="hljs-comment">//此时c为0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-comment">//w==0 表示没人加写锁</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>           <span class="hljs-comment">//c！=0的情况分两种有可能是读有可能是写</span><br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br>                <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               <span class="hljs-comment">//重入过多，抛异常</span><br>                <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                <span class="hljs-comment">// Reentrant acquire</span><br>                setState(c + acquires);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>           <span class="hljs-comment">//本次逻辑会走到这，writeShouldBlock固定返回false</span><br>           <span class="hljs-comment">// 将state用cas方式改为c+1</span><br>            <span class="hljs-keyword">if</span> (writerShouldBlock() ||<br>                !compareAndSetState(c, c + acquires))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//cas修改成功，设置当前线程为owner。</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-comment">//return true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401163718211.png" srcset="/img/loading.gif" lazyload alt="image-20220401163718211"></p>
<p>t2 执行 r.lock ， 此时进入读锁的 acquireShared(1)流程，<strong>首先会进入 tryAcquire</strong>流程，如果有写锁占据，那么 tryAcquireShared 返回-1 表示失败</p>
<p>tryAcquireShared 返回值表示</p>
<ul>
<li>-1 表示失败</li>
<li>0 表示成功，但后继节会继续唤醒</li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒</li>
<li>读写锁只会返回 1，更大的数值返回会在信号量中使用到</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//读锁的lock方法</span><br>       <span class="hljs-comment">// 进入acquireShared</span><br>            sync.acquireShared(<span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">//进入tryAcquireShared</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireShared(arg);<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>           <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>           <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>              <span class="hljs-comment">//先看写锁部分是否不为0（true） &amp;&amp; 再看加写锁的是不是自己（false）</span><br>           <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>               getExclusiveOwnerThread() != current)<br>             <span class="hljs-comment">//返回-1</span><br>               <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>           <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>               r &lt; MAX_COUNT &amp;&amp;<br>               compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>               <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                   firstReader = current;<br>                   firstReaderHoldCount = <span class="hljs-number">1</span>;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                   firstReaderHoldCount++;<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>                   <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                       cachedHoldCounter = rh = readHolds.get();<br>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                       readHolds.set(rh);<br>                   rh.count++;<br>               &#125;<br>               <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>       &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401165050221.png" srcset="/img/loading.gif" lazyload alt="image-20220401165050221"></p>
<p>又进入了 doAcquireShared 流程</p>
<p>加共享（shared)的节点类型，此时 node（t2）仍然处于活跃状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">//tryAcquireShared由于加了写锁，且写锁不是自己加的，所以返回-1</span><br>      <span class="hljs-comment">//进入doAcquireShared</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireShared(arg);<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//在队列中生成head头节点和shared类型的当前线程节点</span><br>       <span class="hljs-comment">//将前驱节点的状态值改为-1</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">//if 自己是老二</span><br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                   <span class="hljs-comment">//再尝试获取锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                   <span class="hljs-comment">//获取锁成功的，等会再看</span><br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-comment">// 进入这，两次循环后陷入阻塞。在reentrantlock那块很详细的看过了，不再赘述</span><br>              <span class="hljs-comment">/*</span><br><span class="hljs-comment">              与reentrant lock不同的是，多循环了一次来获取锁；以及node的状态是shared而不是exclusive</span><br><span class="hljs-comment">              */</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401165153041.png" srcset="/img/loading.gif" lazyload alt="image-20220401165153041"></p>
<p><img src="/img/mac/image-20220401165451087.png" srcset="/img/loading.gif" lazyload alt="image-20220401165451087"></p>
<p><strong>在上面的情况下，假设又有 t3 加读锁，t4 加写锁</strong></p>
<p>此时 t1 仍持有锁，注意状态的不同</p>
<p><img src="/img/mac/image-20220401165722258.png" srcset="/img/loading.gif" lazyload alt="image-20220401165722258"></p>
<h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><p><strong>t1.w.unlock</strong></p>
<p>sync.release==》try Release</p>
<p>ownerthread 置为 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//写锁的unlock 进入release</span><br>            sync.release(<span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">// 进入try Release</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>           <span class="hljs-comment">//如果持有锁的不是当前线程 抛异常</span><br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>           <span class="hljs-comment">//nextc = 当前状态 - 1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br><br>           <span class="hljs-comment">// 如果减为0了</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (free)<br>               <span class="hljs-comment">//将当前owner设为null</span><br>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(nextc);<br>            <span class="hljs-comment">// 返回true</span><br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>进入唤醒流程 unparkSuccessor，让老二 t2 恢复运行，在 parkAndCheck Interrupt 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">// try Release返回true</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>           <span class="hljs-comment">// 进入唤醒流程unparkSuccessor</span><br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 这里的node 是 头节点head</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>       <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>           compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>      <span class="hljs-comment">//s为下一个节点</span><br>       <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>           s = <span class="hljs-literal">null</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>               <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                   s = t;<br>       &#125;<br>       <span class="hljs-comment">//唤醒下一个节点 老二</span><br>       <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>           LockSupport.unpark(s.thread);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401170148894.png" srcset="/img/loading.gif" lazyload alt="image-20220401170148894"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>             <span class="hljs-comment">//再次进入循环</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                   <span class="hljs-comment">//进入tryAcquireShared 返回了r=1</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                    <span class="hljs-comment">//这次能进入if语句块</span><br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-comment">//进入</span><br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                 <span class="hljs-comment">//老二在parkAndCheck处被唤醒</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>              <span class="hljs-comment">//c = 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><br>           <span class="hljs-comment">//写锁为0</span><br>            <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>                getExclusiveOwnerThread() != current)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//读锁为0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>            <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>                r &lt; MAX_COUNT &amp;&amp;<br>                <span class="hljs-comment">//前两个条件都成立</span><br>                  <span class="hljs-comment">// cas方式让读锁+1，</span><br>                compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>                <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                    firstReader = current;<br>                    firstReaderHoldCount = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                    firstReaderHoldCount++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>                    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                        cachedHoldCounter = rh = readHolds.get();<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                        readHolds.set(rh);<br>                    rh.count++;<br>                &#125;<br>              <span class="hljs-comment">//return 1读锁加锁成功</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>进入 setHeadAndPropagate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>  <span class="hljs-comment">// 将当前线程节点设为head ， 也就是t2</span><br>  setHead(node);<br><br>  <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>      (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>      <span class="hljs-comment">//s是t2的后继节点，如果是共享类型，进入doReleaseShared</span><br>      <span class="hljs-comment">//本例中是这样的 ， t2和t3都上了读锁，是共享类型节点，所以进入</span><br>      doReleaseShared();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401170628648.png" srcset="/img/loading.gif" lazyload alt="image-20220401170628648"></p>
<p>进入 do ReleaseShared</p>
<p>将头节点的状态从-1 改为 0，假设成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-comment">// head此时为t2</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>               <span class="hljs-comment">// head节点的状态值确实为-1</span><br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                   <span class="hljs-comment">//将头节点的状态从-1改为0，假设其修改成功；修改失败就继续循环了</span><br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                  <span class="hljs-comment">//再把头节点的后继节点唤醒，也就是t3</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401171550582.png" srcset="/img/loading.gif" lazyload alt="image-20220401171550582"></p>
<p>t3 会再走一遍刚才的逻辑，</p>
<p>但是不会再次进入 do ReleaseShared</p>
<p>因为它的下一个节点 t4 不是共享（shared）类型</p>
<p><img src="/img/mac/image-20220401171559173.png" srcset="/img/loading.gif" lazyload alt="image-20220401171559173"></p>
<p>可以看到，这就是读-读并发的原理，它会一连串的把 share 的结点唤醒</p>
<p><strong>t2.r.unlock , t3.r.unlock</strong></p>
<p>tryReleaseShared</p>
<p>进入 doReleaseShared，</p>
<p>将头节点状态改为 0，然后将 t4 唤醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-comment">//读锁的unlock</span><br>            sync.releaseShared(<span class="hljs-number">1</span>);<br>        &#125;<br><br> <span class="hljs-comment">// aqs的模板方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//进入try Release Shared</span><br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接看最后for循环这块了</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>              <span class="hljs-comment">// 把状态减1，然后cas尝试</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                  <span class="hljs-comment">//返回它是否为0，t2的那块返回false，t3的返回true</span><br>                    <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>            &#125;<br></code></pre></td></tr></table></figure>

<p>以 t3 为例，进入 do ReleaseShared</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// aqs的模板方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//try Release Shared 返回true</span><br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        <span class="hljs-comment">// 进入此方法</span><br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-comment">// head此时为t3</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>               <span class="hljs-comment">// head节点的状态值确实为-1</span><br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                   <span class="hljs-comment">//将头节点的状态从-1改为0，假设其修改成功；修改失败就继续循环了</span><br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                  <span class="hljs-comment">//再把头节点的后继节点唤醒，也就是t4</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401172327918.png" srcset="/img/loading.gif" lazyload alt="image-20220401172327918"></p>
<p>t4 从 acquireQueued 醒来，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 将t4变成头节点。</span><br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401172459504.png" srcset="/img/loading.gif" lazyload alt="image-20220401172459504"></p>
<h3 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="应用之缓存"></a>应用之缓存</h3><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>缓存可以使用《先更新数据库，再删除缓存，同时给缓存增加时间》</p>
<ul>
<li>写策略</li>
</ul>
<ol>
<li>将数据更新到数据库</li>
<li>删除缓存</li>
</ol>
<ul>
<li>读策略</li>
</ul>
<ol>
<li>如果缓存命中，返回</li>
<li>如果没有，查询数据库，返回</li>
<li>写入缓存</li>
</ol>
<p>因为缓存的写入要远远快于数据库的更新，所以很少发生数据一致性</p>
<p>在进一步，可以使用消息队列重试或者订阅 binlog</p>
<p>先清缓存还是先更新数据库</p>
<p>图中打上三个感叹号的地方就是<strong>数据不一致</strong>。</p>
<ul>
<li>如果先清缓存，再查询数据库。</li>
</ul>
<p><img src="/img/mac/image-20220401161242601.png" srcset="/img/loading.gif" lazyload alt="image-20220401161242601"></p>
<ul>
<li>如果先更新数据库，也会产生不一致</li>
</ul>
<p><img src="/img/mac/image-20220401161407148.png" srcset="/img/loading.gif" lazyload alt="image-20220401161407148"></p>
<p>解决方式：加锁</p>
<p>写操作加写锁，读操作加读锁。</p>
<p>写操作 包括修改数据库，将数据放入缓存。</p>
<p>读操作包括读取缓存。</p>
<ul>
<li>缓存适合读取操作远远多于写操作的场景</li>
<li>没有考虑缓存容量</li>
<li>没有考虑缓存过期</li>
<li>只适合单机，不适合分布式</li>
<li>并发性还是低，目前只会用一把锁；可以<strong>针对不同的表设计不同的锁</strong></li>
<li>更新方法太过简单粗暴，清空了所有的 key（考虑按类型分区，或者重新设计 key）</li>
</ul>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>jdk8 加入，进一步优化读性能，特点是<strong>使用读、写锁时都配合【戳】使用</strong></p>
<p>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock(stamp);<br></code></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">lock</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure>

<p>乐观读，读取完毕后需要做一次戳校验，如果校验通过，表示这期间没有写操作，数据可以安全使用；如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<p>乐观读是没有加锁操作的，提高性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-type">long</span>　<span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br>　<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br><span class="hljs-comment">//锁升级 - 读锁</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.testStampLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStampLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            dataContainer.read(<span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            dataContainer.write(<span class="hljs-number">2</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainerStamped</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> readTime)</span> &#123;<br>        <span class="hljs-comment">//乐观读</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br>        log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);<br>        Sleeper.sleep(readTime);<br>        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>        <span class="hljs-comment">// 锁升级 - 读锁</span><br>        log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            stamp = lock.readLock();<br>            log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);<br>            Sleeper.sleep(readTime);<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockRead(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> newData)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>        log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">this</span>.data = newData;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>stampedlock 不支持条件变量</li>
<li>stampedlock 不支持可重入</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上限。</p>
<p>可以有多个共享资源。</p>
<p><strong>一个比喻</strong></p>
<p>停车场车位：共享资源。</p>
<p>车辆：线程。</p>
<p>信号量：剩余车位数。</p>
<p>当信号量为 0 时，就不能再进来了。</p>
<p><strong>使用</strong></p>
<p>许可 permits 表示允许同时访问的线程数。</p>
<p>公平 fair 表示先来的先获得。</p>
<p>acquire 表示获得许可 permits，获得后许可数-1。</p>
<p>release 表示释放许可，也放在 finally 块中。</p>
<p>​</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            pool.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    log.debug(<span class="hljs-string">&quot;start ... &quot;</span>);<br>                    Sleeper.sleep(<span class="hljs-number">2</span>);<br>                    log.debug(<span class="hljs-string">&quot;end ... &quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        pool.shutdown();<br></code></pre></td></tr></table></figure>

<p><strong>应用</strong></p>
<ul>
<li>使用其<strong>限流</strong>，让请求线程阻塞，高峰期过去再释放许可。当然它只适合限制单机线程数量，并且<strong>仅是限制线程数</strong>，而<strong>不是资源数（</strong>例如连接数，对比 Tomcat LimitLatch）</li>
<li>用 Semaphore 实现简单连接池，对比【享元模式】下的实现数据库连接池（用 wait notify），可以用 semaphore 改进</li>
</ul>
<p>// 组合一个 semaphore</p>
<p>//让许可数与资源数一致</p>
<p>//让没有许可的线程去等待，代替了 wait notify</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//while (true)&#123;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capcity; i++) &#123;<br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;获得连接&quot;</span>);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">//            synchronized (this)&#123;</span><br><span class="hljs-comment">//                try &#123;</span><br><span class="hljs-comment">//                    log.debug(&quot;未获得连接，进入等待&quot;);</span><br><span class="hljs-comment">//                    this.wait();</span><br><span class="hljs-comment">//                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                    e.printStackTrace();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br>       <span class="hljs-comment">// &#125;</span><br>        log.debug(<span class="hljs-string">&quot; can I ?&quot;</span>);<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 6 归还连接方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Connection connection)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capcity; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connection  == connections[i])&#123;<br>                states.set(i,<span class="hljs-number">0</span>);<br><span class="hljs-comment">//                synchronized (this)&#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                    this.notifyAll();</span><br><span class="hljs-comment">//                &#125;</span><br>                semaphore.release();<br>                log.debug(<span class="hljs-string">&quot;归还连接&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4><p>构造方法</p>
<p>permit 的参数，其实就传给了 AQS 的 state</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> permits) &#123;<br>            setState(permits);<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>假设 permits 为 3，这时 5 个线程来争抢资源</p>
<p>假设其中线程 1，2，4 竞争成功，而线程 0，3 竞争失败，进入 AQS 阻塞队列 park 阻塞。</p>
<p><strong>以线程 1 为例，加锁成功</strong></p>
<p>acquire 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>acquire shared interruptibly 方法,传入参数为 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-comment">// into here</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireSharedInterruptibly(arg);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>try acquire shared 返回值是剩余的资源数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>                <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>                    compareAndSetState(available, remaining))<br>                     <span class="hljs-comment">//返回值是剩余的资源数</span><br>                    <span class="hljs-keyword">return</span> remaining;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p><strong>以线程 0 为例，加锁失败</strong></p>
<p>acquire 方法</p>
<p>acquire shared interruptibly 方法</p>
<p>try acquire shared 返回值是剩余的资源数</p>
<p>doAcquireShared Interruptibly 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>          <span class="hljs-comment">// into here</span><br>            doAcquireSharedInterruptibly(arg);<br>    &#125;<br><br><br><br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-comment">//给阻塞队列创建节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-comment">//再次尝试获取</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-comment">//循环</span><br>               <span class="hljs-comment">//然后park住</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>给阻塞队列创建节点</p>
<p>再次尝试获取</p>
<p>循环</p>
<p>然后 park 住</p>
<p><img src="/img/mac/image-20220401214307061.png" srcset="/img/loading.gif" lazyload alt="image-20220401214307061"></p>
<h4 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4><p>realease</p>
<p>releaseShared</p>
<p>tryRelease Shared</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>               <span class="hljs-comment">// 拿到0 因为许可都用完了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-comment">// 释放1个许可</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>                <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>               <span class="hljs-comment">//cas将0改为1，返回true</span><br>                <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br><br></code></pre></td></tr></table></figure>

<p>进入 doReleaseShared 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                   <span class="hljs-comment">// 将头节点状态状态cas改为0</span><br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                  <span class="hljs-comment">//unparkSuccessor 唤醒下一个节点</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>以共享节点的方式连续唤醒，是一连串的，类似读写锁的读-读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>        setHead(node);<br>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>            (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-comment">//以共享节点的方式连续唤醒</span><br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>                doReleaseShared();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/mac/image-20220401214953952.png" srcset="/img/loading.gif" lazyload alt="image-20220401214953952"></p>
<p>但是只有一个线程释放了许可，state 仍旧是 0，</p>
<p>thread3 尝试不成功再次进入阻塞</p>
<p><img src="/img/mac/image-20220401215002290.png" srcset="/img/loading.gif" lazyload alt="image-20220401215002290"></p>
<h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p>倒计时锁。</p>
<p>用来进行线程同步协作，等待所有线程完成倒计时。</p>
<p>构造参数用来初始化等待计数值，</p>
<p>await 用来等待计数归零，</p>
<p>countDown 用来让计数减一</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>tryAcquireShared</p>
<p>try ReleaseShared</p>
<p>非常简单的逻辑</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>主线程使用 await 3，表示等待三个计数归零</p>
<p>开三个线程用来让计数-1</p>
<p>用线程池来做</p>
<p>能否用 join 替代 countdownlatch？</p>
<p>因为固定大小线程池的线程一直运行等待任务，所以 join 等不到它们结束。</p>
<p>建议还是用这种高级的 api 代替低级的 join api</p>
<h3 id="应用之同步等待多线程准备完毕"><a href="#应用之同步等待多线程准备完毕" class="headerlink" title="应用之同步等待多线程准备完毕"></a>应用之同步等待多线程准备完毕</h3><p>用线程池开 10 个线程</p>
<p>模拟 10 个玩家加载游戏</p>
<p>用 for 循环模拟加载，用 string 字符串来模拟玩家的加载过程，用随机睡眠时间打印每位玩家的加载进度。用 不换行+“\r”回车符 让后面的内容覆盖前面的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>) ;<br>        String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j;<br>            pool.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(random.nextInt(<span class="hljs-number">200</span>));<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    strs[k] = i+<span class="hljs-string">&quot;% &quot;</span>;<br>                    System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(strs));<br>                &#125;<br>                latch.countDown();<br>            &#125;);<br>        &#125;<br><br><br>       latch.await();<br>        System.out.println(<span class="hljs-string">&quot;\n game begin&quot;</span>);<br>        pool.shutdown();<br></code></pre></td></tr></table></figure>

<h3 id="应用之同步等待多个远程调用结束"><a href="#应用之同步等待多个远程调用结束" class="headerlink" title="应用之同步等待多个远程调用结束"></a>应用之同步等待多个远程调用结束</h3><p>n8/testCountdownLatch.java</p>
<p>用 rest Template 调用不同的微服务，每个微服务都要不同的执行时间，串行处理的效率就非常低。</p>
<p>用线程池 + countdownLatch 进行改造：</p>
<p>分为多个线程进行处理</p>
<h2 id="future-应用"><a href="#future-应用" class="headerlink" title="future 应用"></a>future 应用</h2><p>在应用之同步等待多个远程调用结束中，每个任务的<strong>处理结果</strong>都是<strong>在各自的线程中</strong>。</p>
<p>我们需要<strong>用 future 在主线程中汇总。</strong></p>
<h2 id="Cyclicbarrier"><a href="#Cyclicbarrier" class="headerlink" title="Cyclicbarrier"></a>Cyclicbarrier</h2><p>countDownLatch 不能被重用，每循环一次，就得重新创建</p>
<p>循环栅栏，用来进行线程协作，等待线程满足某个计数。</p>
<p><strong>构造方法</strong></p>
<p>构造时设置计数个数，每个线程执行到需要“同步“的时刻调用 await 方法进行等待，当等待的线程满足计数个数时，继续执行。</p>
<p>第二个参数，是一个 runnable，是当等待数为 0 时执行的线程</p>
<p>与 countDown Latch 不同的是，它的计数到 0 后依旧可以重用。</p>
<p>await 表示当前线程在此阻塞，并且等待值-1。等待值为 0 后方可继续运行。</p>
<p>与 countDown Latch 不同的是，它的计数到 0 后依旧可以重用。</p>
<p>它的数值到 0 后，再调用 await，还是可以继续使用。</p>
<p><strong>注意</strong></p>
<p><strong>构造方法里的等待值，要和线程池里的线程数一致</strong>，否则会出现问题。</p>
<h1 id="八、线程安全集合类概述"><a href="#八、线程安全集合类概述" class="headerlink" title="八、线程安全集合类概述"></a>八、线程安全集合类概述</h1><h2 id="遗留的线程安全集合类"><a href="#遗留的线程安全集合类" class="headerlink" title="遗留的线程安全集合类"></a>遗留的线程安全集合类</h2><h3 id="hashTable"><a href="#hashTable" class="headerlink" title="hashTable"></a>hashTable</h3><p>直接在方法上加 synchronized 的 HashMap，性能低</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>类似。</p>
<h2 id="修饰的线程安全集合类"><a href="#修饰的线程安全集合类" class="headerlink" title="修饰的线程安全集合类"></a>修饰的线程安全集合类</h2><p>采用了装饰器模式</p>
<p>将线程不安全的集合，修饰为线程安全的集合。</p>
<p><strong>原理</strong></p>
<p>在调用集合对应的所有方法里，都加上了一个<strong>synchronized</strong>，性能一样没有提升。</p>
<h2 id="JUC-安全集合"><a href="#JUC-安全集合" class="headerlink" title="JUC 安全集合"></a>JUC 安全集合</h2><p>分为 Blocking 、 CopyOnWrite 、 Concurrent 三大类</p>
<ul>
<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法。很多方法不满足条件时就要等待。</li>
<li>CopyOnWrite 之类容器修改开销相对较重。适用于读多写少的场景</li>
<li>Concurrent 类型容器<ul>
<li>内部使用很多 cas 优化，一般可以提供较高吞吐量</li>
<li><strong>弱一致性</strong><ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，<strong>迭代器仍然可以继续遍历</strong>，这时<strong>内容是旧的</strong>，fali-safe 机制</li>
<li>求大小弱一致性，<strong>size 操作未必是 100%准确</strong></li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用<strong>fail-fast 机制也就是让遍历立刻失败</strong>，抛出 Concurrent Modification Exception，不在继续遍历</p>
<h3 id="ConcurrnetHashMap"><a href="#ConcurrnetHashMap" class="headerlink" title="ConcurrnetHashMap"></a>ConcurrnetHashMap</h3><p><strong>练习 单词计数</strong></p>
<p>N8/TestWordCount</p>
<p>为什么用 ConcurrentHashMap 还是有问题？</p>
<p>因为只是单个方法是线程安全的，但是方法的组合不是线程安全的。</p>
<p>解决方法 1:</p>
<p>上 synchronized</p>
<p>解决方法 2：</p>
<p>分析：因为 get 和 put 不是原子的。 只要这三个操作是原子的，就没有问题了，</p>
<p>用 concurrenthashmap 的 computeIfAbsent 方法</p>
<p>如果缺少一个 key，则计算生成一个值，然后将 key value 放入 map。</p>
<p>累加操作使用 longAdder 来保证</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>先看 hashmap，看看 hash map 有哪些线程不安全的地方</p>
<h5 id="1-7-的-hash-map-的死链"><a href="#1-7-的-hash-map-的死链" class="headerlink" title="1.7 的 hash map 的死链"></a><strong>1.7 的 hash map 的死链</strong></h5><p>哈希表是用拉链法，就是哈希冲突时用的是链表。</p>
<p>1.7 中，<strong>后插入的数据放在链表头部</strong>，死链的必要条件</p>
<p>1.8 中，后插入的数据放在链表尾部</p>
<ul>
<li>扩容：当数组超过 3/4 时，会将数组扩容为原来的 2 倍。并且会重新计算桶下标。</li>
<li>并发死链：在多线程的情况下，如果进行扩容，会产生并发死链问题。</li>
</ul>
<p>并发死链测试</p>
<p>test/testDeadLink.java</p>
<p>长度达到 12 的时候扩容 3/4.</p>
<p>在 transfer 590 行处加个断点</p>
<p>并且添加断点条件，让 Thread 0 和 1 在扩容时停下。</p>
<p>随后让 Thread1 执行完整个扩容。</p>
<p>再看 Thread-0，断点打在 594 行。他的 e 和 next 引用还是没有变，仍旧是 1 和 35。</p>
<p>但是 Thread-1 已经更改了引用里面的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> 由<br> e  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">35</span>-&gt;<span class="hljs-number">16</span>-&gt;<span class="hljs-literal">null</span><br> next  <span class="hljs-number">35</span>-&gt;<span class="hljs-number">16</span>-&gt;<span class="hljs-literal">null</span><br><br> 变为<br>e  <span class="hljs-number">1</span>-&gt;<span class="hljs-literal">null</span><br>next <span class="hljs-number">35</span>-&gt;<span class="hljs-number">1</span><br><br> 再循环一次<br>   把e放入链表，next变成了e<br>   下一个e变成了<span class="hljs-number">35</span><br>   但是<span class="hljs-number">35</span>又链着<span class="hljs-number">1</span><br>   链表变成<br>   <span class="hljs-number">1</span>-&gt;<span class="hljs-number">35</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-literal">null</span><br>   再循环一次<br>   死链就会形成<br></code></pre></td></tr></table></figure>

<p>小结：虽然 8 不会出现死链，但是仍然会出现丢失数据等问题。</p>
<h5 id="JDK8-ConcurrentHashMap"><a href="#JDK8-ConcurrentHashMap" class="headerlink" title="JDK8 ConcurrentHashMap"></a>JDK8 ConcurrentHashMap</h5><h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>map 中，数组简称 table，链表简称 bin</p>
<h6 id="为什么线程安全"><a href="#为什么线程安全" class="headerlink" title="为什么线程安全"></a>为什么线程安全</h6><ol>
<li>使用 CAS 初始化 table，保证只有一个线程进行表的创建</li>
<li>no lock when adding to empty bin，使用 CAS 初始化链表头结点</li>
</ol>
<h6 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认为0</span><br><span class="hljs-comment">//当初始化时，为-1</span><br><span class="hljs-comment">//当扩容时，为-（1+扩容线程数）</span><br><span class="hljs-comment">//当初始化或扩容完成后，为下一次的扩容的阈值大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<br><br><span class="hljs-comment">// Node是键值对</span><br><span class="hljs-comment">//整个ConcurrentHashMap就是一个Node[]</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>  <span class="hljs-comment">//成员有键值 hash码以及next</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        <span class="hljs-keyword">volatile</span> V val;<br>        <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;&#125;<br><br><span class="hljs-comment">//hash表</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">//扩容时的新hash表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<br><br><span class="hljs-comment">//扩容时如果bin迁移完毕，用ForwardingNode作为旧table bin的头结点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br> <span class="hljs-comment">//用在compute以及computeIfAbsent时，用来占位，计算完成后转为普通Node</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReservationNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br>    <span class="hljs-comment">//作为treebin的头结点，存储root和first</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br>    <span class="hljs-comment">//作为treebin的结点，存储parent，left，right</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br><br></code></pre></td></tr></table></figure>

<p>当<strong>链表长度超过 8</strong>并且<strong>数组的长度超过 64 后</strong>，将链表转换为红黑树。</p>
<p>当红黑树的结点又小于 6 了，又将红黑树转换回链表。</p>
<h6 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Node[]中第i个Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span> &#123;<br><br>    &#125;<br><br><span class="hljs-comment">//cas修改Node[]中第i个Node的值，c为旧值，v为新值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i,</span><br><span class="hljs-params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;<br><br>    &#125;<br><br><span class="hljs-comment">//直接修改Node[]中第i个Node的值，v为新值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;<br>        U.putObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h6 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                             <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0.0f</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>       <span class="hljs-comment">//保证初始容量有并发度那么大</span><br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="hljs-comment">// Use at least as many bins</span><br>            initialCapacity = concurrencyLevel; <span class="hljs-comment">// as estimated threads</span><br><br>  <span class="hljs-comment">//    计算下一次容量的大小是多少，使用懒加载；在jdk8中独有。</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(<span class="hljs-number">1.0</span> + (<span class="hljs-type">long</span>)initialCapacity / loadFactor);<br><br>  <span class="hljs-comment">//tableSizeFor仍然保证计算的大小是2^n，即16，32，62……。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> (size &gt;= (<span class="hljs-type">long</span>)MAXIMUM_CAPACITY) ?<br>            MAXIMUM_CAPACITY : tableSizeFor((<span class="hljs-type">int</span>)size);<br>        <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>初始容量大小 8，扩容因子 3/4，并发度 16</p>
<ol>
<li>保证初始容量有并发度那么大</li>
<li>计算下一次容量的大小是多少，使用懒加载；在 jdk8 中独有。</li>
<li>初始大小 size 第一次计算</li>
<li>tableSizeFor 仍然保证计算的大小是 2^n，即 16，32，62……。</li>
</ol>
<h6 id="get-流程-无锁"><a href="#get-流程-无锁" class="headerlink" title="get 流程-无锁"></a>get 流程-无锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>     <span class="hljs-comment">// spread方法能确保返回结果是正数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>      <span class="hljs-comment">//table不为null，且length大于0</span><br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>             <span class="hljs-comment">// &amp;运算理解为取模运算，找到桶下标的头结点是不是空</span><br>            (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果头结点已经是要查找的key（hash码一样，key内存地址一样，key的equals一样），那么返回对应的value</span><br>            <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>                <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                    <span class="hljs-keyword">return</span> e.val;<br>            &#125;<br><br>           <span class="hljs-comment">//e头结点的hash为负数表示该bin在扩容中或是treebin</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>              <span class="hljs-comment">// 如果在扩容中，调用forwardingNode的find方法，到新的Table里找结点</span><br>              <span class="hljs-comment">//如果是Treebin，调用TreeNode的find去红黑树里找结点</span><br>                <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br><br>          <span class="hljs-comment">//如果不是要找的key不是头结点，也不是红黑树或者在扩容中，</span><br>          <span class="hljs-comment">// 正常遍历链表，用hash equals和key地址比较</span><br>            <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                    ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                    <span class="hljs-keyword">return</span> e.val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>spread 方法能确保返回结果是正数</li>
<li>table 不为 null，且 length 大于 0</li>
<li>&amp;运算理解为取模运算，找到桶下标的头结点是不是空</li>
<li>如果头结点已经是要查找的 key（hash 码一样，key 内存地址一样，key 的 equals 一样），那么返回对应的 value</li>
<li>hash 为负数表示该 bin 在扩容中或是 treebin</li>
<li>如果在扩容中，调用 forwardingNode 的 find 方法，到新的 Table 里找结点</li>
<li>如果是 Treebin，调用 treebin 的 find 去红黑树里找</li>
<li>如果不是头结点也不是红黑树，正常遍历链表，用 equals 比较</li>
</ol>
<h6 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a>put 流程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>       <span class="hljs-comment">//put带有一个bool类型的参数；如果为true，只有第一次的时候才放入map</span><br>        <span class="hljs-comment">//如果为true的话，不会进行覆盖</span><br>        <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br>    <span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>       <span class="hljs-comment">//普通hashMap允许空的key和空的value；concurrenthashmap不允许</span><br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>     <span class="hljs-comment">// spread保证hash码是正数，负数有特殊用途</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br><br>      <span class="hljs-comment">// binCount是链表或者红黑树的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">//死循环</span><br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>           <span class="hljs-comment">//死循环里，f是链表头结点，fh是链表头结点的hash，i是链表在table中的下标</span><br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>              <span class="hljs-comment">// 懒惰初始化哈希表；使用了cas，保证只有一个线程创建hash表</span><br>                tab = initTable();<br>            <span class="hljs-comment">//如果表中对应位置 没有头结点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//添加链表头使用了cas；如果成功break退出循环；</span><br>              <span class="hljs-comment">// 如果其他线程创建了头结点，那么就退出然后再次循环</span><br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                    <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>            &#125;<br>            <span class="hljs-comment">// forwardingNode的哈希码就是MOVED，表示其他线程正在扩容，</span><br>            <span class="hljs-comment">// 扩容的时候会锁住一个链表进行扩容。帮忙扩容后，进入下一层循环。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>              <span class="hljs-comment">// 帮忙扩容</span><br>                tab = helpTransfer(tab, f);<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//最后一个else，表示table当前没有进行初始化和扩容，并且桶下标冲突了；在这种情况下才要加锁，而且它只对这个桶的链表的头结点加锁。</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>               <span class="hljs-comment">//对链表头上锁</span><br>                <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                  <span class="hljs-comment">//再次确认链表头结点没有被移动</span><br>                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//确认hash&gt;=0是链表。 binCount是bin的长度</span><br>                            binCount = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                                K ek;<br>                                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                    ((ek = e.key) == key ||<br>                                     (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                    oldVal = e.val;<br>                                    <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                        e.val = value;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                                Node&lt;K,V&gt; pred = e;<br>                              <span class="hljs-comment">// 遍历链表，找到相同的key，更新；</span><br>                                <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                    pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                              value, <span class="hljs-literal">null</span>);<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                       <span class="hljs-comment">//如果是红黑树，则往红黑树中添加结点</span><br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                            Node&lt;K,V&gt; p;<br>                            binCount = <span class="hljs-number">2</span>;<br>                            <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                           value)) != <span class="hljs-literal">null</span>) &#123;<br>                                oldVal = p.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    p.val = value;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>               <span class="hljs-comment">//binCount检查是否超过了树化的阈值，如果链表长度 &gt;=8 ，并且table大于64 链表转红黑树</span><br>               <span class="hljs-comment">// 如果链表长度 &gt;=8 ，并且table小于64 则先扩容</span><br>                <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                        treeifyBin(tab, i);<br>                    <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">return</span> oldVal;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//增加size计数，用的类似于LongAdder的累加技术。</span><br>        addCount(<span class="hljs-number">1L</span>, binCount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>put 带有一个 bool 类型的参数；如果为 true，只有第一次的时候才放入 map；</p>
<ol>
<li>普通 hashMap 允许空的 key 和空的 value；concurrenthashmap 不允许</li>
<li>spread 保证 hash 码是正数，负数有特殊用途</li>
<li>死循环里，f 是链表头结点，fh 是链表头结点的 hash，i 是链表在 table 中的下标</li>
<li>懒惰初始化哈希表；使用了 cas，保证只有一个线程创建 hash 表</li>
<li>如果没有头结点</li>
<li>添加链表头使用了 cas；如果成功 break 退出循环；如果其他线程创建了头结点，那么就退出然后再次循环</li>
<li>帮忙扩容</li>
<li>forwardingNode 的哈希码就是 MOVED，表示其他线程正在扩容，扩容的时候会锁住一个链表进行扩容。帮忙扩容后，进入下一层循环。</li>
<li>最后一个 else，表示 table 当前没有初始化和扩容，并且桶下标冲突了；在这种情况下才要加锁，而且它只对这个桶的链表的头结点加锁。</li>
<li>再次确认链表头结点没有被移动</li>
<li>确认 hash&gt;=0 是链表。遍历链表，找到相同的 key，更新；</li>
<li>已经是最后的结点了，新增 Node，追加至链表结尾</li>
<li>如果是红黑树，调用红黑树头结点的方法。</li>
<li>binCount 检查是否超过了树化的阈值，如果链表长度 &gt;=8 ，链表转红黑树</li>
<li>增加 size 计数，用的类似于 LongAdder 的累加技术。</li>
</ol>
<h6 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<p>在 put 中创建 hash 表时提到的方法</p>
<ol>
<li>看下表创建了没，没建的话进入 while</li>
<li>else if 里 用 cas 把它的 sizectl 的值改为-1，表示正在执行初始化 hashTable</li>
<li>如果一个线程成功了，去创建 hash 表，其他线程会进入下层循环，调用 yield 让出 cpu；</li>
<li>双重检查 hash 表的创建，sc 表示要创建的初始容量；使用构造函数给定的值或者默认的值；创建完后，计算出下次要扩容时的阈值</li>
</ol>
<h6 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h6><p>也是 put 方法中的方法，在最后调用。是增加 size 的计数用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<ol>
<li><p>已经有了 counterCells 累加单元数组，向 cell 累加单元累加</p>
</li>
<li><p>还没有，向 baseCount 累加</p>
</li>
<li><p>还没有 counterCells</p>
</li>
<li><p>还没有 cell</p>
</li>
<li><p>cell cas 增加计数失败</p>
</li>
<li><p>创建累加单元数组和 cell，累加重试 fullAddCount</p>
</li>
<li><p>获取元素个数准备判断是否要扩容</p>
</li>
<li><p>需要扩容，这时 newtable 未创建。将 sizectl 用 cas 设置为负数（RESIZE_STAMP_SHIFT</p>
</li>
<li><p>调用 transfer 扩容，因为是第一次扩容，传入 null</p>
</li>
<li><p>其他线程循环进来 如果 sc 小于 0 了，表示 newTable 已经被创建，newtable 已经创建了，帮忙扩容。因为 transfer 第二个参数是 nt，表示帮忙扩容。</p>
</li>
</ol>
<h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p>size 计算实际发生在 put remove 改变集合的操作之中</p>
<ul>
<li>没有竞争发生，向 baseCount 累加计数</li>
<li>有竞争发生，新建 countercells，向其中一个 cell 累加计数<ul>
<li>counterCells 初始有 2 个 cell</li>
<li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<p>将 baseCount 计数与所有 cell 计数累加</p>
<p>但是其得到的只是大概值，不是精确值</p>
<h6 id="transfer-扩容"><a href="#transfer-扩容" class="headerlink" title="transfer 扩容"></a>transfer 扩容</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123; <span class="hljs-comment">//传入两个参数，原始tab和新建的tab；</span><br><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>        <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>            stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br>        <span class="hljs-comment">//  因为是延迟初始化，所以nextTab为null</span><br>        <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>               <span class="hljs-comment">//新建node数组</span><br>                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>                nextTab = nt;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>                sizeCtl = Integer.MAX_VALUE;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            nextTable = nextTab;<br>            transferIndex = n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>        ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br><br>      <span class="hljs-comment">//做结点的搬迁工作，以链表为单位进行移动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>            <span class="hljs-keyword">while</span> (advance) &#123;<br>                <span class="hljs-type">int</span> nextIndex, nextBound;<br>                <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                    advance = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                    i = -<span class="hljs-number">1</span>;<br>                    advance = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                         (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                          nextBound = (nextIndex &gt; stride ?<br>                                       nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                    bound = nextBound;<br>                    i = nextIndex - <span class="hljs-number">1</span>;<br>                    advance = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>                <span class="hljs-type">int</span> sc;<br>                <span class="hljs-keyword">if</span> (finishing) &#123;<br>                    nextTable = <span class="hljs-literal">null</span>;<br>                    table = nextTab;<br>                    sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                        <span class="hljs-keyword">return</span>;<br>                    finishing = advance = <span class="hljs-literal">true</span>;<br>                    i = n; <span class="hljs-comment">// recheck before commit</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果链表头为null，表示处理完了，cas将其替换为fwd即ForwardingNode。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>                advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br>           <span class="hljs-comment">//如果链表头已经为ForwardingNode，进入下轮循环</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>                advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br>            <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//如果链表头有元素，就加锁锁住链表头进行处理。</span><br>                <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                        Node&lt;K,V&gt; ln, hn;<br>                      <span class="hljs-comment">//如果链表头的hash码大于0，表示其是链表。</span><br>                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>                            Node&lt;K,V&gt; lastRun = f;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;<br>                                <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>                                    runBit = b;<br>                                    lastRun = p;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>                                ln = lastRun;<br>                                hn = <span class="hljs-literal">null</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                hn = lastRun;<br>                                ln = <span class="hljs-literal">null</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;<br>                                <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)<br>                                    ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);<br>                                <span class="hljs-type">else</span><br>                                    <span class="hljs-variable">hn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);<br>                            &#125;<br>                            setTabAt(nextTab, i, ln);<br>                            setTabAt(nextTab, i + n, hn);<br>                            setTabAt(tab, i, fwd);<br>                            advance = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                      <span class="hljs-comment">// 如果链表头是tree bin 红黑树</span><br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;<br>                            TreeNode&lt;K,V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                            TreeNode&lt;K,V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;<br>                                TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;<br>                                    (h, e.key, e.val, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;<br>                                    <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-literal">null</span>)<br>                                        lo = p;<br>                                    <span class="hljs-keyword">else</span><br>                                        loTail.next = p;<br>                                    loTail = p;<br>                                    ++lc;<br>                                &#125;<br>                                <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-literal">null</span>)<br>                                        hi = p;<br>                                    <span class="hljs-keyword">else</span><br>                                        hiTail.next = p;<br>                                    hiTail = p;<br>                                    ++hc;<br>                                &#125;<br>                            &#125;<br>                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                                (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;<br>                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                                (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;<br>                            setTabAt(nextTab, i, ln);<br>                            setTabAt(nextTab, i + n, hn);<br>                            setTabAt(tab, i, fwd);<br>                            advance = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>传入两个参数，</p>
<p>原始 tab 和新建的 tab；</p>
<p>因为是延迟初始化，所以 nextTab 为 null</p>
<p>做结点的搬迁工作，以链表为单位进行移动</p>
<p>如果链表头为 null，表示处理完了，将其替换为 fwd 即 ForwardingNode。</p>
<p>如果链表头已经为 ForwardingNode，进入下轮循环</p>
<p>如果链表头有元素，就加锁锁住链表头进行处理。</p>
<p>如果链表头的 hash 码大于 0，表示其是链表。</p>
<p>如果链表头的 hash 码小于 0，表示其是红黑树。</p>
<h5 id="Jdk7-ConcurrentHashMap"><a href="#Jdk7-ConcurrentHashMap" class="headerlink" title="Jdk7 ConcurrentHashMap"></a>Jdk7 ConcurrentHashMap</h5><p>它维护了一个 segment 数组，每个 segment 对应一把锁</p>
<ul>
<li>优点：如果多个线程访问不同的 segment，实际没有冲突，与 jdk8 思想类似</li>
<li>segments 数组默认大小为 16，这个容器初始化指定后就不能改变了，并且<strong>不是懒惰初始化</strong></li>
</ul>
<p>每个 segment 里面对应一个 hashEntry，使用的是<strong>分段式锁</strong>的机制</p>
<p><img src="/img/mac/image-20220402205614794.png" srcset="/img/loading.gif" lazyload alt="image-20220402205614794"></p>
<p>用位与运算将 key 对应到哪个 segment 上。</p>
<p>使用的是 this.segmentShift 和 this.segmentMask，它们的作用是决定将 key 的 hash 结果匹配到哪个 segment。</p>
<p><img src="/img/mac/image-20220402210101028.png" srcset="/img/loading.gif" lazyload alt="image-20220402210101028"></p>
<p><strong>put 流程</strong></p>
<p>j 是 计算出 segment 下标</p>
<p>获得 segment 对象，判断是否为 null，是则创建该 segment</p>
<p>segment 创建使用了 cas</p>
<p>进入 segment 的 put</p>
<p>segment 继承了可重入锁，它的 put 方法</p>
<p>尝试加锁</p>
<p>如果不成功 进入 scanAndLockForPut</p>
<p>如果是多核 cpu，最多 tryLock64 次，进入 lock 流程</p>
<p>在尝试期间，还可以顺便看该结点在链表中有没有，如果没有顺便创建出来</p>
<p>执行到 old value segment 已经成功加锁</p>
<p>更新逻辑</p>
<p>新增逻辑</p>
<p>之前等待锁时，node 已经被创建，next 指向链头</p>
<p>否则创建新 node</p>
<p>扩容 rehash</p>
<p>将 node 作为链表头</p>
<h6 id="rehash-流程"><a href="#rehash-流程" class="headerlink" title="rehash 流程"></a>rehash 流程</h6><p>发生在 put 中，因为已经获得了锁，因此 rehash 不需要考虑线程安全。</p>
<p>先获取旧的容量，容量*2</p>
<p>过一遍链表，尽可能的搬迁链表而不是新建 Node 结点</p>
<p>如果 rehash 后 idx 不变，直接重用</p>
<h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><p>get 时并未加锁，用了 unsafe 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新表取内容。</p>
<h6 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h6><p>遍历所有 segment，只要 segment 不为空，就进行计数</p>
<p>modCount 是最近修改的计数。</p>
<p>如果溢出，统计失败。</p>
<p>如果没溢出，往 size 累加。</p>
<p>last 用于统计上次的修改总和，sum 每次都累加 sumCount</p>
<p>如果循环 3 次都不行，对所有的 segment 加锁，统计。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h4 id="基本的入队出队"><a href="#基本的入队出队" class="headerlink" title="基本的入队出队"></a>基本的入队出队</h4><p>链表结构</p>
<p>结点对象 Node</p>
<p>是单链表。</p>
<p>next 三种情况</p>
<ul>
<li>真正的后继</li>
<li>自己，发生在出队时</li>
<li>null，表示没有后继节点，自己是最后</li>
</ul>
<p>初始化链表 last = head = new Node<E>(null);</p>
<p>Dummy 节点用来占位，item 为 null</p>
<p><img src="/img/mac/image-20220403095448265.png" srcset="/img/loading.gif" lazyload alt="image-20220403095448265"></p>
<p>当一个节点入队</p>
<p>Last = last.next = node;</p>
<p><img src="/img/mac/image-20220403095607289.png" srcset="/img/loading.gif" lazyload alt="image-20220403095607289"></p>
<p>再来一个节点入队</p>
<p><img src="/img/mac/image-20220403095641207.png" srcset="/img/loading.gif" lazyload alt="image-20220403095641207"></p>
<p>出队</p>
<p>h = head</p>
<p>first = h.next</p>
<p>h.next = h</p>
<p><img src="/img/mac/image-20220403095904419.png" srcset="/img/loading.gif" lazyload alt="image-20220403095904419"></p>
<p>head = first</p>
<p><img src="/img/mac/image-20220403095917943.png" srcset="/img/loading.gif" lazyload alt="image-20220403095917943"></p>
<p>E x = first.item;</p>
<p>first.item = null;</p>
<p>return x;</p>
<p><img src="/img/mac/image-20220403100042714.png" srcset="/img/loading.gif" lazyload alt="image-20220403100042714"></p>
<h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>高明之处在于 用了两把锁和 dummyNode</p>
<ul>
<li>用一把锁，同一时刻，最多只允许一个线程（生产者或者消费者，二选一）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程同时执行（锁队头或者队尾）<ul>
<li>消费者与消费者线程仍然串行</li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
</ul>
<p>线程安全分析</p>
<ul>
<li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证 last 节点的线程安全，takeLock 保证 head 节点的线程安全。两把锁保证入队出队没有竞争</li>
<li>当节点总数等于 2（一个 dummy，一个正常节点），仍然是两把锁锁两个对象，这里 dummy 的作用就体现出来了</li>
<li>当节点总数为 1 时，这时 take 线程会被 notEmpty 条件阻塞</li>
</ul>
<h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>不允许空元素</p>
<p>上锁</p>
<p>满了等待（倒过来读：等待不满）</p>
<p>有空位，入队且计数+1</p>
<p>让计数+1，但是 c 是+1 前的值</p>
<p>一次只唤醒一个线程，并且不是让消费者唤醒生产者。</p>
<p>除了自己 put 外，队列还有空位，由生产者自己叫醒其他 put 线程。</p>
<p>如果队列中有一个元素，叫醒 take 线程</p>
<p>唤醒的方法都是 signal</p>
<h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>take 方法类似 put</p>
<h4 id="与-ArrayBlockingQueue"><a href="#与-ArrayBlockingQueue" class="headerlink" title="与 ArrayBlockingQueue"></a>与 ArrayBlockingQueue</h4><ul>
<li>linked 支持有界，Array 强制有界</li>
<li>Linked 实现是链表，Arrays 实现是数组</li>
<li>Linked 是懒惰的，Array 需要提前初始化 Node 数组</li>
<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li>
<li>Linked 两把锁，Array 一把锁</li>
</ul>
<h3 id="ConcurrentlinkedQueue"><a href="#ConcurrentlinkedQueue" class="headerlink" title="ConcurrentlinkedQueue"></a>ConcurrentlinkedQueue</h3><p>与 LinkedBlockingQueue 非常像</p>
<ul>
<li>两把锁，同一时刻可以允许两个线程执行</li>
<li>dummy 节点引入让两把锁将来锁住的是对象，避免竞争</li>
<li>只是这<strong>锁用了 cas</strong>来实现</li>
</ul>
<p><strong>CLQ 应用</strong></p>
<p>在 tomcat 中的 Acceptor 和 Poller 是生产者和消费者。</p>
<p>它们传递信息时，用的就是 CLQ</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArraySet 是它的马甲</p>
<p><strong>写入时拷贝</strong>思想：</p>
<p>增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时<strong>不影响其他线程的并发读</strong>，读写分离。</p>
<p>做到<strong>读-读 读-写并发</strong> 写-写互斥。</p>
<p>以新增为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<p>其他读操作并未加锁，如 foreach</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<p>适合【读多写少】的场景</p>
<p><strong>get 弱一致性问题</strong></p>
<p>Thread 0 仍然是旧数组的引用</p>
<p><img src="/img/mac/image-20220403102902582.png" srcset="/img/loading.gif" lazyload alt="image-20220403102902582"></p>
<p><strong>迭代器弱一致性</strong></p>
<p>做到的是读-写的并发</p>
<p>不要觉得弱一致性就不好</p>
<ul>
<li>数据库的 MVCC 都是弱一致性的表现</li>
<li>并发高和一致性是矛盾的，需要权衡</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/juc/">juc</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/juc/">juc</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/12/JUC-2/">
                        <span class="hidden-mobile">JUC-2</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
