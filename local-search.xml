<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划学习专栏</title>
    <link href="/2022/05/23/dp/"/>
    <url>/2022/05/23/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="核心基础"><a href="#核心基础" class="headerlink" title="核心基础"></a>核心基础</h2><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p>重叠子问题 / 最优子结构 / 状态转移方程</p><h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>对重叠子问题的消除：通过带备忘录的递归，或者是 dp 数组的迭代解法。</p><p>二者的区别是：前者是<strong>自顶向下</strong>得出答案，后者是<strong>自底向上</strong>推出答案。</p><h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><p>对 dp 数组进行压缩，只记录必要的数据，具体例子可以参考背包的一维滚动数组。</p><h2 id="解题五步"><a href="#解题五步" class="headerlink" title="解题五步"></a>解题五步</h2><ul><li>确定 dp 数组及其下标含义</li><li>确定 递推公式</li><li>确定 遍历顺序</li><li>dp 数组的初始化</li><li>推导 dp 数组是否如预期</li></ul><p>在不同的专题中， 我会尽量抽取出他们公共的逻辑放在所有题解的上方。</p><p>关于确定递推公式：</p><p>在明确了 dp 数组及其下标含义的情况下，你要思考的是如何在已知 dp [0…i - 1] 的情况下推出 dp[i] 。</p><p>需要用到数学归纳法的思想。</p><p>如果这一步异常困难，你就需要考虑是否弄错了 dp 数组的含义，需要重新定义 dp 数组；或者是 dp 数组存储的信息不够，需要将 dp 数组扩大为二维、三维……。</p><p>另一种思考方式：</p><ul><li>确定 base case，类似于上面的对 dp 数组初始化。或者说是递归的终点</li><li>确定“状态”，也就是原问题和子问题的变量。</li><li>确定”选择“，也就是导致”状态“发生变化的行为。</li><li>明确 dp 函数/数组的定义</li></ul><p>以 NO 322 零钱兑换（凑零钱）为例</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个函数的含义就是凑成目标金额所需的最少硬币数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> amount;<br>        <span class="hljs-comment">// 对一个或多个&quot;选择&quot;进行遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>            <span class="hljs-comment">// 凑成目标金额所需的最少硬币数,也就是 dp 函数/数组的定义</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">subProblem</span> <span class="hljs-operator">=</span> coinChange(coins,amount - coin);<br>            <span class="hljs-keyword">if</span> (subProblem == -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = Math.min(res,subProblem + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res == amount) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这种解法的时间复杂度为 O(k * 3^n)指数级别，</p><p>用记忆化或说是备忘录来优化掉<strong>重叠子问题</strong>，时间复杂度为 O(kn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] memory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10002</span>];<br>   <span class="hljs-comment">// 这个函数的含义就是凑成目标金额所需的最少硬币数</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>       <span class="hljs-comment">// base case</span><br>       <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (amount &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>       <span class="hljs-comment">//记忆化</span><br>       <span class="hljs-keyword">if</span> (memory[amount] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memory[amount];<br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">10001</span>;<br>       <span class="hljs-comment">// 对一个或多个&quot;选择&quot;进行遍历</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> coin : coins) &#123;<br>           <span class="hljs-comment">// 凑成目标金额所需的最少硬币数,也就是 dp 函数/数组的定义</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">subProblem</span> <span class="hljs-operator">=</span> coinChange(coins,amount - coin);<br>           <span class="hljs-keyword">if</span> (subProblem == -<span class="hljs-number">1</span>) &#123;<br>               <span class="hljs-keyword">continue</span>;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               res = Math.min(res,subProblem + <span class="hljs-number">1</span>);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//记忆化</span><br>       <span class="hljs-keyword">if</span> ((memory[amount] = res) == <span class="hljs-number">10001</span>) &#123;<br>           <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> res;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="背包专题"><a href="#背包专题" class="headerlink" title="背包专题"></a>背包专题</h2><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h4><h2 id="树形-dp"><a href="#树形-dp" class="headerlink" title="树形 dp"></a>树形 dp</h2><table><thead><tr><th align="center">LeetCode</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></td><td align="center">medium</td></tr></tbody></table><p>思路： 树形 dp 不用手动创建 dp 数组，可以在 递归调用栈 中保存对应的 dp ！</p><p>按照解题五步，以及递归的三步来编程即可。</p><p>这里给出 NO337 的题解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] res = rrob(root);<br>        <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>],res[<span class="hljs-number">1</span>]);<br>    &#125;<br><br><br>    <span class="hljs-comment">// dp 0 表示不偷当前节点，dp 1 表示偷当前节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] rrob(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        &#125;<br>          <span class="hljs-comment">//遍历顺序：一定是后序遍历，因为我们需要之前的结果来推导当前结果</span><br>        <span class="hljs-type">int</span>[] left = rrob(root.left);<br>        <span class="hljs-type">int</span>[] right = rrob(root.right);<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 不偷当前节点 表示可以对左右孩子节点大放手脚，挑大的偷</span><br>        dp[<span class="hljs-number">0</span>] = Math.max(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>]) + Math.max(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 偷了当前节点 孩子节点就只能不偷</span><br>        dp[<span class="hljs-number">1</span>] = left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>] + root.val;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="股票专题"><a href="#股票专题" class="headerlink" title="股票专题"></a>股票专题</h2><table><thead><tr><th align="center">LeetCode</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></td><td align="center">easy</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii">122. 买卖股票的最佳时机 II</a></td><td align="center">medium</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></td><td align="center">hard</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></td><td align="center">hard</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></td><td align="center">medium</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></td><td align="center">medium</td></tr></tbody></table><p></p><p>核心思想： dp 下标的含义是当天持有的最大现金。 递推公式根据不同的题目有所变化。遍历顺序在上面几题中是从前往后。初始化在上面几题中只初始化第一天。</p><p>NO 121:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 每天只有 2 个状态</span><br>        <span class="hljs-comment">// dp 是当天持有的最大现金</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 0 是 持股 ， 1是非持股</span><br><br>        <span class="hljs-comment">//初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">// 因为股票只能买入一次 所以 持股的话就是今天买入，或者昨天已经买入</span><br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>],-prices[i]);<br>            <span class="hljs-comment">// 因为股票只能卖出一次，不是昨天已经卖出的话，就是今天卖出</span><br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 122：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>       <span class="hljs-comment">//dp</span><br>        <span class="hljs-comment">//dp[i][0] 表示第i天持有股票的最大现金</span><br>        <span class="hljs-comment">//dp[i][1] 表示第i天不持有股票第最大现金</span><br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 123：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">//最多可以完成两笔交易的股票问题</span><br>        <span class="hljs-comment">// 未买入 也算状态？ 0</span><br>        <span class="hljs-comment">// 状态有第 1 次买入 1，第 1 次卖出 2</span><br>        <span class="hljs-comment">// 第 2 次买入 3， 第 2 次卖出 4</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">5</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">// 已知今天的状态，用正确的逻辑推导出昨天的状态即可</span><br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br><br>            <span class="hljs-comment">// 昨天未买入，今天买入</span><br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">// 昨天已经买入，今天收获利润</span><br>            dp[i][<span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);<br>            dp[i][<span class="hljs-number">3</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            dp[i][<span class="hljs-number">4</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 188：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-comment">// 状态有 0 - 2k</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 0 表示未买入</span><br>        <span class="hljs-comment">// 1 12</span><br>        <span class="hljs-comment">// 2 34</span><br>        <span class="hljs-comment">// 3 56</span><br>        <span class="hljs-comment">// k 2k,2k-1</span><br>        <span class="hljs-comment">//其中单数表示持股 双数表示不持股</span><br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>            dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span> * i - <span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>            dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span> * i] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br>                <span class="hljs-comment">//持股 ： 昨天已经持有，昨天不持股 + 今天买入</span><br>                dp[i][j * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>],dp[i - <span class="hljs-number">1</span>][j * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>] - prices[i]);<br>                <span class="hljs-comment">//卖出： 昨天已经不持股，昨天持股 + 今天卖出</span><br>                dp[i][j * <span class="hljs-number">2</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][j * <span class="hljs-number">2</span>],dp[i - <span class="hljs-number">1</span>][j * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][k * <span class="hljs-number">2</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 309：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br><br>  <span class="hljs-comment">// 将每一天分为 持有股票/两天前就卖出了股票，度过了冷冻期，一直不操作  / 今天卖出了股票 /  今天是冷冻期状态</span><br>    <span class="hljs-comment">// 他们的状态分别为 0  /   1  /  2  / 3</span><br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">4</span>];<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-comment">// 昨天已经持有了股票 或者今天买入，今天买入又分为 状态 1 和 状态 3</span><br>            dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>],Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]) - prices[i]);<br>            <span class="hljs-comment">// 昨天就是这状态，或者昨天是冷冻期</span><br>            dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>            <span class="hljs-comment">// 今天卖股 ， 仅有一种可能：昨天持有了股票</span><br>            dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];<br>            <span class="hljs-comment">// 昨天只有卖出股票的可能</span><br>            dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br><br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> Math.max(Math.max(dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]),dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 714：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第i天持有股票和不持股票的最大现金</span><br>       <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[prices.length][<span class="hljs-number">2</span>];<br><br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>           dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>           dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[prices.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h2 id="子序列求递增-公共的个数专题"><a href="#子序列求递增-公共的个数专题" class="headerlink" title="子序列求递增 / 公共的个数专题"></a>子序列求递增 / 公共的个数专题</h2><table><thead><tr><th align="center">LeetCode</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></td><td align="center">medium</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></td><td align="center">easy</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></td><td align="center">medium</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></td><td align="center">medium</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></td><td align="center">easy</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></td><td align="center">hard</td></tr></tbody></table><p>本系列的子序列题目，要点在于求递推公式。要明确当前状态如何从上一个状态推出。</p><p>对于不要求连续的，要考虑左方和上方。</p><p>NO 300 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// dp i 表示长度为 i 的序列长度的最大子序列的长度</span><br>    <span class="hljs-comment">// 递推公式 ： 如果当前 nums i &gt; nums j (j &lt; i)，那么 dp i = dp[j] + 1</span><br>    <span class="hljs-comment">// dp i 即 0 - j 的dp j 中最大值 + 1</span><br>    <span class="hljs-comment">// 初始化的话 全部初始化为 1</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    Arrays.fill(dp,<span class="hljs-number">1</span>);<br><br><br>    <span class="hljs-comment">//[1,3,6,7,9,4,10,5,6]</span><br>    <span class="hljs-comment">// 1 2 3 4 5 3 6 1 1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 递推公式如下</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                dp[i] = Math.max(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>                res = Math.max(res,dp[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>NO674 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp i 表示长度为 i 的序列的最长连续递增子序列的长度</span><br>        <span class="hljs-comment">// 本题要求的序列是连续的</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>         &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; i++) &#123;<br>            max = Math.max(max,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO718：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLength</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">// dp i j 表示 下标为 i - 1 的 nums1 和 下标为 j - 1 的 nums2 的最长重复子数组的长度</span><br>        <span class="hljs-comment">// 递推公式 ， if nums[i - 1] == nums2[j - 1]，dp[i][j] = dp[i - 1][j - 1] + 1,即从左上方推出。</span><br>        <span class="hljs-comment">// 遍历顺序 没有讲究</span><br>        <span class="hljs-comment">// 初始化 0 应该就可以，这里省略了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums1.length + <span class="hljs-number">1</span>][nums2.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums1.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= nums2.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (dp[i][j] &gt;  res) &#123;<br>                        res = dp[i][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// for (int[] ints : dp) &#123;</span><br>        <span class="hljs-comment">//     for (int anInt : ints) &#123;</span><br>        <span class="hljs-comment">//         System.out.print(anInt + &quot; &quot;);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//     System.out.println();</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO1143：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-comment">// dp i j  表示 最远下标为 i - 1 的 text1 和 最远下标为 j - 1 的 text2 的最长公共子序列</span><br>        <span class="hljs-comment">// 本题与上一题 《最长重复子数组》的区别在于，本题仅要求 相对 公共序列，而不是连续的公共序列</span><br>        <span class="hljs-comment">// 在递推公式上存在区别，就是ext1.charAt(i - 1) != text2.charAt(j - 1)时，</span><br>       <span class="hljs-comment">//                      需要参照的是 dp 的左方和上方，具体意义参照第一行。</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[text1.length() + <span class="hljs-number">1</span>][text2.length() + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= text1.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= text2.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>],dp[i - <span class="hljs-number">1</span>][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[text1.length()][text2.length()];<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO1035 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 本题的含义就是求最长公共非连续的子序列的长度，和上一题解法一模一样。</span><br><span class="hljs-comment">// 暂略，有空补上</span><br></code></pre></td></tr></table></figure><p>NO53：本题是 NO 300 的连续子序列版本，但是求的是其和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>        <span class="hljs-comment">// 连续子序列版本</span><br>        <span class="hljs-comment">// dp i 表示 最远下标为 i 的 nums 数组的最大和</span><br>        <span class="hljs-comment">// dp 递推公式</span><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// dp i 只能从两个方向推出，左边或者自己</span><br>            dp[i] = Math.max(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]);<br>            res = Math.max(res,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 354: 二维 最长递增子序列问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 下面的代码超时了， 需要对 LIS 算法使用 贪心 + 二分 优化为 nlogn</span><br><span class="hljs-comment">//                  当然，这并不是重点</span><br><span class="hljs-comment">//  试图扩展到三维的信封问题，再按照本题的思路来就不行了，需要使用树状数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] envelopes)</span> &#123;<br>        <span class="hljs-comment">// 可以先对一个维度进行从小到大的排序，然后对另一个维度使用 LIS 最长递增子序列算法，算出的结果即是答案。</span><br>        <span class="hljs-comment">// 比如对 w 进行从小到大的排序</span><br>        <span class="hljs-comment">// 如果 w 相等，则对 h 按照从大到小的排序</span><br>        <span class="hljs-comment">// 因为 w 相同的话，一个信封是无法套进另一个信封的</span><br>        Arrays.sort(envelopes,(a,b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])  <span class="hljs-keyword">return</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>        &#125;);<br>        <span class="hljs-type">int</span> h[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[envelopes.length];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; envelopes.length; i++) &#123;<br>            h[i] = envelopes[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> LIS(h);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">LIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// dp i 表示 最远下标为 i 的最长递增子序列长度</span><br><br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br><br>        <span class="hljs-comment">//base case</span><br>        Arrays.fill(dp,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m : dp) &#123;<br>            <span class="hljs-keyword">if</span> (m &gt; res) &#123;<br>                res = m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="子序列之编辑专题"><a href="#子序列之编辑专题" class="headerlink" title="子序列之编辑专题"></a>子序列之编辑专题</h2><table><thead><tr><th align="center">LeetCode</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></td><td align="center">easy</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></td><td align="center">hard</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></td><td align="center">medium</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></td><td align="center">hard</td></tr></tbody></table><p>NO 392 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//以 dp 方式来解的话，有两种思路 这里只给出第一种</span><br><span class="hljs-comment">// 复杂度为 O(n^2)</span><br><span class="hljs-comment">// 一种是 dp[i][j] 表示 长度为 i - 1 的 s 是否为长度为 j - 1 的 t 的子序列</span><br><span class="hljs-comment">// 另一种是 dp[i][j] 表示 长度为 i - 1 的 s 和长度为 j - 1 的 t 的最长相同子序列长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubsequence</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j] 表示 长度为 i - 1 的 s 是否为长度为 j - 1 的 t 的子序列</span><br><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>][t.length() + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">//初始化 空串可以认为是其子序列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= t.length(); i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= s.length(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 递推公式</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= t.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == t.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; dp[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">boolean</span>[] booleans : dp) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">boolean</span> aBoolean : booleans) &#123;<br>                System.out.print(aBoolean);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s.length()][t.length()];<br>    &#125;<br><br><br><br></code></pre></td></tr></table></figure><p>NO 115：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numDistinct</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-comment">// dp i j 表示 长度为 i - 1 的 t 串和长度为 j - 1 的 s 串，t 串在 s 串中出现的次数</span><br>        <span class="hljs-comment">// 也可以理解为 有几种方法删除 s 中部分字符，使其变成 t ==&gt; 本题只能删 s</span><br>        <span class="hljs-comment">// 递推公式 ：</span><br>        <span class="hljs-comment">// 如果 t.charAt(i - 1) == s.charAt(j - 1)，那么 s 串可以考虑匹配，也可以考虑不匹配</span><br>        <span class="hljs-comment">//      可能较难理解，举个例子 t 为 rab ， s 为 rabb ，s可以用 012 或者 013 去和 t 匹配。</span><br>        <span class="hljs-comment">//      s 的维度是 j， 所以 dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];</span><br><br>        <span class="hljs-comment">// 如果 t.charAt(i - 1) != s.charAt(j - 1)， 那么 s 串不提供这次匹配</span><br>        <span class="hljs-comment">//  dp[i][j] = dp[i][j - 1];</span><br><br><br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[t.length() + <span class="hljs-number">1</span>][s.length() + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= t.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= s.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (t.charAt(i - <span class="hljs-number">1</span>) == s.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// for (int[] ints : dp) &#123;</span><br>        <span class="hljs-comment">//     for (int anInt : ints) &#123;</span><br>        <span class="hljs-comment">//         System.out.print(anInt + &quot; &quot;);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//     System.out.println();</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">return</span> dp[t.length()][s.length()];<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 583：</p><p>与上面一题类似，不同的是可以既可以删 s ，又可以删 t</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// dp i j 表示 使长度为 i - 1 的 word1 和长度为 j - 1 的 word2 相等所需要的最小步数</span><br>        <span class="hljs-comment">// 仅可以删除，但是不可以修改</span><br>        <span class="hljs-comment">// 递推公式 == word1(i) word2(j) 相等的话，dp i j 等于 dp i - 1 j - 1</span><br>         <span class="hljs-comment">//             ... ...         不相等的话， dp i j 等于 左边和上边 挑一个小的 + 1</span><br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word2.length(); i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word1.length(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word1.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= word2.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j],dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 72：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// 与上一题不一样的是，这里可以使用增/删/改三种方式来修改单词</span><br>        <span class="hljs-comment">// dp 下标含义是一样的。不再赘述</span><br>        <span class="hljs-comment">// 关键的递推公式</span><br>        <span class="hljs-comment">// 如果 word(i) 和 word(j) 一样，那么从 dp i j 等于左上的值</span><br>        <span class="hljs-comment">// 如果不一样，那么就要把这个不一样的删掉，从左和上挑一个最小的 +1 即可</span><br><br>        <span class="hljs-comment">// 初始化： 按照 dp 下标的含义来初始化即可</span><br><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word1.length(); i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word2.length(); i++) &#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word1.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= word2.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j],Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>],dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints : dp) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt : ints) &#123;<br>                System.out.print(anInt + <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="回文序列"><a href="#回文序列" class="headerlink" title="回文序列"></a>回文序列</h2><table><thead><tr><th align="center">LeetCode</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></td><td align="center">medium</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></td><td align="center">medium</td></tr></tbody></table><p>NO 647 ：回文子串</p><p>这题需要注意的是遍历的顺序，按照递推公式来确定。否则会无从下手，个人认为遍历顺序的确定就是本题的核心。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//  可以回溯爆搜，一个个列出来判断</span><br>        <span class="hljs-comment">// dp ij 表示区间为 [i,j] 的串是否是回文字串</span><br>        <span class="hljs-comment">// 递推公式  如果 s[j] != s[i] 那么 dp i j 为 false</span><br>        <span class="hljs-comment">//          如果 s[j] == s[i] 那么 要分情况</span><br>              <span class="hljs-comment">//      i j 区间的长度小于等于 2 true</span><br>             <span class="hljs-comment">//       i j 区间长度大于 2 ， = dp[j - 1][i + 1]</span><br>        <span class="hljs-comment">// 遍历顺序</span><br>        <span class="hljs-comment">// 根据递推公式得知，本题的状态要从左下方推出，所以遍历顺序是从左下到右上</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-comment">// 区间 j，i</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); j++) &#123;<br><br>                <span class="hljs-comment">// 如果 si == sj</span><br>                <span class="hljs-keyword">if</span> (s.charAt(j) == s.charAt(i)) &#123;<br>                    <span class="hljs-comment">//区间长度 小于等于2 true</span><br>                    <span class="hljs-keyword">if</span> (j - i &lt;= <span class="hljs-number">1</span>) &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                        dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                        res++;<br>                    &#125;<br>            &#125;<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 516：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">// dp i j 表示 区间[i,j] 最长回文子序列的长度</span><br>        <span class="hljs-comment">// 递推公式</span><br>        <span class="hljs-comment">// 如果 si == sj  长度为dp ij = dp[i + 1][j - 1] + 2</span><br>        <span class="hljs-comment">// 如果 si != sj  dp ij = Max(dp[i + 1][j] , dp[i][j - 1]) ==&gt; 从左边或者下边选一个最大的</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 根据递推公式 推出遍历顺序，应该是从下往上，从左往右</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s.length()][s.length()];<br><br>        <span class="hljs-comment">// 根据 dp 数组的含义，将斜线上的数初始化为 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length(); i++) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; s.length(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                   dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j],dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.length() - <span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构，算法</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS 学习专栏</title>
    <link href="/2022/05/23/bfs/"/>
    <url>/2022/05/23/bfs/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><blockquote><p>搞懂了枯燥的本质，再去欣赏美妙的包装，才能胸有成竹。</p></blockquote><h2 id="BFS-常见场景"><a href="#BFS-常见场景" class="headerlink" title="BFS 常见场景"></a>BFS 常见场景</h2><p>问题的本质是让你在一幅“图”中找到从起点 <code>start</code> 到终点 <code>target</code> 的<strong>最短距离</strong>。</p><h2 id="解题框架"><a href="#解题框架" class="headerlink" title="解题框架"></a>解题框架</h2><p>单向 BFS 如下</p><p>双向 BFS 将在下面的实例中介绍</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Node start, Node target)</span> &#123;<br>        Queue&lt;Node&gt; q;<br>        Set&lt;Node&gt; visited; <span class="hljs-comment">//避免走回头路</span><br><br>        q.offer(start);<br>        visited.add(start);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> q.size();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> q.poll();<br>                <span class="hljs-comment">//判断是否到达终点</span><br>                <span class="hljs-keyword">if</span>(cur == target) &#123;<br>                    <span class="hljs-keyword">return</span> step;<br>                &#125;<br>                <span class="hljs-comment">// 将 cur 的相邻结点入队</span><br>                <span class="hljs-keyword">for</span>(Node x : cur.adj()) &#123;<br>                    <span class="hljs-keyword">if</span> (x not in visted) &#123;<br>                        q.offer(x);<br>                        visited.add(x);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 在这里更新步数</span><br>            step++;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="题目实战"><a href="#题目实战" class="headerlink" title="题目实战"></a>题目实战</h2><table><thead><tr><th align="center">LeetCode</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center"><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></td><td align="center">easy</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></td><td align="center">medium</td></tr></tbody></table><p>NO 111:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>  <span class="hljs-comment">//   后面补上的细节，不用太重视</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 第一步 明确 start 和 target</span><br>        <span class="hljs-comment">// start 是 root ， target 是叶子结点</span><br>        <span class="hljs-comment">// 二叉树没有回头路，可以不用 visited 防止死循环</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.offer(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 根结点也算走了一步</span><br><br>        <span class="hljs-comment">//搭出框架</span><br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-comment">// 到达结果了，返回</span><br>                <span class="hljs-keyword">if</span> (poll.left == <span class="hljs-literal">null</span> &amp;&amp; poll.right == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> step;<br>                &#125;<br>                <span class="hljs-comment">//将当前结点的相邻结点加入队列</span><br>                <span class="hljs-keyword">if</span> (poll.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(poll.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (poll.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.offer(poll.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新步数</span><br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br>    &#125;<br></code></pre></td></tr></table></figure><p>NO 752 传统 BFS 解法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先关注核心的 BFS 框架，后面再补充如 deadends 等细节</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> &#123;<br>        <span class="hljs-comment">// 记录走过的路，防止死循环</span><br>        Set&lt;String&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Set&lt;String&gt; deadEnds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 记录 dead ends</span><br>        <span class="hljs-keyword">for</span> (String s : deadends) &#123;<br>            deadEnds.add(s);<br>        &#125;<br>        <span class="hljs-comment">// start</span><br>        queue.offer(<span class="hljs-string">&quot;0000&quot;</span>);<br>        visited.add(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-comment">// 判断是否到了终点</span><br>                <span class="hljs-keyword">if</span> (poll.equals(target)) &#123;<br>                    <span class="hljs-keyword">return</span> step;<br>                &#125;<br>                <span class="hljs-comment">//dead ends ==&gt; 可以直接放入visited，这里就先不优化了</span><br>                <span class="hljs-keyword">if</span> (deadEnds.contains(poll)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//遍历 poll 相邻的结点</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> up(poll, j);<br>                    <span class="hljs-comment">// 没有走过</span><br>                    <span class="hljs-keyword">if</span> (!visited.contains(up)) &#123;<br>                        queue.offer(up);<br>                        visited.add(up);<br>                    &#125;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> down(poll,j);<br>                    <span class="hljs-keyword">if</span> (!visited.contains(down)) &#123;<br>                        queue.offer(down);<br>                        visited.add(down);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 更新路径</span><br>            step ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> step;<br>    &#125;<br><br>    <span class="hljs-comment">// 向上拨</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">up</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-keyword">if</span> (chars[j] == <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            chars[j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            chars[j] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    &#125;<br>    <span class="hljs-comment">// 向下拨</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">down</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-keyword">if</span> (chars[j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            chars[j] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            chars[j] -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构，算法</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/2022/05/23/volatile/"/>
    <url>/2022/05/23/volatile/</url>
    
    <content type="html"><![CDATA[<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><h2 id="作用详解"><a href="#作用详解" class="headerlink" title="作用详解"></a>作用详解</h2><h3 id="防重排序"><a href="#防重排序" class="headerlink" title="防重排序"></a>防重排序</h3><p>以 double-check 单例为例。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数私有，禁止外部实例化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这里的 singleton</span><br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实例化一个对象分为三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ul><p>如果第二步和第三步发生了 <code>指令重排</code>，会导致某个线程得到未初始化完全的对象，导致不可预料的后果。</p><h3 id="实现可见性"><a href="#实现可见性" class="headerlink" title="实现可见性"></a>实现可见性</h3><p>解决由于 CPU Cache ，或者说是线程工作内存引起的可见性问题。</p><p>被 volatile 修饰的变量的写会同步到主存当中。</p><p>被 volatile 修饰的变量的读会从主存当中读取。</p><p>原理是 内存屏障 。</p><h3 id="保证单次读-写的原子性"><a href="#保证单次读-写的原子性" class="headerlink" title="保证单次读/写的原子性"></a>保证单次读/写的原子性</h3><p>这里的单次读/写，是指令级别的。</p><p>举个例子，i++操作实际上是一次读 + 一次写。</p><ul><li>读取 i 的值</li><li>将 i 的值 +1</li><li>将 i 的值写回</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="volatile-的可见性实现"><a href="#volatile-的可见性实现" class="headerlink" title="volatile 的可见性实现"></a>volatile 的可见性实现</h3><ul><li><p>内存屏障，又称内存栅栏，是一个 CPU 指令。</p></li><li><p>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。</p></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="一次安全发布"><a href="#一次安全发布" class="headerlink" title="一次安全发布"></a>一次安全发布</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单例的 double-check</span><br></code></pre></td></tr></table></figure><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><h3 id="独立观察"><a href="#独立观察" class="headerlink" title="独立观察"></a>独立观察</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManager</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> String lastUser;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">authenticate</span><span class="hljs-params">(String user, String password)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> passwordIsValid(user, password);<br>        <span class="hljs-keyword">if</span> (valid) &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            activeUsers.add(u);<br>            lastUser = user;<br>        &#125;<br>        <span class="hljs-keyword">return</span> valid;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Synchronized 关键字</title>
    <link href="/2022/05/18/Synchronized/"/>
    <url>/2022/05/18/Synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h2><p>假设以 obj 对象作为锁</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">synchronized</span>(obj) &#123;<br> <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>obj 对象在同一时间只与一个 monitor(锁)相关联，而一个 monitor 在同一时间只能被一个线程获得。</p><p>任意线程对 obj 的访问，首先要获得 obj 的监视器。如果获取失败，当前线程就进入了 BLOCKED 阻塞状态，即进入了一个同步队列 SynchronizedQueue。当收到 Monitor Exit 通知后，出队列。</p><h2 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h2><p>每个 Monitor 中有一个计数器，如果当前已获得 Monitor 锁的线程再次执行 Monitor Enter 指令，则计数 +1。</p><p>释放锁后，计数 -1。</p><h2 id="JVM-中锁的优化"><a href="#JVM-中锁的优化" class="headerlink" title="JVM 中锁的优化"></a>JVM 中锁的优化</h2><h3 id="Java-中锁的类型"><a href="#Java-中锁的类型" class="headerlink" title="Java 中锁的类型"></a>Java 中锁的类型</h3><p><code>无锁</code> <code>偏向锁</code> <code>轻量级锁</code> <code>重量级锁</code></p><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p><h3 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>线程挂起和恢复需要转入内核态进行操作，这对性能有较大的影响。</p><p>Synchronized 没有获取到锁时，不是马上将当前线程挂起，而是自旋等待锁的释放。</p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>更加灵活的更改自旋的时间。</p><p>如果自旋等待刚刚成功获取过锁，那么 JVM 会认为该锁自旋获取到锁的可能性较大，会自动的增加等待时间。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>虚拟机即时编译器运行时，对一些代码上要求了同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>即使没有线程竞争，频繁的对同一对象反复加锁和解锁也会导致性能降低。</p><p>JVM 会将加锁同步的范围扩展到一系列操作的外部。减少加锁的次数。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在 JDK 1.6 之后引入的轻量级锁，目的是对在大多数情况下同步块并不会有竞争出现提出的一种优化。</p><p>在对象头中(<code>Object Header</code>)存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为 32 位或者 64 位(视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>在线程执行同步块之前，JVM 会在栈帧中创建一个<code> Lock Record</code> 。</p><p>如果 CAS 操作将对象头中的标志位 <code>01</code> 改为 <code>00</code> 成功，<code>Lock Record</code> 会拷贝锁对象目前的 <code>Mark Word</code> ，锁对象的 <code>Mark Word</code> 更新为指向 <code>Lock Record</code> （栈帧）的指针。同时将对象头中的锁标记位改为 <code>00</code> ，表示轻量级锁。</p><p>如果这个 CAS 操作失败了，JVM 会检查对象头中的 <code>Mark Word</code> 是否存在指向当前线程的栈帧的指针，如果存在则说明该锁已经被获取，可以直接调用。如果不存在，说明当前有两个或以上的线程竞争同一把锁，轻量级锁升级为重量级锁，对象头中的 <code>Mark Word</code> 指向重量级锁的指针。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>背景：抹掉 <code>同一个线程</code> 反复获取锁和释放锁带来的性能开销。</p><p>总是偏向第一个获取锁对象的线程。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁。只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p>在 Mark Word 中倒数第三位为标志位 ……101</p>]]></content>
    
    
    <categories>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用 Git 指令</title>
    <link href="/2022/05/09/git-pro/"/>
    <url>/2022/05/09/git-pro/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Git 指令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 在 Windows &amp; Mac 下的快捷键</title>
    <link href="/2022/05/09/idea-properties/"/>
    <url>/2022/05/09/idea-properties/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-下的快捷键"><a href="#Windows-下的快捷键" class="headerlink" title="Windows 下的快捷键"></a>Windows 下的快捷键</h1><ul><li><p>ctrl + N 查找类</p></li><li><p>alt + 7 查看当前类的属性以及方法。</p></li><li><p>ctrl+D 复制粘贴当前行</p></li><li><p>ctrl + / 快速注释</p></li><li><p>ctrl + P 查看括号内的参数</p></li><li><p>ctrl + O 快速重写方法</p></li><li><p>ctrl + R 替换</p></li><li><p>ctrl + H 查找继承结构</p></li><li><p>ctrl + Alt + T 快速生成包围代码块</p></li><li><p>Alt + Shift + ↑ IDEA 上下移动一行</p></li><li><p>ctrl + Y 删除一行</p></li><li><p>ctrl + alt + L 对选中代码进行格式化</p></li><li><p>ctrl + F 查找</p></li><li><p>ctrl + F12 查看当前类的所有方法</p></li><li><p>在注解类中，按 Alt + 7 , 可以查看注解类拥有哪些属性</p></li><li><p>在接口中按 ctrl+shift+T , 可以进行代码的测试 test 工作</p></li></ul><h1 id="Mac-下的快捷键"><a href="#Mac-下的快捷键" class="headerlink" title="Mac 下的快捷键"></a>Mac 下的快捷键</h1>]]></content>
    
    
    <categories>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小小的笔记仓库</title>
    <link href="/2022/03/11/hello-world/"/>
    <url>/2022/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="学习-amp-生活"><a href="#学习-amp-生活" class="headerlink" title="学习 &amp; 生活"></a>学习 &amp; 生活</h2><h3 id="3-11-第一篇-blog"><a href="#3-11-第一篇-blog" class="headerlink" title="3.11 第一篇 blog"></a>3.11 第一篇 blog</h3><p>照着官方文档搭建的小网站，没有什么写文章的想法，先当做自己的笔记仓库~</p><!-- ### 3.12今天学习了 jvm 中类的加载过程，加载-连接（验证、准备、解析）-初始化阶段，以及类加载器，双亲委派机制以及源码；还学习了运行期的优化如即时编译的逃逸分析，解释器和 JIT、方法内联；还有反射优化里的膨胀阈值。简单复习了优先队列（小顶堆和大顶堆）的使用，对应的刷了 LeetCode。### 3.13今天有事耽搁了，只有晚上学了一会。总的来说就是学了 JMM 内存模型。理解了原子性、可见性、有序性的问题产生(JIT 和高速缓存，指令重排)和对应的解决方法(synchronized、volatile)。笼统的看了 CAS 与原子类，简单了解了其实现。了解了 synchronized 在 jdk6 之后的优化，轻量级锁、重量级锁、偏向锁。轻量级锁的锁膨胀，重量级锁自旋，偏向锁的优缺点。JVM 到此就结束了，过几天将笔记整理完毕后会发到 blog 上。明天开始学习 OS。### 3.14&3.153.14 没更，放到今天一起总结。这两天猛攻操作系统，学了操作系统的基本介绍，操作系统分别对程序和硬件"打交道"的方式-中断、系统调用和异常，操作系统如何管理物理内存。管理内存是个大章节，由浅入深的学了地址空间和地址生成（逻辑地址和物理地址），地址的安全检查机制，连续内存分配的三种基本算法，分配后产生的内外碎片的处理机制（压缩式、交换式碎片整理）。 非连续内存管理-分段、分页，操作系统专门生成对应的段表，页表。 基于分页分段的非连续内存管理，又学习了虚拟内存。虚拟内存中，页面的置换又有多种算法。关于页面的置换，局部页面置换学了 FIFO、LRU、CLOCK、基于 CLOCK 的二次机会法、LFU、Belady 现象，这些是在一个进程中进行的，对于全局页面置换算法，深入了解了工作集页置换算法、缺页率页面置换算法、抖动现象。最后给进程管理开了个头，包括进程的定义、组成、特点、PCB。。。具体内容再展开就太多了。LeetCode 这两天复习的是树，树的复习大概会持续一周这样。over -->]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
