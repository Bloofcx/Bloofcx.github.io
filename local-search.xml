<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql-log-mvcc</title>
    <link href="/2022/03/11/mysql-log-mvcc/"/>
    <url>/2022/03/11/mysql-log-mvcc/</url>
    
    <content type="html"><![CDATA[<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>记录事务提交后修改了哪些东西的文件。比如，某个事务将系统表空间中 第 10 号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第 0 号表空间的 10 号页面的偏移量为 100 处的值更新为 2 。</p><h4 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h4><p>保证事务的持久性。如果数据库 dawn 机了，能够进行回滚。</p><h4 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h4><p>redo 分为 redologbuffer 和 redologfile</p><p>具体流程</p><p><img src="/img/image-20220311172604713.png" alt="image-20220311172604713"></p><p>先从磁盘中读取相关数据，进行修改之后将生成一条 redolog 写入 redologbuffer，记录的是数据被修改之后的值。再接着 事务 commit 时，将 redolog 中的内容刷新到 redologfile。最后，定期将内存中修改的数据写入到磁盘。</p><p>流程图：最常见的状态，效率不是很高，但胜在数据稳定。</p><p><img src="/img/image-20220311173118161.png" alt="image-20220311173118161"></p><p>当事务提交的时候进行主动刷盘或者每隔 1s 就写入 pagecache（一块由 os 管理的内存）。</p><h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><h4 id="为什么需要？-1"><a href="#为什么需要？-1" class="headerlink" title="为什么需要？"></a>为什么需要？</h4><p>在上面 redolog 的情况下，如果 os 错误，或者断电也会导致事务执行中存在错误。所以我们要进行 rollback，让事务看起来什么都没做，符合原子性要求。解决事务的原子性问题</p><h4 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h4><p>理解为记录某条记录在被更新之前的状态，通过隐藏段 deletemark 来实现。</p><h4 id="怎么实现？"><a href="#怎么实现？" class="headerlink" title="怎么实现？"></a>怎么实现？</h4><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">begin;<br>insert into user (name) VALUES (&quot;tom&quot;);<br></code></pre></td></tr></table></figure><p>插入后表中的记录是这个样子的：</p><p><img src="/img/image-20220311174310415.png" alt="image-20220311174310415"></p><p>此时 undo no = 0 的情况就是表中原来一条数据都没有的情况；</p><p>接着在这个事务中执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update user set name = &#x27;Mary&#x27; where id = 1;<br></code></pre></td></tr></table></figure><p>这时候 undo no = 1 的情况就是表中只有一条记录且名字为 Tom 的情况，因为只修改了列信息。</p><p><img src="/img/image-20220311175105213.png" alt="image-20220311175105213"></p><p>再接着</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update user set id = 2 where id = 1;<br></code></pre></td></tr></table></figure><p>我们的主键列发生了改变，这里的第一个改变是将原来的 deletemark 改为 1，第二个改变是 id=2 的数据插入表中，所以图是这样的：</p><p><img src="/img/image-20220311175137731.png" alt="image-20220311175137731"></p><p>综上，我们再接着在这个事务中执行 rollback，就会这样回滚：</p><ol><li><p>通过 undo no=3 的日志把 id=2 的数据删除</p></li><li><p>通过 undo no=2 的日志把 id=1 的数据的 deletemark 还原成 0</p></li><li><p>通过 undo no=1 的日志把 id=1 的数据的 name 还原成 Tom</p></li><li><p>通过 undo no=0 的日志把 id=1 的数据删除</p></li></ol><p>这里的 undolog 分为两类。一类是 insert undolog 只对事务本身可见，所以事务提交后可以删除。</p><p>update undolog 可能还要交给 MVCC 使用，所以在提交时放入 undolog 链表，等待 purge 线程进行最后的删除。</p><h4 id="小结日志流程图"><a href="#小结日志流程图" class="headerlink" title="小结日志流程图"></a>小结日志流程图</h4><p><img src="/img/image-20220311175456975.png" alt="image-20220311175456975"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2022/03/11/hello-world/"/>
    <url>/2022/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>先简单做个自我介绍吧，我是双非大三科班的在读生，目前奋斗在 java 后端的路上~<br>第一页没啥好放的，就放些最近放松时玩的游戏吧。<br>目前暂定每三天就写一点东西，复习一下之前学过的高频知识点。<br>实在是太容易忘了 - -</p><h2 id="简单的小爱好-gt-lt"><a href="#简单的小爱好-gt-lt" class="headerlink" title="简单的小爱好&gt;&lt;"></a>简单的小爱好&gt;&lt;</h2><h3 id="3-11-EldenRing"><a href="#3-11-EldenRing" class="headerlink" title="3.11 EldenRing"></a>3.11 EldenRing</h3><p>从发售开始玩到现在还热情满满的游戏，可以说是我心中最好的游戏之一了。<br><img src="/img/20220310233622_1.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
