<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JUC-3</title>
    <link href="/2022/04/12/JUC-3/"/>
    <url>/2022/04/12/JUC-3/</url>
    
    <content type="html"><![CDATA[<div class="code-wrapper"><pre><code class="hljs">读写锁</code></pre></div><h3 id="ReentrantReadWriterLock"><a href="#ReentrantReadWriterLock" class="headerlink" title="ReentrantReadWriterLock"></a>ReentrantReadWriterLock</h3><p><strong>基本介绍</strong></p><p>支持可重入的读写锁。</p><p>当读操作远远高于写操作时，这时候使用<strong>读写锁</strong>让<strong>读-读</strong>可以并发，提高性能。</p><p>类似于数据库中的 select … from … lock in share mode</p><p><strong>基本使用</strong></p><p>提供一个<strong>数据容器类</strong>内部分别使用读锁保护数据的 read（）方法，写锁保护数据的 write（）方法</p><p>n8/TestReadWriteLock.java</p><p>测试读写锁</p><p>读-读 不互斥/可并发</p><p>读-写 互斥</p><p>写-写 互斥</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读-写</span><br><span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>        <span class="hljs-type">DataContainer</span> <span class="hljs-variable">container</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainer</span>();<br>        container.setData(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        pool.execute(()-&gt;&#123;<br>            lock.readLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Sleeper.sleep(<span class="hljs-number">2</span>);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,container.getData());<br><br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.readLock().unlock();<br>            &#125;<br>        &#125;);<br><br>        pool.execute(()-&gt;&#123;<br>            lock.writeLock().lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;write begin&quot;</span>);<br>                container.setData(<span class="hljs-number">2</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.writeLock().unlock();<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>读锁不支持条件变量</li><li>重入时升级不支持：有读锁的情况再获取写锁，会导致写锁永久等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">r.lock();<br><br><span class="hljs-keyword">try</span>&#123;<br>   w.lock();<br>   <span class="hljs-keyword">try</span>&#123;<br><br>   &#125;<span class="hljs-keyword">finally</span>&#123;<br>    w.unlock();<br>   &#125;<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br> r.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重入时降级支持：即持有写锁的情况下去获取读锁</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">锁的降级：<br><span class="hljs-built_in">writeLock</span>()<span class="hljs-selector-class">.lock</span>();<br>rw1<span class="hljs-selector-class">.readLock</span>()<span class="hljs-selector-class">.lock</span>();<br><span class="hljs-built_in">wirteLock</span>()<span class="hljs-selector-class">.unlock</span>();<br>rw1<span class="hljs-selector-class">.readLock</span>()<span class="hljs-selector-class">.unlock</span>();<br></code></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>读写锁用的是同一个 sync 同步器，因此等待队列，state 等也是同一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Sync sync;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantReadWriteLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>        sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>        readerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadLock</span>(<span class="hljs-built_in">this</span>);<br>        writerLock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteLock</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><p><strong>以 t1 线程上写锁，t2 线程上读锁为例</strong></p><p>t1 成功上锁，流程与 reentrantlock 加锁相比没有特殊之处，不同的是写锁状态占 state 的低 16 位，而读锁使用的是 state 的高 16 位。</p><p>先看加写锁 t1.w.lock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">//写锁的lock方法</span><br>          <span class="hljs-comment">//进入acquire</span><br>           sync.acquire(<span class="hljs-number">1</span>);<br>       &#125;<br></code></pre></td></tr></table></figure><p>进入 tryAcquire 查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//进入try Acquire</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><p>c==0，见图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>         <span class="hljs-comment">// state 写锁状态占state的低16位，而读锁使用的是state的高16位。</span><br>          <span class="hljs-comment">//此时c为0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-comment">//w==0 表示没人加写锁</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>           <span class="hljs-comment">//c！=0的情况分两种有可能是读有可能是写</span><br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br>                <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               <span class="hljs-comment">//重入过多，抛异常</span><br>                <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                <span class="hljs-comment">// Reentrant acquire</span><br>                setState(c + acquires);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>           <span class="hljs-comment">//本次逻辑会走到这，writeShouldBlock固定返回false</span><br>           <span class="hljs-comment">// 将state用cas方式改为c+1</span><br>            <span class="hljs-keyword">if</span> (writerShouldBlock() ||<br>                !compareAndSetState(c, c + acquires))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//cas修改成功，设置当前线程为owner。</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-comment">//return true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401163718211.png" alt="image-20220401163718211"></p><p>t2 执行 r.lock ， 此时进入读锁的 acquireShared(1)流程，<strong>首先会进入 tryAcquire</strong>流程，如果有写锁占据，那么 tryAcquireShared 返回-1 表示失败</p><p>tryAcquireShared 返回值表示</p><ul><li>-1 表示失败</li><li>0 表示成功，但后继节会继续唤醒</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒</li><li>读写锁只会返回 1，更大的数值返回会在信号量中使用到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//读锁的lock方法</span><br>       <span class="hljs-comment">// 进入acquireShared</span><br>            sync.acquireShared(<span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">//进入tryAcquireShared</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireShared(arg);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>           <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>           <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>              <span class="hljs-comment">//先看写锁部分是否不为0（true） &amp;&amp; 再看加写锁的是不是自己（false）</span><br>           <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>               getExclusiveOwnerThread() != current)<br>             <span class="hljs-comment">//返回-1</span><br>               <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>           <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>               r &lt; MAX_COUNT &amp;&amp;<br>               compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>               <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                   firstReader = current;<br>                   firstReaderHoldCount = <span class="hljs-number">1</span>;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                   firstReaderHoldCount++;<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>                   <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                       cachedHoldCounter = rh = readHolds.get();<br>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                       readHolds.set(rh);<br>                   rh.count++;<br>               &#125;<br>               <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>       &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401165050221.png" alt="image-20220401165050221"></p><p>又进入了 doAcquireShared 流程</p><p>加共享（shared)的节点类型，此时 node（t2）仍然处于活跃状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">//tryAcquireShared由于加了写锁，且写锁不是自己加的，所以返回-1</span><br>      <span class="hljs-comment">//进入doAcquireShared</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireShared(arg);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//在队列中生成head头节点和shared类型的当前线程节点</span><br>       <span class="hljs-comment">//将前驱节点的状态值改为-1</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">//if 自己是老二</span><br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                   <span class="hljs-comment">//再尝试获取锁</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                   <span class="hljs-comment">//获取锁成功的，等会再看</span><br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-comment">// 进入这，两次循环后陷入阻塞。在reentrantlock那块很详细的看过了，不再赘述</span><br>              <span class="hljs-comment">/*</span><br><span class="hljs-comment">              与reentrant lock不同的是，多循环了一次来获取锁；以及node的状态是shared而不是exclusive</span><br><span class="hljs-comment">              */</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401165153041.png" alt="image-20220401165153041"></p><p><img src="/img/mac/image-20220401165451087.png" alt="image-20220401165451087"></p><p><strong>在上面的情况下，假设又有 t3 加读锁，t4 加写锁</strong></p><p>此时 t1 仍持有锁，注意状态的不同</p><p><img src="/img/mac/image-20220401165722258.png" alt="image-20220401165722258"></p><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><p><strong>t1.w.unlock</strong></p><p>sync.release==》try Release</p><p>ownerthread 置为 null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//写锁的unlock 进入release</span><br>            sync.release(<span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">// 进入try Release</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>           <span class="hljs-comment">//如果持有锁的不是当前线程 抛异常</span><br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>           <span class="hljs-comment">//nextc = 当前状态 - 1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> getState() - releases;<br><br>           <span class="hljs-comment">// 如果减为0了</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> exclusiveCount(nextc) == <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (free)<br>               <span class="hljs-comment">//将当前owner设为null</span><br>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(nextc);<br>            <span class="hljs-comment">// 返回true</span><br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br></code></pre></td></tr></table></figure><p>进入唤醒流程 unparkSuccessor，让老二 t2 恢复运行，在 parkAndCheck Interrupt 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>      <span class="hljs-comment">// try Release返回true</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>           <span class="hljs-comment">// 进入唤醒流程unparkSuccessor</span><br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 这里的node 是 头节点head</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>       <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>           compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>      <span class="hljs-comment">//s为下一个节点</span><br>       <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>           s = <span class="hljs-literal">null</span>;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>               <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                   s = t;<br>       &#125;<br>       <span class="hljs-comment">//唤醒下一个节点 老二</span><br>       <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>           LockSupport.unpark(s.thread);<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401170148894.png" alt="image-20220401170148894"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>             <span class="hljs-comment">//再次进入循环</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                   <span class="hljs-comment">//进入tryAcquireShared 返回了r=1</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                    <span class="hljs-comment">//这次能进入if语句块</span><br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-comment">//进入</span><br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            selfInterrupt();<br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>                 <span class="hljs-comment">//老二在parkAndCheck处被唤醒</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>              <span class="hljs-comment">//c = 0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br><br>           <span class="hljs-comment">//写锁为0</span><br>            <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>                getExclusiveOwnerThread() != current)<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//读锁为0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>            <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>                r &lt; MAX_COUNT &amp;&amp;<br>                <span class="hljs-comment">//前两个条件都成立</span><br>                  <span class="hljs-comment">// cas方式让读锁+1，</span><br>                compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>                <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>                    firstReader = current;<br>                    firstReaderHoldCount = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>                    firstReaderHoldCount++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>                    <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                        cachedHoldCounter = rh = readHolds.get();<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                        readHolds.set(rh);<br>                    rh.count++;<br>                &#125;<br>              <span class="hljs-comment">//return 1读锁加锁成功</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>        &#125;<br></code></pre></td></tr></table></figure><p>进入 setHeadAndPropagate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br><br>  <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>  <span class="hljs-comment">// 将当前线程节点设为head ， 也就是t2</span><br>  setHead(node);<br><br>  <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>      (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>      <span class="hljs-comment">//s是t2的后继节点，如果是共享类型，进入doReleaseShared</span><br>      <span class="hljs-comment">//本例中是这样的 ， t2和t3都上了读锁，是共享类型节点，所以进入</span><br>      doReleaseShared();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401170628648.png" alt="image-20220401170628648"></p><p>进入 do ReleaseShared</p><p>将头节点的状态从-1 改为 0，假设成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-comment">// head此时为t2</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>               <span class="hljs-comment">// head节点的状态值确实为-1</span><br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                   <span class="hljs-comment">//将头节点的状态从-1改为0，假设其修改成功；修改失败就继续循环了</span><br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                  <span class="hljs-comment">//再把头节点的后继节点唤醒，也就是t3</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401171550582.png" alt="image-20220401171550582"></p><p>t3 会再走一遍刚才的逻辑，</p><p>但是不会再次进入 do ReleaseShared</p><p>因为它的下一个节点 t4 不是共享（shared）类型</p><p><img src="/img/mac/image-20220401171559173.png" alt="image-20220401171559173"></p><p>可以看到，这就是读-读并发的原理，它会一连串的把 share 的结点唤醒</p><p><strong>t2.r.unlock , t3.r.unlock</strong></p><p>tryReleaseShared</p><p>进入 doReleaseShared，</p><p>将头节点状态改为 0，然后将 t4 唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-comment">//读锁的unlock</span><br>            sync.releaseShared(<span class="hljs-number">1</span>);<br>        &#125;<br><br> <span class="hljs-comment">// aqs的模板方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//进入try Release Shared</span><br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接看最后for循环这块了</span><br><span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>              <span class="hljs-comment">// 把状态减1，然后cas尝试</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - SHARED_UNIT;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                  <span class="hljs-comment">//返回它是否为0，t2的那块返回false，t3的返回true</span><br>                    <span class="hljs-type">return</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>            &#125;<br></code></pre></td></tr></table></figure><p>以 t3 为例，进入 do ReleaseShared</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// aqs的模板方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//try Release Shared 返回true</span><br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        <span class="hljs-comment">// 进入此方法</span><br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-comment">// head此时为t3</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>               <span class="hljs-comment">// head节点的状态值确实为-1</span><br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                   <span class="hljs-comment">//将头节点的状态从-1改为0，假设其修改成功；修改失败就继续循环了</span><br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                  <span class="hljs-comment">//再把头节点的后继节点唤醒，也就是t4</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401172327918.png" alt="image-20220401172327918"></p><p>t4 从 acquireQueued 醒来，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 将t4变成头节点。</span><br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401172459504.png" alt="image-20220401172459504"></p><h3 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="应用之缓存"></a>应用之缓存</h3><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>缓存可以使用《先更新数据库，再删除缓存，同时给缓存增加时间》</p><ul><li>写策略</li></ul><ol><li>将数据更新到数据库</li><li>删除缓存</li></ol><ul><li>读策略</li></ul><ol><li>如果缓存命中，返回</li><li>如果没有，查询数据库，返回</li><li>写入缓存</li></ol><p>因为缓存的写入要远远快于数据库的更新，所以很少发生数据一致性</p><p>在进一步，可以使用消息队列重试或者订阅 binlog</p><p>先清缓存还是先更新数据库</p><p>图中打上三个感叹号的地方就是<strong>数据不一致</strong>。</p><ul><li>如果先清缓存，再查询数据库。</li></ul><p><img src="/img/mac/image-20220401161242601.png" alt="image-20220401161242601"></p><ul><li>如果先更新数据库，也会产生不一致</li></ul><p><img src="/img/mac/image-20220401161407148.png" alt="image-20220401161407148"></p><p>解决方式：加锁</p><p>写操作加写锁，读操作加读锁。</p><p>写操作 包括修改数据库，将数据放入缓存。</p><p>读操作包括读取缓存。</p><ul><li>缓存适合读取操作远远多于写操作的场景</li><li>没有考虑缓存容量</li><li>没有考虑缓存过期</li><li>只适合单机，不适合分布式</li><li>并发性还是低，目前只会用一把锁；可以<strong>针对不同的表设计不同的锁</strong></li><li>更新方法太过简单粗暴，清空了所有的 key（考虑按类型分区，或者重新设计 key）</li></ul><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>jdk8 加入，进一步优化读性能，特点是<strong>使用读、写锁时都配合【戳】使用</strong></p><p>加解读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock(stamp);<br></code></pre></td></tr></table></figure><p>加解写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">lock</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><p>乐观读，读取完毕后需要做一次戳校验，如果校验通过，表示这期间没有写操作，数据可以安全使用；如果校验没通过，需要重新获取读锁，保证数据安全。</p><p>乐观读是没有加锁操作的，提高性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-type">long</span>　<span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br>　<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br><span class="hljs-comment">//锁升级 - 读锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.testStampLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStampLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            dataContainer.read(<span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            dataContainer.write(<span class="hljs-number">2</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainerStamped</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> readTime)</span> &#123;<br>        <span class="hljs-comment">//乐观读</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br>        log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);<br>        Sleeper.sleep(readTime);<br>        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>        <span class="hljs-comment">// 锁升级 - 读锁</span><br>        log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            stamp = lock.readLock();<br>            log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);<br>            Sleeper.sleep(readTime);<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockRead(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> newData)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>        log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">this</span>.data = newData;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>stampedlock 不支持条件变量</li><li>stampedlock 不支持可重入</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上限。</p><p>可以有多个共享资源。</p><p><strong>一个比喻</strong></p><p>停车场车位：共享资源。</p><p>车辆：线程。</p><p>信号量：剩余车位数。</p><p>当信号量为 0 时，就不能再进来了。</p><p><strong>使用</strong></p><p>许可 permits 表示允许同时访问的线程数。</p><p>公平 fair 表示先来的先获得。</p><p>acquire 表示获得许可 permits，获得后许可数-1。</p><p>release 表示释放许可，也放在 finally 块中。</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            pool.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    log.debug(<span class="hljs-string">&quot;start ... &quot;</span>);<br>                    Sleeper.sleep(<span class="hljs-number">2</span>);<br>                    log.debug(<span class="hljs-string">&quot;end ... &quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        pool.shutdown();<br></code></pre></td></tr></table></figure><p><strong>应用</strong></p><ul><li>使用其<strong>限流</strong>，让请求线程阻塞，高峰期过去再释放许可。当然它只适合限制单机线程数量，并且<strong>仅是限制线程数</strong>，而<strong>不是资源数（</strong>例如连接数，对比 Tomcat LimitLatch）</li><li>用 Semaphore 实现简单连接池，对比【享元模式】下的实现数据库连接池（用 wait notify），可以用 semaphore 改进</li></ul><p>// 组合一个 semaphore</p><p>//让许可数与资源数一致</p><p>//让没有许可的线程去等待，代替了 wait notify</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//while (true)&#123;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capcity; i++) &#123;<br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;获得连接&quot;</span>);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br><span class="hljs-comment">//            synchronized (this)&#123;</span><br><span class="hljs-comment">//                try &#123;</span><br><span class="hljs-comment">//                    log.debug(&quot;未获得连接，进入等待&quot;);</span><br><span class="hljs-comment">//                    this.wait();</span><br><span class="hljs-comment">//                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                    e.printStackTrace();</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br>       <span class="hljs-comment">// &#125;</span><br>        log.debug(<span class="hljs-string">&quot; can I ?&quot;</span>);<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 6 归还连接方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Connection connection)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capcity; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connection  == connections[i])&#123;<br>                states.set(i,<span class="hljs-number">0</span>);<br><span class="hljs-comment">//                synchronized (this)&#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                    this.notifyAll();</span><br><span class="hljs-comment">//                &#125;</span><br>                semaphore.release();<br>                log.debug(<span class="hljs-string">&quot;归还连接&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4><p>构造方法</p><p>permit 的参数，其实就传给了 AQS 的 state</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> permits) &#123;<br>            setState(permits);<br>        &#125;<br></code></pre></td></tr></table></figure><p>假设 permits 为 3，这时 5 个线程来争抢资源</p><p>假设其中线程 1，2，4 竞争成功，而线程 0，3 竞争失败，进入 AQS 阻塞队列 park 阻塞。</p><p><strong>以线程 1 为例，加锁成功</strong></p><p>acquire 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>acquire shared interruptibly 方法,传入参数为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-comment">// into here</span><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            doAcquireSharedInterruptibly(arg);<br>    &#125;<br></code></pre></td></tr></table></figure><p>try acquire shared 返回值是剩余的资源数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>                <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>                    compareAndSetState(available, remaining))<br>                     <span class="hljs-comment">//返回值是剩余的资源数</span><br>                    <span class="hljs-keyword">return</span> remaining;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>以线程 0 为例，加锁失败</strong></p><p>acquire 方法</p><p>acquire shared interruptibly 方法</p><p>try acquire shared 返回值是剩余的资源数</p><p>doAcquireShared Interruptibly 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br><br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>          <span class="hljs-comment">// into here</span><br>            doAcquireSharedInterruptibly(arg);<br>    &#125;<br><br><br><br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-comment">//给阻塞队列创建节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head) &#123;<br>                    <span class="hljs-comment">//再次尝试获取</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                    <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                        setHeadAndPropagate(node, r);<br>                        p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                        failed = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-comment">//循环</span><br>               <span class="hljs-comment">//然后park住</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>给阻塞队列创建节点</p><p>再次尝试获取</p><p>循环</p><p>然后 park 住</p><p><img src="/img/mac/image-20220401214307061.png" alt="image-20220401214307061"></p><h4 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4><p>realease</p><p>releaseShared</p><p>tryRelease Shared</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            doReleaseShared();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>               <span class="hljs-comment">// 拿到0 因为许可都用完了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-comment">// 释放1个许可</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>                <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>               <span class="hljs-comment">//cas将0改为1，返回true</span><br>                <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br><br></code></pre></td></tr></table></figure><p>进入 doReleaseShared 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>                <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                   <span class="hljs-comment">// 将头节点状态状态cas改为0</span><br>                    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                        <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                  <span class="hljs-comment">//unparkSuccessor 唤醒下一个节点</span><br>                    unparkSuccessor(h);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                         !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>以共享节点的方式连续唤醒，是一连串的，类似读写锁的读-读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>        setHead(node);<br>        <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>            (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-comment">//以共享节点的方式连续唤醒</span><br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>                doReleaseShared();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220401214953952.png" alt="image-20220401214953952"></p><p>但是只有一个线程释放了许可，state 仍旧是 0，</p><p>thread3 尝试不成功再次进入阻塞</p><p><img src="/img/mac/image-20220401215002290.png" alt="image-20220401215002290"></p><h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p>倒计时锁。</p><p>用来进行线程同步协作，等待所有线程完成倒计时。</p><p>构造参数用来初始化等待计数值，</p><p>await 用来等待计数归零，</p><p>countDown 用来让计数减一</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>tryAcquireShared</p><p>try ReleaseShared</p><p>非常简单的逻辑</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>主线程使用 await 3，表示等待三个计数归零</p><p>开三个线程用来让计数-1</p><p>用线程池来做</p><p>能否用 join 替代 countdownlatch？</p><p>因为固定大小线程池的线程一直运行等待任务，所以 join 等不到它们结束。</p><p>建议还是用这种高级的 api 代替低级的 join api</p><h3 id="应用之同步等待多线程准备完毕"><a href="#应用之同步等待多线程准备完毕" class="headerlink" title="应用之同步等待多线程准备完毕"></a>应用之同步等待多线程准备完毕</h3><p>用线程池开 10 个线程</p><p>模拟 10 个玩家加载游戏</p><p>用 for 循环模拟加载，用 string 字符串来模拟玩家的加载过程，用随机睡眠时间打印每位玩家的加载进度。用 不换行+“\r”回车符 让后面的内容覆盖前面的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>) ;<br>        String[] strs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j;<br>            pool.execute(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(random.nextInt(<span class="hljs-number">200</span>));<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    strs[k] = i+<span class="hljs-string">&quot;% &quot;</span>;<br>                    System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(strs));<br>                &#125;<br>                latch.countDown();<br>            &#125;);<br>        &#125;<br><br><br>       latch.await();<br>        System.out.println(<span class="hljs-string">&quot;\n game begin&quot;</span>);<br>        pool.shutdown();<br></code></pre></td></tr></table></figure><h3 id="应用之同步等待多个远程调用结束"><a href="#应用之同步等待多个远程调用结束" class="headerlink" title="应用之同步等待多个远程调用结束"></a>应用之同步等待多个远程调用结束</h3><p>n8/testCountdownLatch.java</p><p>用 rest Template 调用不同的微服务，每个微服务都要不同的执行时间，串行处理的效率就非常低。</p><p>用线程池 + countdownLatch 进行改造：</p><p>分为多个线程进行处理</p><h2 id="future-应用"><a href="#future-应用" class="headerlink" title="future 应用"></a>future 应用</h2><p>在应用之同步等待多个远程调用结束中，每个任务的<strong>处理结果</strong>都是<strong>在各自的线程中</strong>。</p><p>我们需要<strong>用 future 在主线程中汇总。</strong></p><h2 id="Cyclicbarrier"><a href="#Cyclicbarrier" class="headerlink" title="Cyclicbarrier"></a>Cyclicbarrier</h2><p>countDownLatch 不能被重用，每循环一次，就得重新创建</p><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。</p><p><strong>构造方法</strong></p><p>构造时设置计数个数，每个线程执行到需要“同步“的时刻调用 await 方法进行等待，当等待的线程满足计数个数时，继续执行。</p><p>第二个参数，是一个 runnable，是当等待数为 0 时执行的线程</p><p>与 countDown Latch 不同的是，它的计数到 0 后依旧可以重用。</p><p>await 表示当前线程在此阻塞，并且等待值-1。等待值为 0 后方可继续运行。</p><p>与 countDown Latch 不同的是，它的计数到 0 后依旧可以重用。</p><p>它的数值到 0 后，再调用 await，还是可以继续使用。</p><p><strong>注意</strong></p><p><strong>构造方法里的等待值，要和线程池里的线程数一致</strong>，否则会出现问题。</p><h1 id="八、线程安全集合类概述"><a href="#八、线程安全集合类概述" class="headerlink" title="八、线程安全集合类概述"></a>八、线程安全集合类概述</h1><h2 id="遗留的线程安全集合类"><a href="#遗留的线程安全集合类" class="headerlink" title="遗留的线程安全集合类"></a>遗留的线程安全集合类</h2><h3 id="hashTable"><a href="#hashTable" class="headerlink" title="hashTable"></a>hashTable</h3><p>直接在方法上加 synchronized 的 HashMap，性能低</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>类似。</p><h2 id="修饰的线程安全集合类"><a href="#修饰的线程安全集合类" class="headerlink" title="修饰的线程安全集合类"></a>修饰的线程安全集合类</h2><p>采用了装饰器模式</p><p>将线程不安全的集合，修饰为线程安全的集合。</p><p><strong>原理</strong></p><p>在调用集合对应的所有方法里，都加上了一个<strong>synchronized</strong>，性能一样没有提升。</p><h2 id="JUC-安全集合"><a href="#JUC-安全集合" class="headerlink" title="JUC 安全集合"></a>JUC 安全集合</h2><p>分为 Blocking 、 CopyOnWrite 、 Concurrent 三大类</p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法。很多方法不满足条件时就要等待。</li><li>CopyOnWrite 之类容器修改开销相对较重。适用于读多写少的场景</li><li>Concurrent 类型容器<ul><li>内部使用很多 cas 优化，一般可以提供较高吞吐量</li><li><strong>弱一致性</strong><ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，<strong>迭代器仍然可以继续遍历</strong>，这时<strong>内容是旧的</strong>，fali-safe 机制</li><li>求大小弱一致性，<strong>size 操作未必是 100%准确</strong></li><li>读取弱一致性</li></ul></li></ul></li></ul><p>遍历时如果发生了修改，对于非安全容器来讲，使用<strong>fail-fast 机制也就是让遍历立刻失败</strong>，抛出 Concurrent Modification Exception，不在继续遍历</p><h3 id="ConcurrnetHashMap"><a href="#ConcurrnetHashMap" class="headerlink" title="ConcurrnetHashMap"></a>ConcurrnetHashMap</h3><p><strong>练习 单词计数</strong></p><p>N8/TestWordCount</p><p>为什么用 ConcurrentHashMap 还是有问题？</p><p>因为只是单个方法是线程安全的，但是方法的组合不是线程安全的。</p><p>解决方法 1:</p><p>上 synchronized</p><p>解决方法 2：</p><p>分析：因为 get 和 put 不是原子的。 只要这三个操作是原子的，就没有问题了，</p><p>用 concurrenthashmap 的 computeIfAbsent 方法</p><p>如果缺少一个 key，则计算生成一个值，然后将 key value 放入 map。</p><p>累加操作使用 longAdder 来保证</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>先看 hashmap，看看 hash map 有哪些线程不安全的地方</p><h5 id="1-7-的-hash-map-的死链"><a href="#1-7-的-hash-map-的死链" class="headerlink" title="1.7 的 hash map 的死链"></a><strong>1.7 的 hash map 的死链</strong></h5><p>哈希表是用拉链法，就是哈希冲突时用的是链表。</p><p>1.7 中，<strong>后插入的数据放在链表头部</strong>，死链的必要条件</p><p>1.8 中，后插入的数据放在链表尾部</p><ul><li>扩容：当数组超过 3/4 时，会将数组扩容为原来的 2 倍。并且会重新计算桶下标。</li><li>并发死链：在多线程的情况下，如果进行扩容，会产生并发死链问题。</li></ul><p>并发死链测试</p><p>test/testDeadLink.java</p><p>长度达到 12 的时候扩容 3/4.</p><p>在 transfer 590 行处加个断点</p><p>并且添加断点条件，让 Thread 0 和 1 在扩容时停下。</p><p>随后让 Thread1 执行完整个扩容。</p><p>再看 Thread-0，断点打在 594 行。他的 e 和 next 引用还是没有变，仍旧是 1 和 35。</p><p>但是 Thread-1 已经更改了引用里面的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> 由<br> e  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">35</span>-&gt;<span class="hljs-number">16</span>-&gt;<span class="hljs-literal">null</span><br> next  <span class="hljs-number">35</span>-&gt;<span class="hljs-number">16</span>-&gt;<span class="hljs-literal">null</span><br><br> 变为<br>e  <span class="hljs-number">1</span>-&gt;<span class="hljs-literal">null</span><br>next <span class="hljs-number">35</span>-&gt;<span class="hljs-number">1</span><br><br> 再循环一次<br>   把e放入链表，next变成了e<br>   下一个e变成了<span class="hljs-number">35</span><br>   但是<span class="hljs-number">35</span>又链着<span class="hljs-number">1</span><br>   链表变成<br>   <span class="hljs-number">1</span>-&gt;<span class="hljs-number">35</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-literal">null</span><br>   再循环一次<br>   死链就会形成<br></code></pre></td></tr></table></figure><p>小结：虽然 8 不会出现死链，但是仍然会出现丢失数据等问题。</p><h5 id="JDK8-ConcurrentHashMap"><a href="#JDK8-ConcurrentHashMap" class="headerlink" title="JDK8 ConcurrentHashMap"></a>JDK8 ConcurrentHashMap</h5><h6 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h6><p>map 中，数组简称 table，链表简称 bin</p><h6 id="为什么线程安全"><a href="#为什么线程安全" class="headerlink" title="为什么线程安全"></a>为什么线程安全</h6><ol><li>使用 CAS 初始化 table，保证只有一个线程进行表的创建</li><li>no lock when adding to empty bin，使用 CAS 初始化链表头结点</li></ol><h6 id="重要属性和内部类"><a href="#重要属性和内部类" class="headerlink" title="重要属性和内部类"></a>重要属性和内部类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认为0</span><br><span class="hljs-comment">//当初始化时，为-1</span><br><span class="hljs-comment">//当扩容时，为-（1+扩容线程数）</span><br><span class="hljs-comment">//当初始化或扩容完成后，为下一次的扩容的阈值大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<br><br><span class="hljs-comment">// Node是键值对</span><br><span class="hljs-comment">//整个ConcurrentHashMap就是一个Node[]</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>  <span class="hljs-comment">//成员有键值 hash码以及next</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        <span class="hljs-keyword">volatile</span> V val;<br>        <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;&#125;<br><br><span class="hljs-comment">//hash表</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">//扩容时的新hash表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<br><br><span class="hljs-comment">//扩容时如果bin迁移完毕，用ForwardingNode作为旧table bin的头结点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br> <span class="hljs-comment">//用在compute以及computeIfAbsent时，用来占位，计算完成后转为普通Node</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReservationNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br>    <span class="hljs-comment">//作为treebin的头结点，存储root和first</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br>    <span class="hljs-comment">//作为treebin的结点，存储parent，left，right</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;<br><br><br></code></pre></td></tr></table></figure><p>当<strong>链表长度超过 8</strong>并且<strong>数组的长度超过 64 后</strong>，将链表转换为红黑树。</p><p>当红黑树的结点又小于 6 了，又将红黑树转换回链表。</p><h6 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Node[]中第i个Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span> &#123;<br><br>    &#125;<br><br><span class="hljs-comment">//cas修改Node[]中第i个Node的值，c为旧值，v为新值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i,</span><br><span class="hljs-params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;<br><br>    &#125;<br><br><span class="hljs-comment">//直接修改Node[]中第i个Node的值，v为新值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;<br>        U.putObjectVolatile(tab, ((<span class="hljs-type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="构造器分析"><a href="#构造器分析" class="headerlink" title="构造器分析"></a>构造器分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                             <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0.0f</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>       <span class="hljs-comment">//保证初始容量有并发度那么大</span><br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="hljs-comment">// Use at least as many bins</span><br>            initialCapacity = concurrencyLevel; <span class="hljs-comment">// as estimated threads</span><br><br>  <span class="hljs-comment">//    计算下一次容量的大小是多少，使用懒加载；在jdk8中独有。</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(<span class="hljs-number">1.0</span> + (<span class="hljs-type">long</span>)initialCapacity / loadFactor);<br><br>  <span class="hljs-comment">//tableSizeFor仍然保证计算的大小是2^n，即16，32，62……。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> (size &gt;= (<span class="hljs-type">long</span>)MAXIMUM_CAPACITY) ?<br>            MAXIMUM_CAPACITY : tableSizeFor((<span class="hljs-type">int</span>)size);<br>        <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>    &#125;<br></code></pre></td></tr></table></figure><p>初始容量大小 8，扩容因子 3/4，并发度 16</p><ol><li>保证初始容量有并发度那么大</li><li>计算下一次容量的大小是多少，使用懒加载；在 jdk8 中独有。</li><li>初始大小 size 第一次计算</li><li>tableSizeFor 仍然保证计算的大小是 2^n，即 16，32，62……。</li></ol><h6 id="get-流程-无锁"><a href="#get-流程-无锁" class="headerlink" title="get 流程-无锁"></a>get 流程-无锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-type">int</span> n, eh; K ek;<br>     <span class="hljs-comment">// spread方法能确保返回结果是正数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br>      <span class="hljs-comment">//table不为null，且length大于0</span><br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>             <span class="hljs-comment">// &amp;运算理解为取模运算，找到桶下标的头结点是不是空</span><br>            (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果头结点已经是要查找的key（hash码一样，key内存地址一样，key的equals一样），那么返回对应的value</span><br>            <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;<br>                <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))<br>                    <span class="hljs-keyword">return</span> e.val;<br>            &#125;<br><br>           <span class="hljs-comment">//e头结点的hash为负数表示该bin在扩容中或是treebin</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)<br>              <span class="hljs-comment">// 如果在扩容中，调用forwardingNode的find方法，到新的Table里找结点</span><br>              <span class="hljs-comment">//如果是Treebin，调用TreeNode的find去红黑树里找结点</span><br>                <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-literal">null</span> ? p.val : <span class="hljs-literal">null</span>;<br><br>          <span class="hljs-comment">//如果不是要找的key不是头结点，也不是红黑树或者在扩容中，</span><br>          <span class="hljs-comment">// 正常遍历链表，用hash equals和key地址比较</span><br>            <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;<br>                    ((ek = e.key) == key || (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek))))<br>                    <span class="hljs-keyword">return</span> e.val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>spread 方法能确保返回结果是正数</li><li>table 不为 null，且 length 大于 0</li><li>&amp;运算理解为取模运算，找到桶下标的头结点是不是空</li><li>如果头结点已经是要查找的 key（hash 码一样，key 内存地址一样，key 的 equals 一样），那么返回对应的 value</li><li>hash 为负数表示该 bin 在扩容中或是 treebin</li><li>如果在扩容中，调用 forwardingNode 的 find 方法，到新的 Table 里找结点</li><li>如果是 Treebin，调用 treebin 的 find 去红黑树里找</li><li>如果不是头结点也不是红黑树，正常遍历链表，用 equals 比较</li></ol><h6 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a>put 流程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>       <span class="hljs-comment">//put带有一个bool类型的参数；如果为true，只有第一次的时候才放入map</span><br>        <span class="hljs-comment">//如果为true的话，不会进行覆盖</span><br>        <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Implementation for put and putIfAbsent */</span><br>    <span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>       <span class="hljs-comment">//普通hashMap允许空的key和空的value；concurrenthashmap不允许</span><br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>     <span class="hljs-comment">// spread保证hash码是正数，负数有特殊用途</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> spread(key.hashCode());<br><br>      <span class="hljs-comment">// binCount是链表或者红黑树的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">//死循环</span><br>        <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;<br>           <span class="hljs-comment">//死循环里，f是链表头结点，fh是链表头结点的hash，i是链表在table中的下标</span><br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> n, i, fh;<br>            <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>              <span class="hljs-comment">// 懒惰初始化哈希表；使用了cas，保证只有一个线程创建hash表</span><br>                tab = initTable();<br>            <span class="hljs-comment">//如果表中对应位置 没有头结点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//添加链表头使用了cas；如果成功break退出循环；</span><br>              <span class="hljs-comment">// 如果其他线程创建了头结点，那么就退出然后再次循环</span><br>                <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>)))<br>                    <span class="hljs-keyword">break</span>;                   <span class="hljs-comment">// no lock when adding to empty bin</span><br>            &#125;<br>            <span class="hljs-comment">// forwardingNode的哈希码就是MOVED，表示其他线程正在扩容，</span><br>            <span class="hljs-comment">// 扩容的时候会锁住一个链表进行扩容。帮忙扩容后，进入下一层循环。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>              <span class="hljs-comment">// 帮忙扩容</span><br>                tab = helpTransfer(tab, f);<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//最后一个else，表示table当前没有进行初始化和扩容，并且桶下标冲突了；在这种情况下才要加锁，而且它只对这个桶的链表的头结点加锁。</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldVal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>               <span class="hljs-comment">//对链表头上锁</span><br>                <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                  <span class="hljs-comment">//再次确认链表头结点没有被移动</span><br>                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//确认hash&gt;=0是链表。 binCount是bin的长度</span><br>                            binCount = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;<br>                                K ek;<br>                                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                                    ((ek = e.key) == key ||<br>                                     (ek != <span class="hljs-literal">null</span> &amp;&amp; key.equals(ek)))) &#123;<br>                                    oldVal = e.val;<br>                                    <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                        e.val = value;<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                                Node&lt;K,V&gt; pred = e;<br>                              <span class="hljs-comment">// 遍历链表，找到相同的key，更新；</span><br>                                <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-literal">null</span>) &#123;<br>                                    pred.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(hash, key,<br>                                                              value, <span class="hljs-literal">null</span>);<br>                                    <span class="hljs-keyword">break</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                       <span class="hljs-comment">//如果是红黑树，则往红黑树中添加结点</span><br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                            Node&lt;K,V&gt; p;<br>                            binCount = <span class="hljs-number">2</span>;<br>                            <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                                           value)) != <span class="hljs-literal">null</span>) &#123;<br>                                oldVal = p.val;<br>                                <span class="hljs-keyword">if</span> (!onlyIfAbsent)<br>                                    p.val = value;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>               <span class="hljs-comment">//binCount检查是否超过了树化的阈值，如果链表长度 &gt;=8 ，并且table大于64 链表转红黑树</span><br>               <span class="hljs-comment">// 如果链表长度 &gt;=8 ，并且table小于64 则先扩容</span><br>                <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)<br>                        treeifyBin(tab, i);<br>                    <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">return</span> oldVal;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//增加size计数，用的类似于LongAdder的累加技术。</span><br>        addCount(<span class="hljs-number">1L</span>, binCount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>put 带有一个 bool 类型的参数；如果为 true，只有第一次的时候才放入 map；</p><ol><li>普通 hashMap 允许空的 key 和空的 value；concurrenthashmap 不允许</li><li>spread 保证 hash 码是正数，负数有特殊用途</li><li>死循环里，f 是链表头结点，fh 是链表头结点的 hash，i 是链表在 table 中的下标</li><li>懒惰初始化哈希表；使用了 cas，保证只有一个线程创建 hash 表</li><li>如果没有头结点</li><li>添加链表头使用了 cas；如果成功 break 退出循环；如果其他线程创建了头结点，那么就退出然后再次循环</li><li>帮忙扩容</li><li>forwardingNode 的哈希码就是 MOVED，表示其他线程正在扩容，扩容的时候会锁住一个链表进行扩容。帮忙扩容后，进入下一层循环。</li><li>最后一个 else，表示 table 当前没有初始化和扩容，并且桶下标冲突了；在这种情况下才要加锁，而且它只对这个桶的链表的头结点加锁。</li><li>再次确认链表头结点没有被移动</li><li>确认 hash&gt;=0 是链表。遍历链表，找到相同的 key，更新；</li><li>已经是最后的结点了，新增 Node，追加至链表结尾</li><li>如果是红黑树，调用红黑树头结点的方法。</li><li>binCount 检查是否超过了树化的阈值，如果链表长度 &gt;=8 ，链表转红黑树</li><li>增加 size 计数，用的类似于 LongAdder 的累加技术。</li></ol><h6 id="initTable"><a href="#initTable" class="headerlink" title="initTable"></a>initTable</h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>在 put 中创建 hash 表时提到的方法</p><ol><li>看下表创建了没，没建的话进入 while</li><li>else if 里 用 cas 把它的 sizectl 的值改为-1，表示正在执行初始化 hashTable</li><li>如果一个线程成功了，去创建 hash 表，其他线程会进入下层循环，调用 yield 让出 cpu；</li><li>双重检查 hash 表的创建，sc 表示要创建的初始容量；使用构造函数给定的值或者默认的值；创建完后，计算出下次要扩容时的阈值</li></ol><h6 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h6><p>也是 put 方法中的方法，在最后调用。是增加 size 的计数用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><ol><li><p>已经有了 counterCells 累加单元数组，向 cell 累加单元累加</p></li><li><p>还没有，向 baseCount 累加</p></li><li><p>还没有 counterCells</p></li><li><p>还没有 cell</p></li><li><p>cell cas 增加计数失败</p></li><li><p>创建累加单元数组和 cell，累加重试 fullAddCount</p></li><li><p>获取元素个数准备判断是否要扩容</p></li><li><p>需要扩容，这时 newtable 未创建。将 sizectl 用 cas 设置为负数（RESIZE_STAMP_SHIFT</p></li><li><p>调用 transfer 扩容，因为是第一次扩容，传入 null</p></li><li><p>其他线程循环进来 如果 sc 小于 0 了，表示 newTable 已经被创建，newtable 已经创建了，帮忙扩容。因为 transfer 第二个参数是 nt，表示帮忙扩容。</p></li></ol><h6 id="size"><a href="#size" class="headerlink" title="size"></a>size</h6><p>size 计算实际发生在 put remove 改变集合的操作之中</p><ul><li>没有竞争发生，向 baseCount 累加计数</li><li>有竞争发生，新建 countercells，向其中一个 cell 累加计数<ul><li>counterCells 初始有 2 个 cell</li><li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p>将 baseCount 计数与所有 cell 计数累加</p><p>但是其得到的只是大概值，不是精确值</p><h6 id="transfer-扩容"><a href="#transfer-扩容" class="headerlink" title="transfer 扩容"></a>transfer 扩容</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123; <span class="hljs-comment">//传入两个参数，原始tab和新建的tab；</span><br><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>        <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)<br>            stride = MIN_TRANSFER_STRIDE; <span class="hljs-comment">// subdivide range</span><br>        <span class="hljs-comment">//  因为是延迟初始化，所以nextTab为null</span><br>        <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// initiating</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>               <span class="hljs-comment">//新建node数组</span><br>                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>                nextTab = nt;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;      <span class="hljs-comment">// try to cope with OOME</span><br>                sizeCtl = Integer.MAX_VALUE;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            nextTable = nextTab;<br>            transferIndex = n;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>        ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// to ensure sweep before committing nextTab</span><br><br>      <span class="hljs-comment">//做结点的搬迁工作，以链表为单位进行移动</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>            Node&lt;K,V&gt; f; <span class="hljs-type">int</span> fh;<br>            <span class="hljs-keyword">while</span> (advance) &#123;<br>                <span class="hljs-type">int</span> nextIndex, nextBound;<br>                <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing)<br>                    advance = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                    i = -<span class="hljs-number">1</span>;<br>                    advance = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt<br>                         (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                          nextBound = (nextIndex &gt; stride ?<br>                                       nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                    bound = nextBound;<br>                    i = nextIndex - <span class="hljs-number">1</span>;<br>                    advance = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>                <span class="hljs-type">int</span> sc;<br>                <span class="hljs-keyword">if</span> (finishing) &#123;<br>                    nextTable = <span class="hljs-literal">null</span>;<br>                    table = nextTab;<br>                    sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> ((sc - <span class="hljs-number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)<br>                        <span class="hljs-keyword">return</span>;<br>                    finishing = advance = <span class="hljs-literal">true</span>;<br>                    i = n; <span class="hljs-comment">// recheck before commit</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果链表头为null，表示处理完了，cas将其替换为fwd即ForwardingNode。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>)<br>                advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br>           <span class="hljs-comment">//如果链表头已经为ForwardingNode，进入下轮循环</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)<br>                advance = <span class="hljs-literal">true</span>; <span class="hljs-comment">// already processed</span><br>            <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//如果链表头有元素，就加锁锁住链表头进行处理。</span><br>                <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                    <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                        Node&lt;K,V&gt; ln, hn;<br>                      <span class="hljs-comment">//如果链表头的hash码大于0，表示其是链表。</span><br>                        <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>                            Node&lt;K,V&gt; lastRun = f;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;<br>                                <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>                                    runBit = b;<br>                                    lastRun = p;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>                                ln = lastRun;<br>                                hn = <span class="hljs-literal">null</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                hn = lastRun;<br>                                ln = <span class="hljs-literal">null</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;<br>                                <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)<br>                                    ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);<br>                                <span class="hljs-type">else</span><br>                                    <span class="hljs-variable">hn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);<br>                            &#125;<br>                            setTabAt(nextTab, i, ln);<br>                            setTabAt(nextTab, i + n, hn);<br>                            setTabAt(tab, i, fwd);<br>                            advance = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                      <span class="hljs-comment">// 如果链表头是tree bin 红黑树</span><br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;<br>                            TreeNode&lt;K,V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                            TreeNode&lt;K,V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>                            <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>                                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;<br>                                TreeNode&lt;K,V&gt; p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt;<br>                                    (h, e.key, e.val, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>                                <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;<br>                                    <span class="hljs-keyword">if</span> ((p.prev = loTail) == <span class="hljs-literal">null</span>)<br>                                        lo = p;<br>                                    <span class="hljs-keyword">else</span><br>                                        loTail.next = p;<br>                                    loTail = p;<br>                                    ++lc;<br>                                &#125;<br>                                <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-keyword">if</span> ((p.prev = hiTail) == <span class="hljs-literal">null</span>)<br>                                        hi = p;<br>                                    <span class="hljs-keyword">else</span><br>                                        hiTail.next = p;<br>                                    hiTail = p;<br>                                    ++hc;<br>                                &#125;<br>                            &#125;<br>                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                                (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;<br>                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                                (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;<br>                            setTabAt(nextTab, i, ln);<br>                            setTabAt(nextTab, i + n, hn);<br>                            setTabAt(tab, i, fwd);<br>                            advance = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>传入两个参数，</p><p>原始 tab 和新建的 tab；</p><p>因为是延迟初始化，所以 nextTab 为 null</p><p>做结点的搬迁工作，以链表为单位进行移动</p><p>如果链表头为 null，表示处理完了，将其替换为 fwd 即 ForwardingNode。</p><p>如果链表头已经为 ForwardingNode，进入下轮循环</p><p>如果链表头有元素，就加锁锁住链表头进行处理。</p><p>如果链表头的 hash 码大于 0，表示其是链表。</p><p>如果链表头的 hash 码小于 0，表示其是红黑树。</p><h5 id="Jdk7-ConcurrentHashMap"><a href="#Jdk7-ConcurrentHashMap" class="headerlink" title="Jdk7 ConcurrentHashMap"></a>Jdk7 ConcurrentHashMap</h5><p>它维护了一个 segment 数组，每个 segment 对应一把锁</p><ul><li>优点：如果多个线程访问不同的 segment，实际没有冲突，与 jdk8 思想类似</li><li>segments 数组默认大小为 16，这个容器初始化指定后就不能改变了，并且<strong>不是懒惰初始化</strong></li></ul><p>每个 segment 里面对应一个 hashEntry，使用的是<strong>分段式锁</strong>的机制</p><p><img src="/img/mac/image-20220402205614794.png" alt="image-20220402205614794"></p><p>用位与运算将 key 对应到哪个 segment 上。</p><p>使用的是 this.segmentShift 和 this.segmentMask，它们的作用是决定将 key 的 hash 结果匹配到哪个 segment。</p><p><img src="/img/mac/image-20220402210101028.png" alt="image-20220402210101028"></p><p><strong>put 流程</strong></p><p>j 是 计算出 segment 下标</p><p>获得 segment 对象，判断是否为 null，是则创建该 segment</p><p>segment 创建使用了 cas</p><p>进入 segment 的 put</p><p>segment 继承了可重入锁，它的 put 方法</p><p>尝试加锁</p><p>如果不成功 进入 scanAndLockForPut</p><p>如果是多核 cpu，最多 tryLock64 次，进入 lock 流程</p><p>在尝试期间，还可以顺便看该结点在链表中有没有，如果没有顺便创建出来</p><p>执行到 old value segment 已经成功加锁</p><p>更新逻辑</p><p>新增逻辑</p><p>之前等待锁时，node 已经被创建，next 指向链头</p><p>否则创建新 node</p><p>扩容 rehash</p><p>将 node 作为链表头</p><h6 id="rehash-流程"><a href="#rehash-流程" class="headerlink" title="rehash 流程"></a>rehash 流程</h6><p>发生在 put 中，因为已经获得了锁，因此 rehash 不需要考虑线程安全。</p><p>先获取旧的容量，容量*2</p><p>过一遍链表，尽可能的搬迁链表而不是新建 Node 结点</p><p>如果 rehash 后 idx 不变，直接重用</p><h6 id="get"><a href="#get" class="headerlink" title="get"></a>get</h6><p>get 时并未加锁，用了 unsafe 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新表取内容。</p><h6 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h6><p>遍历所有 segment，只要 segment 不为空，就进行计数</p><p>modCount 是最近修改的计数。</p><p>如果溢出，统计失败。</p><p>如果没溢出，往 size 累加。</p><p>last 用于统计上次的修改总和，sum 每次都累加 sumCount</p><p>如果循环 3 次都不行，对所有的 segment 加锁，统计。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><h4 id="基本的入队出队"><a href="#基本的入队出队" class="headerlink" title="基本的入队出队"></a>基本的入队出队</h4><p>链表结构</p><p>结点对象 Node</p><p>是单链表。</p><p>next 三种情况</p><ul><li>真正的后继</li><li>自己，发生在出队时</li><li>null，表示没有后继节点，自己是最后</li></ul><p>初始化链表 last = head = new Node<E>(null);</p><p>Dummy 节点用来占位，item 为 null</p><p><img src="/img/mac/image-20220403095448265.png" alt="image-20220403095448265"></p><p>当一个节点入队</p><p>Last = last.next = node;</p><p><img src="/img/mac/image-20220403095607289.png" alt="image-20220403095607289"></p><p>再来一个节点入队</p><p><img src="/img/mac/image-20220403095641207.png" alt="image-20220403095641207"></p><p>出队</p><p>h = head</p><p>first = h.next</p><p>h.next = h</p><p><img src="/img/mac/image-20220403095904419.png" alt="image-20220403095904419"></p><p>head = first</p><p><img src="/img/mac/image-20220403095917943.png" alt="image-20220403095917943"></p><p>E x = first.item;</p><p>first.item = null;</p><p>return x;</p><p><img src="/img/mac/image-20220403100042714.png" alt="image-20220403100042714"></p><h4 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h4><p>高明之处在于 用了两把锁和 dummyNode</p><ul><li>用一把锁，同一时刻，最多只允许一个线程（生产者或者消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时执行（锁队头或者队尾）<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析</p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证 last 节点的线程安全，takeLock 保证 head 节点的线程安全。两把锁保证入队出队没有竞争</li><li>当节点总数等于 2（一个 dummy，一个正常节点），仍然是两把锁锁两个对象，这里 dummy 的作用就体现出来了</li><li>当节点总数为 1 时，这时 take 线程会被 notEmpty 条件阻塞</li></ul><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>不允许空元素</p><p>上锁</p><p>满了等待（倒过来读：等待不满）</p><p>有空位，入队且计数+1</p><p>让计数+1，但是 c 是+1 前的值</p><p>一次只唤醒一个线程，并且不是让消费者唤醒生产者。</p><p>除了自己 put 外，队列还有空位，由生产者自己叫醒其他 put 线程。</p><p>如果队列中有一个元素，叫醒 take 线程</p><p>唤醒的方法都是 signal</p><h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>take 方法类似 put</p><h4 id="与-ArrayBlockingQueue"><a href="#与-ArrayBlockingQueue" class="headerlink" title="与 ArrayBlockingQueue"></a>与 ArrayBlockingQueue</h4><ul><li>linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Arrays 实现是数组</li><li>Linked 是懒惰的，Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><h3 id="ConcurrentlinkedQueue"><a href="#ConcurrentlinkedQueue" class="headerlink" title="ConcurrentlinkedQueue"></a>ConcurrentlinkedQueue</h3><p>与 LinkedBlockingQueue 非常像</p><ul><li>两把锁，同一时刻可以允许两个线程执行</li><li>dummy 节点引入让两把锁将来锁住的是对象，避免竞争</li><li>只是这<strong>锁用了 cas</strong>来实现</li></ul><p><strong>CLQ 应用</strong></p><p>在 tomcat 中的 Acceptor 和 Poller 是生产者和消费者。</p><p>它们传递信息时，用的就是 CLQ</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArraySet 是它的马甲</p><p><strong>写入时拷贝</strong>思想：</p><p>增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时<strong>不影响其他线程的并发读</strong>，读写分离。</p><p>做到<strong>读-读 读-写并发</strong> 写-写互斥。</p><p>以新增为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p>其他读操作并未加锁，如 foreach</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p>适合【读多写少】的场景</p><p><strong>get 弱一致性问题</strong></p><p>Thread 0 仍然是旧数组的引用</p><p><img src="/img/mac/image-20220403102902582.png" alt="image-20220403102902582"></p><p><strong>迭代器弱一致性</strong></p><p>做到的是读-写的并发</p><p>不要觉得弱一致性就不好</p><ul><li>数据库的 MVCC 都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul>]]></content>
    
    
    <categories>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-2</title>
    <link href="/2022/04/12/JUC-2/"/>
    <url>/2022/04/12/JUC-2/</url>
    
    <content type="html"><![CDATA[<h1 id="六、-共享模型之不可变"><a href="#六、-共享模型之不可变" class="headerlink" title="六、 共享模型之不可变"></a>六、 共享模型之不可变</h1><h2 id="可变类：日期转换"><a href="#可变类：日期转换" class="headerlink" title="可变类：日期转换"></a>可变类：日期转换</h2><p>N7/test1.java</p><p>simpledateformat 不是线程安全的。</p><p>可变类不加线程安全的保护，使用起来就有问题。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> format.parse(<span class="hljs-string">&quot;2020-05-26&quot;</span>);<br>                    System.out.println(date.toString());<br>                &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>            &#125;).start();<br></code></pre></td></tr></table></figure><h2 id="不可变对象-使用"><a href="#不可变对象-使用" class="headerlink" title="不可变对象-使用"></a>不可变对象-使用</h2><p>DateTimeFormatter 类</p><p>它的源码里有这么一段描述</p><p><strong>This class is immutable and Thread-safe</strong></p><p>说明他是不可变的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><br>                    <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>                    <span class="hljs-type">TemporalAccessor</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> formatter.parse(<span class="hljs-string">&quot;2020-05-25&quot;</span>);<br>                    System.out.println(parse.toString());<br><br><br>            &#125;).start();<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="不可变类的设计"><a href="#不可变类的设计" class="headerlink" title="不可变类的设计"></a>不可变类的设计</h2><h3 id="靠谱的实例"><a href="#靠谱的实例" class="headerlink" title="靠谱的实例"></a>靠谱的实例</h3><p>String 类也是<strong>不可变的</strong>，它是如何保证的？</p><p>以它为例，说明一下不可变设计的要素。</p><h3 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h3><ul><li>属性用 final 修饰<strong>保证了该属性是只读的，不能修改</strong></li><li>类用 final 修饰<strong>保证了该类中的方法不能被覆盖</strong>，防止子类无意间破坏</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类上加final，防止子类继承，破坏它的不可变</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String implements ...&#123;<br><br><span class="hljs-comment">//final修饰</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] value;<br><br><span class="hljs-comment">//没有set方法或构造方法；外界没有机会改变它</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>看一个构造方法：</p><p>通过复制新数组的方式，让自己的 value 引用永远是独一份，不会被外界所拥有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span> value[])</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = Arrays.copyOf(value, value.length);<br>    &#125;<br></code></pre></td></tr></table></figure><p>subString 方法：</p><p>并没有改动原来的字符串对象，而是创建了一个新的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-built_in">this</span><br>                : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br></code></pre></td></tr></table></figure><p><strong>这种通过创建副本对象来<u>避免共享</u>的手段成为保护性拷贝</strong>;</p><p>这里我们可能会想到这不是很浪费空间吗？但是 String 底层有串池的支持，这也是接下来享元模式的一种体现。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>每次保护性拷贝都要大量的创建对象。</p><p>当需要<strong>重用数量有限的同一类对象</strong>时，就可以用到享元模式。</p><p>尽可能的对相同的取值进行共享。</p><h3 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h3><h4 id="包装类的-valueOf"><a href="#包装类的-valueOf" class="headerlink" title="包装类的 valueOf"></a>包装类的 valueOf</h4><p>例如 Long 的 valueOf 会缓存-128 ～ 127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象。</p><h4 id="String-串池"><a href="#String-串池" class="headerlink" title="String 串池"></a>String 串池</h4><h4 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h4><p>这上面的都是享元模式在 jdk 的具体使用。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我们之前在一个案例中<strong>用了 AtomicReference</strong>对 Bigdecimal 做了保护，既然它是<strong>不可变类</strong>，为什么还要套这么一层？</p><p><strong>虽然它们单个方法是线程安全的，但是多个方法的组合不是线程安全的</strong>。</p><p>故<strong>推广到所有的不可变类</strong>，它们单个方法运行时是线程安全的，多个方法的组合不是线程安全的</p><h2 id="DIY-连接池"><a href="#DIY-连接池" class="headerlink" title="DIY 连接池"></a>DIY 连接池</h2><p>数据库连接池。预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池。</p><p>这样既<strong>节约了连接的创建和关闭时间</strong>，也实现了<strong>连接的重用</strong>。</p><p>需要获取连接和归还连接是线程安全的，用享元实现一下。</p><p>n7/Test3.java</p><p>//1 连接池大小</p><p>//2. 连接对象的数组</p><p>//3. 连接状态的数组 0 表示空闲 1 表示繁忙； 如果多个线程对状态进行修改，会发生线程安全，所以这要用原子数组。</p><p>// 4 构造方法 对属性初始化，初始化 connection 对象放到对象数组中</p><p>//5 借连接方法</p><p>cas！！！</p><p>如果没有空闲连接，可以让当前线程进入等待。等有人归还了，再进行唤醒。</p><p>// 6 归还连接方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPool</span> &#123;<br>    <span class="hljs-comment">//1 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br><span class="hljs-comment">//2. 连接对象的数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br><span class="hljs-comment">//3. 连接状态的数组 0表示空闲 1表示繁忙； 如果多个线程对状态进行修改，会发生线程安全，所以这要用原子数组。</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><span class="hljs-comment">// 4构造方法 对属性初始化，初始化connection对象放到对象数组中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyPool</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span>&#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>        connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyConnection</span>[capcity];<br>        states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(capcity);<br>    &#125;<br><span class="hljs-comment">//5 借连接方法</span><br><br><span class="hljs-comment">//    cas！！！</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    如果没有空闲连接，可以让当前线程进入等待。等有人归还了，再进行唤醒。</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capcity; i++) &#123;<br>                <span class="hljs-keyword">if</span> (states.get(i) == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;获得连接&quot;</span>);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;未获得连接，进入等待&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-comment">// 6 归还连接方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Connection connection)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capcity; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connection  == connections[i])&#123;<br>                states.set(i,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>                    log.debug(<span class="hljs-string">&quot;归还连接&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><p>以上实现没有考虑</p><ol><li>连接的动态增长与收缩；将连接池的大小增长收缩</li><li>连接是否存活（可用性检测）</li><li>等待超时处理（保护性暂停，已经写过了）</li><li>分布式 hash</li></ol><p>对关系型数据库，有比较成熟对 druid，c3p0。</p><p>对更通用的连接池，可以考虑使用 apache common pool。</p><h2 id="final-原理"><a href="#final-原理" class="headerlink" title="final 原理"></a>final 原理</h2><h3 id="设置-final-变量的原理"><a href="#设置-final-变量的原理" class="headerlink" title="设置 final 变量的原理"></a>设置 final 变量的原理</h3><p>在赋值后会加入<strong>写屏障</strong>。</p><p><img src="/img/mac/image-20220329195133443.png" alt="image-20220329195133443"></p><ul><li>写屏障：让之前的指令不会重排后自己后面；之前的所有修改操作同步到主存</li></ul><p>不加 final 是存在线程安全问题的。赋值分为两步，第一是加载变量，第二是赋值。</p><p>如果其他线程看到赋值之前的 0，那么就是不正确的。</p><p>final 变量的赋值也会通过 putfield 指令来完成，同样<strong>在这条指令之后也会加入写屏障</strong>，保证<strong>在其他线程读到它的值时不会出现为 0 的情况</strong>。</p><h3 id="获取-final-变量的原理"><a href="#获取-final-变量的原理" class="headerlink" title="获取 final 变量的原理"></a>获取 final 变量的原理</h3><p>static final int A = 10;</p><p>BIPUSH 10</p><p>把 final 变量修饰的值，复制一份到其他线程中；走的是<strong>栈内存</strong>。</p><p>如果不加 final</p><p>那么调用 A 的类会从 A 所在的类的<strong>共享内存</strong>中加载 A，对应字节码是</p><p>GETSTATIC ….</p><p><strong>总结</strong>，读取 final 变量时，不是在<strong>常量池</strong>中读取（数字较大），就是把 final 的值复制一份到栈中（数值较小）</p><p>如果不加 final，要从堆中读取，效率更慢。</p><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>设计 servlet 时为了保证其线程安全，都有这样的建议，<strong>不要为 servlet 设置成员</strong>，这种<strong>没有任何成员变量的类是线程安全的。</strong></p><p>因为成员变量保存的数据也可以成为状态信息，因此没有成员变量就称之为【无状态】</p><h1 id="七、共享之并发工具"><a href="#七、共享之并发工具" class="headerlink" title="七、共享之并发工具"></a>七、共享之并发工具</h1><h2 id="为什么要线程池"><a href="#为什么要线程池" class="headerlink" title="为什么要线程池"></a>为什么要线程池</h2><p>为什么要线程池？</p><p>如果线程数远远多于 cpu 核心数，会发生大量的上下文切换；</p><p>申请的线程数过多，造成 oom 异常等；</p><p>享元模式，减少线程的创建和销毁。</p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>BlockingQueue 阻塞队列。平衡生产者（产生任务的一方）和消费者（线程）的速率。</p><h3 id="整体关系图"><a href="#整体关系图" class="headerlink" title="整体关系图"></a>整体关系图</h3><p><img src="/img/mac/image-20220330100151102.png" alt="image-20220330100151102"></p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><strong>属性：</strong></p><ol><li>任务队列成员-双向链表 ArrayDeque()</li><li>锁成员- ReentrantLock</li><li>生产者条件变量和消费者条件变量</li><li>容量</li></ol><p><strong>方法：</strong></p><p>阻塞获取 take，</p><p>阻塞添加 put，（加锁。await。signal。）</p><p>获取大小</p><p><strong>poll 增强</strong>：</p><p>增加一个带超时的阻塞获取方法。</p><p>跟之前的保护性暂停逻辑类似。判断经过的时间是否大于 timeout。</p><p>但是 awaitNanos 的方法描述中说明了，<strong>它返回的时间就是剩余的等待时间</strong>。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>根据整体关系图，</p><p><strong>成员有</strong></p><ol><li>阻塞队列 BlockingQueue<Runnable></li><li>线程集合 HashSet&lt;&gt; workers（worker 是自定义的包装类）</li><li>核心线程数</li><li>超时时间 long timeout，一旦过了这个时间线程还没有获取到任务就进行销毁</li><li>超时时间单位 timeunit</li></ol><p><strong>构造方法</strong></p><p>略</p><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p><strong>初始化</strong></p><ol><li>继承 thread</li><li>构造器传入 runnable</li></ol><p><strong>执行任务</strong></p><ol><li>当 task 不为空，执行任务；注意异常捕捉；执行完后 task 置为 null</li><li>当 task 执行完毕，再接着从任务队列获取任务并执行</li></ol><p><strong>移除</strong></p><p>如果退出了执行任务的循环，应该从线程池中移除当前线程</p><h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p><strong>线程池方法</strong></p><ol><li>execute 执行任务方法</li></ol><p>当任务数没有超过 coreSize 时，直接交给 worker 对象执行</p><p>当任务数超过 coreSize 加入任务队列暂存</p><p>上面一块逻辑需要锁的保护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.MyThreadPoolExecutor&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPoolExecutor</span> &#123;<br>    <span class="hljs-keyword">private</span> MyBlockingQueue&lt;Runnable&gt; blockingQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeOut;<br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeOut, TimeUnit timeUnit, <span class="hljs-type">int</span> queueSize)</span> &#123;<br>        blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBlockingQueue</span>&lt;&gt;(queueSize);<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeOut = timeOut;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                blockingQueue.put(task);<br>            &#125;<br><br>        &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>            <span class="hljs-comment">//task不为空 或者 阻塞队列不为空</span><br>            <span class="hljs-comment">//while (task != null || (task = blockingQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = blockingQueue.poll(timeOut,timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br><br>                    log.debug(<span class="hljs-string">&quot;开始运行&quot;</span>);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                task = <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//所以任务都执行完毕了,将当前线程移除</span><br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;被移除&quot;</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.MyBlockingQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">//   1. 任务队列成员-双向链表ArrayDeque()</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-comment">//2. 锁成员- ReentrantLock</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">//3. 生产者条件变量和消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">isFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">isEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">//4. 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br><br><br><br><br><br>    <span class="hljs-comment">// 阻塞获取take，</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-comment">//队列为空，当前线程进入阻塞等待</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空，当前线程进入阻塞等待&quot;</span>);<br>                    isEmpty.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>                    log.debug(<span class="hljs-string">&quot;从阻塞队列中获取&quot;</span>);<br>                    <span class="hljs-type">T</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>                    isFull.signal();<br>                    <span class="hljs-keyword">return</span> task;<br><br><br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 阻塞添加put，（加锁。await。signal。）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-comment">//满了，阻塞等待</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;满了，阻塞等待&quot;</span>);<br>                    isFull.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>                <span class="hljs-comment">//没满，正常添加？</span><br>                log.debug(<span class="hljs-string">&quot;正常添加&quot;</span>);<br>                queue.addLast(task);<br>                isEmpty.signal();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//带时限的添加，在规定时间没加进去就</span><br><br>    <span class="hljs-comment">//获取大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> queue.size();<br>    &#125;<br><br><br>    <span class="hljs-comment">/*poll增强：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    增加一个带超时的阻塞获取方法。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    跟之前的保护性暂停逻辑类似。判断经过的时间是否大于timeout。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    但是awaitNanos的方法描述中说明了，**它返回的时间就是剩余的等待时间**。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-comment">//将等待时间转为nanos</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">elseTime</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-comment">//队列为空，当前线程进入阻塞等待</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (elseTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;进入有时限的等待&quot;</span>);<br>                    elseTime = isEmpty.awaitNanos(elseTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br><br>                <span class="hljs-type">T</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>                isFull.signal();<br>                <span class="hljs-keyword">return</span> task;<br><br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>5 个线程，线程池大小 2，阻塞队列大小 10。</p><p>但是这两个线程目前一直在死等，在 take 方法中等着任务的到来，这也是一种策略。</p><h3 id="为线程设置超时"><a href="#为线程设置超时" class="headerlink" title="为线程设置超时"></a>为线程设置超时</h3><p>将 take 改为 poll 方法。</p><p>最后它们会退出循环块，从线程池中移除。</p><h3 id="任务队列已满"><a href="#任务队列已满" class="headerlink" title="任务队列已满"></a>任务队列已满</h3><p>让一个线程的工作，工作的特别久。</p><p>因为我们用的是阻塞添加，所以我们的主线程会在添加的时候卡住。</p><p>这时候我们应该添加一个<strong>拒绝策略</strong>，给主线程一个选择的余地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS, <span class="hljs-number">2</span>);<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>           pool.execute(() -&gt; &#123;<br>               Sleeper.sleep(<span class="hljs-number">30</span>);<br>               log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>           &#125;);<br>       &#125;<br><br>       log.debug(<span class="hljs-string">&quot;can you see me?&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="带超时的阻塞添加"><a href="#带超时的阻塞添加" class="headerlink" title="带超时的阻塞添加"></a>带超时的阻塞添加</h3><p>offer 方法，返回一个 boolean 值表示是否添加成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//带时限的添加，在规定时间没加进去就返回false</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task,<span class="hljs-type">long</span> timeOut,TimeUnit timeUnit)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeOut);<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nanos&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    nanos = isFull.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;时限 - 添加成功&quot;</span>);<br>            queue.addLast(task);<br>            isEmpty.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ol><li>死等</li><li>带超时等待</li><li>让调用者放弃任务执行</li><li>让调用者抛出异常</li><li>让调用者（主线程）自己执行任务</li></ol><p>可以把选择权交给调用者，用<strong>策略模式</strong>实现。把队列满时的操作抽象成接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">rejectPolicy.tryAndPut(task,blockingQueue);<br><br><br><br><span class="hljs-comment">// 1) 死等</span><br><span class="hljs-comment">// queue.put(task);</span><br><span class="hljs-comment">// 2) 带超时等待</span><br><span class="hljs-comment">//            if (!queue.offer(task, 1, TimeUnit.SECONDS)) &#123;</span><br><span class="hljs-comment">//                return;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">// 3) 让调用者放弃任务执行</span><br><span class="hljs-comment">//   log.debug(&quot;放弃&quot;);</span><br><span class="hljs-comment">// 4) 让调用者抛出异常</span><br><span class="hljs-comment">//  throw new RuntimeException(&quot;error&quot;);</span><br><span class="hljs-comment">// 5) 让调用者自己执行任务</span><br><span class="hljs-comment">//task.run();</span><br></code></pre></td></tr></table></figure><p>让客户端自行传入拒绝策略。</p><h3 id="实现拒绝策略"><a href="#实现拒绝策略" class="headerlink" title="实现拒绝策略"></a>实现拒绝策略</h3><p>再给 queue 设计一个 try and put 方法，来实现自定义的拒绝策略。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><img src="/img/mac/image-20220330150542028.png" alt="image-20220330150542028"></p><ul><li><p>ExecutorService 线程池最基本的接口</p></li><li><p>ScheduleExecutorService 在基础接口上增加了任务调度功能</p></li><li><p>ThreadPoolExecutor 最基本的线程池的实现</p></li><li><p>ScheduleThreadPoolExecutor 带任务调度的线程池的实现</p></li></ul><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>ThreadPoolExecutor 使用 int 的<strong>高三位来表示<u>线程池状态</u><strong>，</strong>低 29 位表示<u>线程数量</u></strong></p><p><strong>五种状态</strong></p><ul><li><p>Running：线程池刚被创建出来低状态</p></li><li><p>shutdown：调用了线程池的<strong>shutdown 方法</strong>；<strong>不会接受新任务，但会处理阻塞队列剩余的任务</strong>；温和的停止</p></li><li><p>stop：调用了线程池<strong>shutDownNow 方法</strong>；<strong>会调用 interrupt 打断正在执行的任务，并抛弃阻塞队列任务</strong>，粗暴的停止</p></li><li><p>Tidying：任务全执行完毕，活动线程为 0，即将进入终结；正常的停止</p></li><li><p>terminated：终结状态</p></li></ul><p><img src="/img/mac/image-20220330151118215.png" alt="image-20220330151118215"></p><p>将这些信息存储到一个原子变量中，这样就可以用一次 cas 原子操作进行赋值。</p><p>//c 为旧值，ctlOf 返回结果为新值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;<br></code></pre></td></tr></table></figure><p>//rs 为高 3 位代表线程池状态，wc 为低 29 位表示线程个数，ctl 是合并它们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>七大参数</strong></p><p>核心线程数目 corePoolSize</p><p>最大线程数目 maximumPoolSize</p><p>生存时间-针对救急线程 keepAliveTime</p><p>时间单位-针对救急线程 unit</p><p>阻塞队列 workQueue</p><p>线程工厂-可以为线程创建时起个好名字 threadFactory</p><p>拒绝策略 RejectedExecutionHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li><p>最大线程数目：<strong>核心线程数+救急线程数</strong>，它们都是<strong>懒加载</strong>的，用到了才创建线程</p></li><li><p>生存时间-针对救急线程</p></li><li><p>时间单位-针对救急线程</p></li></ul><p><strong>救急线程</strong></p><p><strong>在阻塞队列放满的情况下</strong>又来了一个新任务，那么这个<strong>新任务就将由救急线程来执行</strong>（如果有救急线程的话）；救急线程有生存时间，核心线程没有。</p><p>救急线程的实现是配合<strong>有界队列</strong>策略来实现的。</p><p><img src="/img/mac/image-20220330152248922.png" alt="image-20220330152248922"></p><p><strong>拒绝策略</strong></p><p>在<strong>救急线程/核心线程/阻塞队列</strong>都<strong>满载</strong>的情况下，<strong>才会执行拒绝策略</strong>。</p><p><img src="/img/mac/image-20220330152940336.png" alt="image-20220330152940336"></p><p>拒绝策略的接口：</p><p>RejectExecutionHandler。</p><p>jdk 提供的四个拒绝策略：</p><ul><li>AbortPolicy: 抛出异常；这是默认策略</li><li>CallerRunsPolicy:让调用者运行任务</li><li>DiscardPolicy:放弃本次任务</li><li>DiscardOldestPolicy:放弃队列中最早的任务，本任务取而代之</li></ul><p>接下来是第三方</p><ul><li>dubbo：在抛出异常前会记录日志，并 dump 线程栈信息，方便定位问题</li><li>netty 的实现：是创建一个新线程来执行任务</li><li>activeMQ: 带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略。</li><li>pinpoint：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul><p><strong>构造方法结语</strong></p><p>根据这个构造方法，Executors 类中提供了众多<strong>工厂方法</strong>来提供各种用途的线程池。</p><h3 id="工厂方法之-newFixedThreadPool-固定大小的线程池"><a href="#工厂方法之-newFixedThreadPool-固定大小的线程池" class="headerlink" title="工厂方法之 newFixedThreadPool 固定大小的线程池"></a>工厂方法之 newFixedThreadPool 固定大小的线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>    &#125;<br></code></pre></td></tr></table></figure><p>特点</p><ul><li>核心线程数 == 最大线程数，<strong>没有救急线程</strong>，因此无需等待时间。</li><li>阻塞队列无界，<strong>可以放任意数量的任务</strong></li></ul><p>适用</p><p>固定大小的线程池，适用于任务量已知，相对耗时的任务</p><p>顺便提一下<strong>线程工厂</strong></p><p>这是 jdk 默认的线程工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultThreadFactory() &#123;<br>            <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>            group = (s != <span class="hljs-literal">null</span>) ? s.getThreadGroup() :<br>                                  Thread.currentThread().getThreadGroup();<br><br>  <span class="hljs-comment">//     可以根据我们的需要自定义线程名称</span><br>            namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>                          poolNumber.getAndIncrement() +<br>                         <span class="hljs-string">&quot;-thread-&quot;</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>线程池中的线程都是<strong>非守护线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, r,<br>                                  namePrefix + threadNumber.getAndIncrement(),<br>                                  <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (t.isDaemon())<br>              <span class="hljs-comment">//非守护线程</span><br>                t.setDaemon(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<br>                t.setPriority(Thread.NORM_PRIORITY);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="工厂方法之-newCachedThreadPool-带缓冲线程池"><a href="#工厂方法之-newCachedThreadPool-带缓冲线程池" class="headerlink" title="工厂方法之 newCachedThreadPool 带缓冲线程池"></a>工厂方法之 newCachedThreadPool 带缓冲线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                      <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong></p><ul><li><strong>核心线程数是 0</strong>，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<ul><li>线程池中<strong>全部都是救急线程</strong> 60s 后回收</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 SynchronousQueue，实现特点是它<strong>没有容量</strong>。当<strong>任务来的时候，没有线程来取是放不进去的。</strong>（一手交钱一手交货）</li></ul><p>SynchronousQueue 测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSynchronousQueue</span><span class="hljs-params">()</span> &#123;<br>        SynchronousQueue&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;putting &#123;&#125; &quot;</span>, <span class="hljs-number">1</span>);<br>                integers.put(<span class="hljs-number">1</span>);<span class="hljs-comment">//当前线程陷入阻塞</span><br>                log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">1</span>);<br><br>                log.debug(<span class="hljs-string">&quot;putting...&#123;&#125; &quot;</span>, <span class="hljs-number">2</span>);<br>                integers.put(<span class="hljs-number">2</span>);<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125; putted...&quot;</span>, <span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">1</span>);<br>                integers.take();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;taking &#123;&#125;&quot;</span>, <span class="hljs-number">2</span>);<br>                integers.take();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>评价</strong></p><p>整个线程池会表现为线程数会根据任务量不断增长，没有上限。当任务执行完毕，空闲 1 分钟后释放线程。</p><p><strong>适合任务数比较密集，但每个任务执行时间较短的情况</strong>。</p><h3 id="工厂方法之-newSingleThreadPool-单线程线程池"><a href="#工厂方法之-newSingleThreadPool-单线程线程池" class="headerlink" title="工厂方法之 newSingleThreadPool 单线程线程池"></a>工厂方法之 newSingleThreadPool 单线程线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//    装饰者模式</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><p>希望多个任务排队执行，线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会释放。</p><p><strong>区别</strong>：</p><ul><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止没有任何补救措施，而线程池还会给你创建一个新线程,保证池的正常工作。</li><li>与 Executors.newFixedThreadPool(1)的区别<ul><li>在构造方法中，对外暴露的不一样，FixedThreadPool 对外暴露的是 ThreadPool，以后还可以通过强转然后调用相关方法，改变核心线程数量</li><li>SingleThreadPool 对外暴露的是，应用了<strong>装饰器模式</strong>，在外面包了一层，不对外暴露更多的接口。</li></ul></li></ul><p>区别 1 测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        pool.execute(()-&gt;&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;<br>            log.debug(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;);<br><br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;);<br><br>        pool.execute(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;c&quot;</span>);<br>        &#125;);<br></code></pre></td></tr></table></figure><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>//执行任务</p><ul><li>Execute</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>submit：执行带返回结果的任务, 提交任务 task，用返回值 future 获得任务执行结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理就是写过的保护性暂停模式来接收结果，</p><p>Future 对象，就是保护性暂停中的 GuardedoObject。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>        Future&lt;Integer&gt; future = pool.submit(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        );<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">inte</span> <span class="hljs-operator">=</span> future.get();<br>        log.debug(<span class="hljs-string">&quot;int : &#123;&#125;&quot;</span>,inte);<br></code></pre></td></tr></table></figure><p>//提交 task 中所有任务</p><ul><li>invokeAll</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>//提交 task 中所有任务，带超时时间</p><ul><li>invokeAll</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                         <span class="hljs-type">long</span> timeout, TimeUnit unit)</span>&#123;<br><br>                                         &#125;<br></code></pre></td></tr></table></figure><p>演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>        List&lt;Callable&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            list.add(()-&gt;&#123;<br>                log.debug(<span class="hljs-string">&quot;print&#123;&#125;&quot;</span>,j);<br>                <span class="hljs-keyword">return</span> j;<br>            &#125;);<br>        &#125;<br>        List&lt;Future&lt;Integer&gt;&gt; futures = pool.invokeAll(list);<br>        futures.forEach(future-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;get&#123;&#125;,&quot;</span>,future.get());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>//提交 task 中所有任务，哪个任务先执行完毕，返回此任务执行结果，其他任务取消</p><ul><li>invokeAny</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>//提交 task 中所有任务，哪个任务先执行完毕，返回此任务执行结果，其他任务取消，带超时时间</p><ul><li>invokeAny</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                           <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><ul><li>shutdown</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">线程池状态变为shutdown</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">不会接收新任务</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">已提交任务执行完</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            checkShutdownAccess();<br>            <span class="hljs-comment">//修改线程池状态</span><br>            advanceRunState(SHUTDOWN);<br>           <span class="hljs-comment">// 仅会打断空闲线程</span><br>            interruptIdleWorkers();<br>            onShutdown(); <span class="hljs-comment">// hook for ScheduledThreadPoolExecutor</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>     <span class="hljs-comment">// 尝试终结</span><br>        tryTerminate();<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>shutdownnow</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">线程池状态变为stop</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">不会接收新任务</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">将队列中的任务返回</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">用interrupt的方式中断正在执行的任务</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Runnable&gt; tasks;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            checkShutdownAccess();<br>           <span class="hljs-comment">//修改线程池状态</span><br>            advanceRunState(STOP);<br>          <span class="hljs-comment">//打断所有的线程</span><br>            interruptWorkers();<br>          <span class="hljs-comment">//获取队列中剩余任务</span><br>            tasks = drainQueue();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>       <span class="hljs-comment">//尝试终结</span><br>        tryTerminate();<br>  <span class="hljs-comment">//剩余任务返回，可以做进一步处理</span><br>        <span class="hljs-keyword">return</span> tasks;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>is shutdown</li></ul><p>不在 running 状态的线程池，此方法就返回 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ! isRunning(ctl.get());<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>awaitTermination</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                nanos = termination.awaitNanos(nanos);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><p>阻塞 main 线程直到线程池的状态为 termination；在等待时间内如果线程还没运行完就接着运行；运行完了，主线程再放弃等待</p><p>shutdown 演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br>       List&lt;Callable&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>           list.add(()-&gt;&#123;<br>               Sleeper.sleep(<span class="hljs-number">5</span>);<br>               log.debug(<span class="hljs-string">&quot;print&#123;&#125;&quot;</span>,j);<br>               <span class="hljs-keyword">return</span> j;<br>           &#125;);<br>       &#125;<br><br>       List&lt;Future&lt;Integer&gt;&gt; futures = pool.invokeAll(list);<br>       pool.shutdown();<br>       futures.forEach(future-&gt;&#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               log.debug(<span class="hljs-string">&quot;get&#123;&#125;,&quot;</span>,future.get());<br>           &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>               e.printStackTrace();<br>           &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>               e.printStackTrace();<br>           &#125;<br>       &#125;);<br></code></pre></td></tr></table></figure><h2 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>让有限的工作线程来<strong>轮流异步处理</strong>无限多的任务。也可以将其归类为分工模式，它的典型实现就是线程池。</p><p>如果一个任务对应一个线程，那么开销就太大了。</p><p>注意，<strong>不同任务类型应该使用不同的线程池</strong>，这样能够<strong>避免饥饿</strong>，并<strong>提高效率</strong>。</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>区别于活跃性时的饥饿。</p><p>这里是线程数量不足导致的饥饿。</p><p>饥饿死锁发生在当一个任务将另一个任务提交到同一个 Executor,并且等待这个被提交任务的结果。</p><p>演示饥饿死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>        pool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;dian菜 宫保鸡丁&quot;</span>);<br>            Future&lt;String&gt; future = pool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜 宫保鸡丁&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;宫保鸡丁&quot;</span>;<br>            &#125;);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s = future.get();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;上菜，&#123;&#125;&quot;</span>,s);<br>        &#125;);<br><br><br>        pool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;dian菜 coffee&quot;</span>);<br>            Future&lt;String&gt; future = pool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜 coffee&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;coffee&quot;</span>;<br>            &#125;);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s = future.get();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;上菜，&#123;&#125;&quot;</span>,s);<br>        &#125;);<br></code></pre></td></tr></table></figure><p><strong>固定大小线程池/单线程线程池</strong>会出现饥饿死锁现象。</p><p>N8/ TestStarvation.java</p><h3 id="解决饥饿"><a href="#解决饥饿" class="headerlink" title="解决饥饿"></a>解决饥饿</h3><p>一句话。<strong>不同的任务类型使用不同的线程池</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">orderPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cookPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>        orderPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;dian菜 宫保鸡丁&quot;</span>);<br>            Future&lt;String&gt; future = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜 宫保鸡丁&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;宫保鸡丁&quot;</span>;<br>            &#125;);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s = future.get();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;上菜，&#123;&#125;&quot;</span>,s);<br>        &#125;);<br><br><br>        orderPool.execute(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;dian菜 coffee&quot;</span>);<br>            Future&lt;String&gt; future = cookPool.submit(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;做菜 coffee&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;coffee&quot;</span>;<br>            &#125;);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                s = future.get();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;上菜，&#123;&#125;&quot;</span>,s);<br>        &#125;);<br></code></pre></td></tr></table></figure><h3 id="线程池大小多少合适"><a href="#线程池大小多少合适" class="headerlink" title="线程池大小多少合适"></a>线程池大小多少合适</h3><ul><li>过小导致<strong>程序不能充分利用系统资源</strong>，容易导致<strong>饥饿死锁</strong></li><li>过大会导致更多的<strong>线程上下文切换</strong>，占更多内存</li></ul><p><strong>具体策略</strong></p><p>首先根据<strong>不同的任务类型</strong>创建不同的池。</p><h4 id="cpu-计算密集型"><a href="#cpu-计算密集型" class="headerlink" title="cpu 计算密集型"></a>cpu 计算密集型</h4><p>通常采用 cpu 核数 +1 能够实现最优的 cpu 利用率。</p><p>+1 是保证当前线程由于页缺失(os 层面）或其他原因导致暂停时，额外的线程就顶上去。</p><h4 id="IO-密集型运算"><a href="#IO-密集型运算" class="headerlink" title="IO 密集型运算"></a>IO 密集型运算</h4><p>如执行远程 rpc，数据库操作等 io 操作，cpu 就闲了。</p><p>经验公式</p><p>线程数=线程核数 _ 期望 cpu 利用率 _（cpu 计算时间+等待时间/cpu 计算时间）</p><p>《Java 并发编程实战》 P141</p><h3 id="任务调度线程池-ScheduledThreadPool"><a href="#任务调度线程池-ScheduledThreadPool" class="headerlink" title="任务调度线程池 ScheduledThreadPool"></a>任务调度线程池 ScheduledThreadPool</h3><p><strong>Timer 的缺点</strong></p><p>由于<strong>所有的任务都是由同一个线程来调度</strong>，因此所以任务都是串行执行的，同一时间只有一个线程在执行，前一个任务的<strong>延迟或异常</strong>都会影响到之后的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// jdk 1.5以前的timer类</span><br>        <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>        <span class="hljs-type">TimerTask</span> <span class="hljs-variable">timerTask1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;timertask1&quot;</span>);<br>                Sleeper.sleep(<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">TimerTask</span> <span class="hljs-variable">timerTask2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;timertask2&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">//在1s后执行</span><br>       timer.schedule(timerTask1,<span class="hljs-number">1000</span>);<br>       timer.schedule(timerTask2,<span class="hljs-number">1000</span>);<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>创建方法</strong></p><p>newScheduledThreadPool 方法类似固定大小线程池。</p><p><strong>schedule 方法延时执行</strong></p><p>可以避免上面 timer 的缺点，当然线程池的大小要足够，否则还是串行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>);<br>        pool.schedule(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;,<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br><br>        pool.schedule(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;Task2&quot;</span>);<br>        &#125;,<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br><br>        pool.shutdown();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>);<br>        pool.schedule(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;task1&quot;</span>);<br><span class="hljs-comment">//            Sleeper.sleep(2);</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>  <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;<br>        &#125;,<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br><br>        pool.schedule(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;Task2&quot;</span>);<br>        &#125;,<span class="hljs-number">1</span>,TimeUnit.SECONDS);<br><br>        pool.shutdown();<br></code></pre></td></tr></table></figure><p>如果 run 方法里运行出现了异常，异常信息如果不加处理是不会被我们看到的。关于异常处理后面再具体介绍。</p><p><strong>scheduleAtFixedRate 定时执行</strong></p><p>延时 delay s 后开始执行，然后以一定的时间间隔执行该任务。</p><p>如果执行的时间较长，会影响时间间隔。</p><p>它会让前面的任务执行完毕再开始下一个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>);<br>        pool.scheduleAtFixedRate(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;running1...&quot;</span>);<br>        &#125;,<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>        pool.scheduleAtFixedRate(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;running2...&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">3</span>);<br>        &#125;,<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>       <span class="hljs-comment">// pool.shutdown();</span><br></code></pre></td></tr></table></figure><p><strong>scheduleWithFixedDelay</strong></p><p>它的第三个参数是每个任务和每个任务的间隔时间。它是从<strong>上一次任务结束的时间</strong>开始计算的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>);<br>        pool.scheduleWithFixedDelay(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;running1...&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">2</span>);<br>        &#125;,<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure><h3 id="正确处理异常"><a href="#正确处理异常" class="headerlink" title="正确处理异常"></a><strong>正确处理异常</strong></h3><p>可以发现，submit，任务调度方法都不会主动抛出异常。需要我们正确处理。</p><ol><li>try catch 代码块；表示任务自身来处理异常</li><li>用 submit + Callable + future.get 来接收异常</li></ol><p>方式一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">pool.schedule(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;running1...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;running2...&quot;</span>);<br>        &#125;,<span class="hljs-number">1000</span>,TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure><p>方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>);<br><br><br>        Future&lt;Boolean&gt; future = pool.submit(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>            log.debug(<span class="hljs-string">&quot;running2...&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;);<br><br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,future.get());<br><br><span class="hljs-comment">//        pool.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="hljs-comment">//            log.debug(&quot;running2...&quot;);</span><br><span class="hljs-comment">//            Sleeper.sleep(3);</span><br><span class="hljs-comment">//        &#125;,1000,1000, TimeUnit.MILLISECONDS);</span><br>        pool.shutdown();<br></code></pre></td></tr></table></figure><h3 id="任务调度应用"><a href="#任务调度应用" class="headerlink" title="任务调度应用"></a>任务调度应用</h3><p>让每周四 18:00:00 定时执行任务</p><p>方法 scheduleAtFixRate</p><p>问题：当前时间和规定时间（周四）的时间差？ 每周的间隔时间？</p><p>​</p><p>用 LocateDateTime 修改时间到周四。</p><p>问题：它改的是本周的周四，如果是今天是周五的话，要改到下周四。</p><p>如果当前时间 &gt; 本周周四</p><p>必须找到下周周四</p><p>用 Duration.between 来获取时间的差值</p><h3 id="Tomcat-线程池"><a href="#Tomcat-线程池" class="headerlink" title="Tomcat 线程池"></a>Tomcat 线程池</h3><p><img src="/img/mac/image-20220331100433711.png" alt="image-20220331100433711"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，</li><li>acceptor 一直在循环，只负责【接收 socket 连接】</li><li>poller 也一直在循环，只负责监听 socket channel 是否有【可读的 I/O 事件】</li><li>一旦可读，封装一个任务对象（socket Processor），提交给 Executor 线程池处理</li><li>Executor 线程池就类似 jdk 的线程池，由工作线程最终负责【处理请求】</li></ul><p>其中每个部分都是对应的线程，不同的线程不同的分工。</p><p>Tomcat 线程池扩展了 ThreadPoolExecutor</p><ul><li>如果总线程数达到 maximumPoolSize<ul><li>这时不会立刻抛 RejectExecutionException 异常</li><li>而是再次尝试将任务放入队列，如果还失败，才抛 RejectExecutionException 异常</li></ul></li></ul><h3 id="Tomcat-线程池配置"><a href="#Tomcat-线程池配置" class="headerlink" title="Tomcat 线程池配置"></a>Tomcat 线程池配置</h3><p>以下具体配置都可以在 server.xml 中更改。</p><p><strong>Connector 配置</strong></p><p><img src="/img/mac/image-20220331101457633.png" alt="image-20220331101457633"></p><p><strong>Executor 线程配置</strong></p><p>maxQueueSize 默认无界。</p><p>最后一个参数是不是懒惰初始化。默认懒惰。</p><p><img src="/img/mac/image-20220331101822342.png" alt="image-20220331101822342"></p><p>队列无界的话，是不是就没有救急线程了？</p><p>tomcat 在这块也做了更改（相较于 jdk）</p><p>核心线程&lt; 提交任务&lt;最大线程数，先创建救急线程，达到最大线程数，再进入阻塞队列。</p><p><img src="/img/mac/image-20220331102105787.png" alt="image-20220331102105787"></p><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>是 JDK1.7 加入的新线程池实现。它体现的是一种<strong>分治的思想</strong>。适用于能够进行<strong>任务拆分</strong>的<strong>cpu 密集型运算</strong>。</p><p>任务拆分，是<strong>将一个大任务拆分为算法上相同的小任务</strong>，直至不能拆分可以直接求解。比如和<strong>递归</strong>相关的计算，如归并排序，斐波那契数列。</p><p>fork/join 在分治的基础上加入了多线程，可以<strong>把每个任务的分解和合并交给不同的线程来完成，进一步提高了运算效率</strong>。</p><p>fork/join 默认会创建和 cpu 核心数大小相同的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt;&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Mytask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">Mytask</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mytask</span>(n-<span class="hljs-number">1</span>);<br>        t1.fork(); <span class="hljs-comment">//让一个线程去执行此任务</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">join</span> <span class="hljs-operator">=</span> t1.join();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n+join;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>不能用 runnable 和 callable。</p><p><strong>从 1-n 的数字的和。</strong></p><p>如果有返回值继承 RecursiveTask，没有返回值继承 RecursiveAction。</p><p>我们要做的仅有拆分任务，类似于递归。</p><p>fork //一个线程去执行此任务，</p><p>join //获取任务结果</p><p>先 fork 拆分，后 join 合并</p><h3 id="优化拆分"><a href="#优化拆分" class="headerlink" title="优化拆分"></a>优化拆分</h3><p>一个任务依赖另一个任务，并发度不高。</p><p><img src="/img/mac/image-20220331105352346.png" alt="image-20220331105352346"></p><p>任务拆分的好，执行的步骤就少一些。</p><h1 id="八、JUC-并发工具包"><a href="#八、JUC-并发工具包" class="headerlink" title="八、JUC 并发工具包"></a>八、JUC 并发工具包</h1><h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>概念</strong></p><p>AbstractQueuedSynchronizer，是<strong>阻塞式锁</strong>和相关的同步器工具的框架。</p><p><strong>特点</strong></p><ul><li>用 state 属性来表示资源的状态（分独占和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>独占模式是只有一个线程能够访问资源，而共享模式允许多个线程访问资源</li><li>getState -获取 state 状态</li><li>setState -设置 state 状态</li><li>compareAndSet - cas 机制设置 state 状态</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>        state = newState;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>        <span class="hljs-comment">// See below for intrinsics setup to support this</span><br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>提供了基于先进先出 fifo 的等待队列，类似于 monitor 的 entry list</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，具体一个条件变量类似于 monitor 的 waitset</li></ul><p><strong>子类需要实现五个方法</strong></p><ul><li>try Acquire</li><li>try Release</li><li>try AcquireShared</li><li>try ReleaseShared</li><li>isHeld Exclusively 是否持有独占锁</li></ul><p><strong>获取锁的姿势</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">// 如果获取锁失败</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>             <span class="hljs-comment">//入队，可能阻塞当前线程 使用的是park unpark</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>          <span class="hljs-comment">// 获取锁成功，对自己执行interrupt？</span><br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>释放锁的姿势</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">// 如果释放锁成功</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>               <span class="hljs-comment">//让阻塞线程恢复运行</span><br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="实现锁（不可重入锁）"><a href="#实现锁（不可重入锁）" class="headerlink" title="实现锁（不可重入锁）"></a>实现锁（不可重入锁）</h3><p>AQS 使用了模板模式 , 将五个方法交给我们进行自定义，他里面自己封装了一定的逻辑进行使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现可重入锁 ， 关键在于内部aqs实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>  &#123;<br><br>    <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//加锁，不成功会进入等待队列</span><br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123; <span class="hljs-comment">//加锁，可打断</span><br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//尝试加锁</span><br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>,unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.getCondition();<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 加锁，需要设置当前状态为1 用cas</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-comment">//设置owner为自己</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br><br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">//state带有volatile写屏障，放在下面</span><br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//是否持有锁</span><br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">getCondition</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h2><p>类图，实现了 Lock 接口，内部维护了一个 Sync，一个继承了 AQS 的抽象类，并且有<strong>非公平</strong>和<strong>公平</strong>的实现。</p><p><img src="/img/mac/image-20220331114332005.png" alt="image-20220331114332005"></p><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a><strong>加锁</strong></h4><p>构造器，默认是非公平实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//默认</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>        sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    &#125;<br><span class="hljs-comment">//自定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>        sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>没有竞争时</strong></p><p><img src="/img/mac/image-20220331114659397.png" alt="image-20220331114659397"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>          　<span class="hljs-comment">//将状态置为1</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            <span class="hljs-comment">//设置owner为自己</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">else</span><br>                acquire(<span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>第一个竞争出现时</strong></p><ol><li><p>CAS 尝试将 state 由 0 改为 1，结果失败</p></li><li><p>进入 tryAcquire 方法逻辑，这时 state 已经是 1，结果仍然失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>                setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">else</span><br>              <span class="hljs-comment">// 进入acquire</span><br>                acquire(<span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//先进入tryAcquire</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非公平锁的tryAcquire</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-comment">//c仍然为1</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//不是当前线程，不是可重入的情况</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//走到这里 ， return false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331140408481.png" alt="image-20220331140408481"></p></li><li><p>接下来进入 addWriter 逻辑，构造 Node 队列，是<strong>双向链表</strong></p></li></ol><ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中<strong>0 为默认正常状态</strong></li><li>Node 是 lazy 式的创建(在源码的注释中有进行说明)</li><li>其中<strong>第一个 Node 成为 Dummy 或哨兵，用来占位</strong>，不关联线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//先进入tryAcquire</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        <span class="hljs-comment">//tryAcquire走过了，现在是进入addWriter</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>            node.prev = pred;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>                pred.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        enq(node);<br>  <span class="hljs-comment">//在等待队列中创建一个node节点</span><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331141105859.png" alt="image-20220331141105859"></p><p>当前线程进入 acquireQueued 逻辑</p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己紧邻着 head（排第二位的），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍然为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的<strong>waitStatus 改为-1</strong>，这次返回 false</li><li>状态为**-1 表示 它有责任唤醒后继结点**。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-comment">//先进入tryAcquire</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        <span class="hljs-comment">//addWriter 也走过了，为阻塞队列添加了一个节点node，并把node返回（当前想要抢占锁的线程）</span><br>        <span class="hljs-comment">//现在进入acquireQueue</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//死循环</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">//假设这里尝试获取锁又失败</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">//进入shouldParkAfterFailedAcquire</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意，这里是首次进入</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>  <span class="hljs-comment">// 获得前驱节点的状态值，假设这时只有一个线程来竞争</span><br>   <span class="hljs-comment">// 那么状态值为0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>  <span class="hljs-comment">//    状态值是否为-1 ， false</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * This node has already set status asking a release</span><br><span class="hljs-comment">             * to signal it, so it can safely park.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 也不会进入if</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">             * indicate retry.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">             * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">             */</span><br><br>          <span class="hljs-comment">//会走到这里，把状态值改为-1</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>  <span class="hljs-comment">// return false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331141128983.png" alt="image-20220331141128983"></p><ol start="5"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued，再次 tryAcquire 尝试获取锁，当然这时 state 仍然为 1，失败；如果碰巧锁被释放，并且被当前线程抢到，那就结束逻辑。</li><li>当再次进入 shouldParkAfterFailedAcquire 时，因为其前驱 node 的代码已经是-1，这次返回 true</li><li>进入 parkAndCheck Interrupt</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第二次进来</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>        <span class="hljs-comment">// 前驱节点的状态已经被置为-1，返回true</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * This node has already set status asking a release</span><br><span class="hljs-comment">             * to signal it, so it can safely park.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//后面代码省略了</span><br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">//已经两次进入shouldParkAfterFailedAcquire了</span><br>               <span class="hljs-comment">//接下来进入parkAndCheckInterrupt 要准备阻塞自己了</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//陷入阻塞</span><br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331141339450.png" alt="image-20220331141339450"></p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p><strong>解锁竞争成功流程</strong></p><p>再次有多个线程经历上述过程竞争失败，变为</p><p><img src="/img/mac/image-20220331141551140.png" alt="image-20220331141551140"></p><p>此时 Thread-0 释放锁，进入 try- Release 流程，如果成功</p><ul><li>设置 owner 线程为 null</li><li>state 为 0</li></ul><p>当前队列不为 null，并且 head 的 waitStatus 为-1，进入 unparkSuccessor 流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>  <span class="hljs-comment">//    进入这</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 这个方法没有公平和非公平之分</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>  <span class="hljs-comment">//     有可重入的判断，重入锁后面再分析</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">//     假设走到这里</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                free = <span class="hljs-literal">true</span>;<br>              <span class="hljs-comment">//设置owner线程为null</span><br>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            &#125;<br>  <span class="hljs-comment">//       state设为0</span><br>            setState(c);<br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>   <span class="hljs-comment">//    return true</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>          <span class="hljs-comment">//根据配图 ， h这时状态值为-1</span><br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>              <span class="hljs-comment">//进入unparkSuccessor</span><br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>找到队列中离 head 最近的一个 Node，unpark 恢复其运行，本例中为 Thread-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//大概意思就是找到队列的下一个可以被唤醒的node，将其唤醒</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">         * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>        <span class="hljs-comment">//将当前头节点状态置为0</span><br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">         * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">         * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">         * non-cancelled successor.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-comment">//找到一个 可以被唤醒的节点</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>            s = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                    s = t;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">//唤醒</span><br>            LockSupport.unpark(s.thread);<br>    &#125;<br></code></pre></td></tr></table></figure><p>回到 Thread-1 的<strong>acquireQueued</strong>流程</p><p><img src="/img/mac/image-20220331142425287.png" alt="image-20220331142425287"></p><p>如果加锁成功（没发生竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state=1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 从链表断开，可被垃圾回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Thread-1从这里被唤醒</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//唤醒</span><br>        <span class="hljs-keyword">return</span> Thread.interrupted(); <span class="hljs-comment">// return true</span><br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">// 再次抢锁</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">//假设抢到了</span><br>                <span class="hljs-comment">//head指向刚刚Thread-1所在的Node，该Node清空Thread</span><br>                    setHead(node);<br>                    <span class="hljs-comment">/* setHead的逻辑</span><br><span class="hljs-comment">                    private void setHead(Node node) &#123;</span><br><span class="hljs-comment">                     head = node;</span><br><span class="hljs-comment">                     node.thread = null;</span><br><span class="hljs-comment">                     node.prev = null;</span><br><span class="hljs-comment">                                     &#125;</span><br><span class="hljs-comment">                    */</span><br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>解锁竞争失败流程</strong></p><p>如果这时候有其他线程来竞争（非公平的体现），例如这时候来了 Thread-4</p><p>如果不巧被 Thread-4 占了先</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state=1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞。</li></ul><p><img src="/img/mac/image-20220331142942434.png" alt="image-20220331142942434"></p><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><p>nonfairTryAcquire</p><p>以非公平锁为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首次获得锁</span><br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>        setExclusiveOwnerThread(current);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>//如果已经获得了锁，线程还是当前线程，表示发生了锁重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>               <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                <span class="hljs-comment">//state++</span><br>               setState(nextc);<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br></code></pre></td></tr></table></figure><p>tryRelease</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>         <span class="hljs-comment">//state--</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>          <span class="hljs-comment">//支持锁重入，只有state减为0，才释放成功</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                free = <span class="hljs-literal">true</span>;<br>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            &#125;<br>            <span class="hljs-comment">//state--</span><br>            setState(c);<br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="可打断原理-巧妙"><a href="#可打断原理-巧妙" class="headerlink" title="可打断原理-巧妙"></a>可打断原理-巧妙</h3><h4 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h4><p>在此模式下，<strong>即使它被打断，仍会驻留在 AQS 队列中</strong>，<strong>等获得锁后方能继续运行</strong>（是继续运行！只是打断标记变成了 true）</p><p><strong>首先明确</strong></p><ul><li>如果打断标记已经是 true，则 park 会失效</li><li>正常运行的线程，被打断的话打断标记为 true</li><li>被阻塞的线程，被打断的话打断标记变为 false</li></ul><p>源码阅读顺序</p><p>acquireQueued:假设当前线程正在阻塞，把它打断了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 如果打断标记已经是true，则park会失效</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//interrupted会清除打断标记</span><br>     <span class="hljs-comment">// 返回是否被打断过，下次被park的时候还能park住</span><br>  <span class="hljs-comment">// 关键点：这里是被打断过的所以会返回true，如果没有被打断过，就返回false</span><br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br><br><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//还是需要tryAcquire获得锁以后，才能返回打断状态</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br><br>               <span class="hljs-comment">//如果是因为interrupt被唤醒并且没有得到锁，继续等待</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br><br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>以下是被打断后获得锁的逻辑，不再截图了。</p><p>acquire ：此时已经获得锁了</p><p>//如果打断状态为 true</p><p>self Interrupt</p><p>//重新产生一次中断</p><h4 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h4><p>源码阅读顺序</p><p>acquireInterruptibly</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    <span class="hljs-comment">//在park过程中如果被interrupt会进入此</span><br>                    <span class="hljs-comment">//这时候抛出异常，而不会再次进入for循环</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><p>nonfairTryAcquire</p><p>以非公平锁为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-comment">//如果还没有获得锁</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//尝试用cas获得，这里体现了非公平性：不去检查AQS队列，直接上来抢</span><br>                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//与非公平锁主要区别在于tryAcquire方法的实现</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>           <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>           <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>           <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 先检查AQS队列中是否有前驱节点，没有才去竞争</span><br>               <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                   compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                   setExclusiveOwnerThread(current);<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>               <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>               setState(nextc);<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// The correctness of this depends on head being initialized</span><br>        <span class="hljs-comment">// before tail and on head.next being accurate if the current</span><br>        <span class="hljs-comment">// thread is first in queue.</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; <span class="hljs-comment">// Read fields in reverse initialization order</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        Node s;<br>        <span class="hljs-comment">//h=t表示队列中有Node</span><br>        <span class="hljs-keyword">return</span> h != t &amp;&amp;<br>          <span class="hljs-comment">//如果队列中没有老二 返回false</span><br>          <span class="hljs-comment">//如果队列中有老二，但是当前线程不是老二，返回false</span><br>            ((s = h.next) == <span class="hljs-literal">null</span> || s.thread != Thread.currentThread());<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 Condition Object 也是一个双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//Condition Object维护的双向链表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br></code></pre></td></tr></table></figure><h4 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h4><p>开始时 Thread-0 持有锁，调用 await，进入 Condition 的 add Condition Waiter 流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>             <span class="hljs-comment">//  等待队列中的node创建完毕</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>             <span class="hljs-comment">// 来到这</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>                LockSupport.park(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>                interruptMode = REINTERRUPT;<br>            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>                unlinkCancelledWaiters();<br>            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>                reportInterruptAfterWait(interruptMode);<br>        &#125;<br></code></pre></td></tr></table></figure><p>创建新的 Node 状态为-2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>            <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>                unlinkCancelledWaiters();<br>                t = lastWaiter;<br>            &#125;<br>            <span class="hljs-comment">//创建新的Node状态为-2（Node.CONDITION），关联Thread-0，加入等待队列尾部</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>                firstWaiter = node;<br>            <span class="hljs-keyword">else</span><br>                t.nextWaiter = node;<br>            lastWaiter = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331172227812.png" alt="image-20220331172227812"></p><p>接下来进入 AQS 的 fullyRelease 流程。</p><p>full Release 表示释放所有的锁，包括重入的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>             <span class="hljs-comment">//  等待队列中的node创建完毕</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>             <span class="hljs-comment">// 来到这</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>                LockSupport.park(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>                interruptMode = REINTERRUPT;<br>            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>                unlinkCancelledWaiters();<br>            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>                reportInterruptAfterWait(interruptMode);<br>        &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//state数量就是重入锁的数量</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-comment">//释放所有的锁，并返回</span><br>            <span class="hljs-comment">//进入release逻辑</span><br>            <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> savedState;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                node.waitStatus = Node.CANCELLED;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331172446431.png" alt="image-20220331172446431"></p><p>unpark 唤醒 AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>       <span class="hljs-comment">//释放所有的锁</span><br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//唤醒等到队列的下一个node</span><br>                unparkSuccessor(h);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331172600130.png" alt="image-20220331172600130"></p><p>park 阻塞 Thread-0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>             <span class="hljs-comment">//  等待队列中的node创建完毕</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>             <span class="hljs-comment">// 把锁释放并且唤醒了其他线程</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>              <span class="hljs-comment">// 这里第一次可以进来,具体不分析了</span><br>            <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>             <span class="hljs-comment">// park阻塞Thread-0</span><br>                LockSupport.park(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>                interruptMode = REINTERRUPT;<br>            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>                unlinkCancelledWaiters();<br>            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>                reportInterruptAfterWait(interruptMode);<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331172630128.png" alt="image-20220331172630128"></p><h4 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h4><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="/img/mac/image-20220331173702979.png" alt="image-20220331173702979"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">//不是锁的持有者，抛出异常</span><br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>           <span class="hljs-comment">//取得等待队列中第一个Node,即Thread-0所在Node</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>            <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>              <span class="hljs-comment">//进入ConditionObject的doSignal流程</span><br>                doSignal(first);<br>        &#125;<br></code></pre></td></tr></table></figure><p>将 node 节点从双向链表中移出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>           <span class="hljs-keyword">do</span> &#123;<br><br>               <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>                   lastWaiter = <span class="hljs-literal">null</span>;<br>                   <span class="hljs-comment">//将 node节点从双向链表中移出</span><br>               first.nextWaiter = <span class="hljs-literal">null</span>;<br>              <span class="hljs-comment">//将Node转移到AQS队列，转移成功返回true</span><br>           &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>                    (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>       &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331174059660.png" alt="image-20220331174059660"></p><p>执行 transferForSingal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//执行transferForSingal流程</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If cannot change waitStatus, the node has been cancelled.</span><br><span class="hljs-comment">         可能等待队列中的Node会放弃对锁的竞争（打断、超时），从而转移失败，让transferforsignal返回false</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-comment">//将Thread-0的waitStatus改为0</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="hljs-comment">         * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="hljs-comment">         * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="hljs-comment">         * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="hljs-comment">         */</span><br>       <span class="hljs-comment">//将该Node加入AQS队列尾部，并且返回前驱结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>        <span class="hljs-comment">//正常情况应该是0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>        <span class="hljs-comment">// 将前驱结点的状态值改为-1</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>            LockSupport.unpark(node.thread);<br>            <span class="hljs-comment">//将Node转移到AQS队列，转移成功返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220331174337095.png" alt="image-20220331174337095"></p><p><strong>小结</strong></p><p>花了一整个上午的时间，把源码彻彻底底的看了一遍，有些地方比较好 debug ，还有些地方比如可打断，我是真不知道怎么 debug，还希望各位大神赐教。</p>]]></content>
    
    
    <categories>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC-1</title>
    <link href="/2022/04/12/JUC-1/"/>
    <url>/2022/04/12/JUC-1/</url>
    
    <content type="html"><![CDATA[<h1 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序中的代码编译成可执行文件，可执行文件到内存中，执行其代码，这是动态的过程，称进程。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个线程就是一个指令流，将一条条指令交给 cpu 执行。</p><p>线程为最小调度单位，进程像是一个资源管理的平台。</p><p>一个进程内的多个线程可以去访问共享资源，但是自己的栈和程序计数器之类的是线程独占的。</p><p>线程的上下文切换比进程上下文切换低。因为进程切换，相较于线程需要更改 cpu 寄存器等其他内容，开销比线程大。</p><h3 id="并发-并行"><a href="#并发-并行" class="headerlink" title="并发 并行"></a>并发 并行</h3><p>单核 cpu 下，微观串行，宏观并行。</p><p>并发 一段时间内执行多个线程</p><p>并行 一个时间点执行多个线程/进程；并行需要多核 cpu 的支撑。</p><p>一般情况下，<strong>并发和并行同时发生</strong>。因为线程数可能远远大于 cpu 核心数。</p><h3 id="应用之异步调用"><a href="#应用之异步调用" class="headerlink" title="应用之异步调用"></a>应用之异步调用</h3><p>需要等待结果返回（阻塞）才能继续运行，同步。Async</p><p>不需要等待结果返回，就能继续运行。（异步）sync</p><p>例如，读取磁盘文件操作是同步的，假设耗费 5s，那么在一个线程下肯定会发生阻塞。</p><p>如果使用 java 的多线程方法，另开一个线程用于读取文件，这样就能避免阻塞主线程。</p><p>io 操作下，<strong>线程不占用 cpu</strong>，但是线程也不工作，会进入<strong>阻塞直到 io 结束</strong>，所以后面有异步 io 和非阻塞 io。</p><h3 id="应用之提高效率"><a href="#应用之提高效率" class="headerlink" title="应用之提高效率"></a>应用之提高效率</h3><figure class="highlight"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs">计算1 10ms<br>计算2 11ms<br>计算3 9ms<br>汇总 1ms<br></code></pre></td></tr></table></figure><p>如果是<strong>单核</strong>cpu，则一共需 31ms</p><p>如果是<strong>多核 cpu</strong>，三个计算<strong>并行</strong>执行，只需要 12ms</p><h1 id="二、java-线程"><a href="#二、java-线程" class="headerlink" title="二、java 线程"></a>二、java 线程</h1><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="方法一，直接使用-Thread"><a href="#方法一，直接使用-Thread" class="headerlink" title="方法一，直接使用 Thread"></a>方法一，直接使用 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><br>  &#125;<br>&#125;; <span class="hljs-comment">//匿名类，实际是创建了thread的子类；仅仅是创建了线程</span><br><br>t.setName(<span class="hljs-string">&quot;t1&quot;</span>);<span class="hljs-comment">//指定线程名称</span><br><br>t.start(); <span class="hljs-comment">//启动线程</span><br></code></pre></td></tr></table></figure><h3 id="方法二，使用-Runnable-配合-Thread"><a href="#方法二，使用-Runnable-配合-Thread" class="headerlink" title="方法二，使用 Runnable 配合 Thread"></a>方法二，使用 Runnable 配合 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//要执行的任务</span><br> &#125;<br>&#125;;<br><br><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable,<span class="hljs-string">&quot;t&quot;</span>);<br><br>t.start();<span class="hljs-comment">//启动线程</span><br></code></pre></td></tr></table></figure><h3 id="lambda-表达式精简"><a href="#lambda-表达式精简" class="headerlink" title="lambda  表达式精简"></a>lambda  表达式精简</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;I am lambda&quot;</span>);<br><br><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable,<span class="hljs-string">&quot;task&quot;</span>);<br><br>t.start();<span class="hljs-comment">//启动线程</span><br></code></pre></td></tr></table></figure><p>函数式接口 Runnable</p><p><strong>结论：推荐使用 Runnable 接口，一是配合线程池；二是优先使用组合关系而不是继承</strong></p><h3 id="方法三，FutureTask-配合-Thread"><a href="#方法三，FutureTask-配合-Thread" class="headerlink" title="方法三，FutureTask 配合 Thread"></a>方法三，FutureTask 配合 Thread</h3><p>FutureTask 可以用 get 方法来获取任务的执行结果。获取结果是通过实现 Callable 接口来实现的。</p><p>get 方法将等待结果返回；如果任务以及完成，那么 get 会立刻返回结果；否则将会进入阻塞直到任务进入完成状态，然后返回结果或者抛出异常。</p><h2 id="linux-查看-java-进程"><a href="#linux-查看-java-进程" class="headerlink" title="linux 查看 java 进程"></a>linux 查看 java 进程</h2><ul><li><p>top 查看耗费 cpu 的进程</p></li><li><p>ps -ef | grep java</p></li><li><p>jps</p></li><li><p>kill (进程号) 杀死进程</p></li><li><p>用 top 查看线程信息：</p><p>top -H -p (pid)</p><p>-H 表示查看线程信息，-p 是线程号</p></li><li><p>jstack (pid) 也是查看线程信息，虽然它能展示更详细的 java 线程信息，但是只是快照，是某个时刻的。</p></li><li><p>jconsole 图形化界面，能够连接到某个 java 进程。也能通过远程连接接到另一个服务器的 java 进程。</p></li></ul><h2 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h2><p>cpu 不再执行当前线程的代码，执行另一个线程的代码</p><ul><li>线程时间片用完</li><li>垃圾回收</li></ul><p>工作线程暂停，垃圾回收线程工作</p><ul><li>更高优先级线程需要运行</li><li>线程自己调用 sleep yield wait join park synchronized lock</li></ul><p>上下文切换时，由操作系统来记录当前的状态。</p><p>java 中对应的概念就是<strong>程序计数器</strong>。</p><ul><li>状态包括栈帧信息，局部变量，操作数栈，返回地址等。</li></ul><p><img src="/img/mac/image-20220325153008819.png" alt="image-20220325153008819"></p><ul><li>频繁的上下文切换会影响性能。</li></ul><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="/img/mac/image-20220325153427913.png" alt="image-20220325153427913"></p><p><img src="/img/mac/image-20220325153634829.png" alt="image-20220325153634829"></p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>start 方法让线程进入就绪态，里面的代码不一定会直接运行（由操作系统决定）；只能调用一次。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>线程启动后调用的方法</p><h3 id="join-join-long-n"><a href="#join-join-long-n" class="headerlink" title="join() / join(long n)"></a>join() / join(long n)</h3><p>请配合<strong>应用之同步</strong>食用</p><p>等待线程运行结束，谁调用 join，就等待谁运行结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">在main线程中，调用t1.join();<br>那么main线程就在此阻塞等待t1线程结束。<br><br>t1.join();<br><br></code></pre></td></tr></table></figure><h3 id="getState"><a href="#getState" class="headerlink" title="getState()"></a>getState()</h3><p>获取当前线程的状态信息。</p><p>java 中的线程有 6 个状态,具体移步六种状态。</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>请配合**应用之防止 CPU 占用 100%**一起食用</p><p>放弃当前线程对时间片的使用</p><ul><li><p>让当前线程从 RUNNING 状态进入 TIMED_WAITING 状态（有时限的等待状态）</p></li><li><p>其他线程可以使用<strong>正在睡眠的线程的 interrupt 方法打断正在睡眠的线程</strong>，这时 sleep 方法会抛出 InterruptedException 异常。</p></li><li><p>睡眠结束后的线程未必立刻得到执行</p></li></ul><p>理解：睡眠结束后，只是进入<strong>就绪状态</strong>，得到 cpu 的时间片才能执行它的代码。</p><ul><li>建议用 TimeUnit 的 sleep 方法代替 Thread 的 sleep 以<strong>获得更好的可读性</strong></li></ul><h3 id="yield-（让出-谦让）"><a href="#yield-（让出-谦让）" class="headerlink" title="yield （让出/谦让）"></a>yield （让出/谦让）</h3><ul><li><p>调用 yield 让当前线程从运行状态进入就绪状态，然后调度执行其他线程</p></li><li><p>具体的实现依赖于 os 的任务调度器</p></li></ul><h3 id="线程的打断"><a href="#线程的打断" class="headerlink" title="线程的打断"></a>线程的打断</h3><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p>打断 sleep wait join 的线程，也就是可以打断 timed wait 状态的线程。让其由 timed wait 状态变为就绪态。同时<strong>将其打断标记置为 false</strong>。</p><p>打断正常运行的线程，不会干扰它的正常运行，<strong>只是将其打断标记置为了 true</strong>。</p><p>join 的底层原理其实就是 wait。</p><h4 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted"></a>isInterrupted</h4><p><strong>正常线程被打断</strong>过后，打断标记被置为 true；</p><p><strong>被阻塞的线程</strong>被打断后，打断标记变成了 false</p><h4 id="static-interrupted"><a href="#static-interrupted" class="headerlink" title="static interrupted"></a>static interrupted</h4><p>于 isInterrupted 的区别是</p><p>判断完以后，会清除打断标记。</p><h4 id="打断-park"><a href="#打断-park" class="headerlink" title="打断 park"></a>打断 park</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br> LockSupport.park();<br>&#125;)<br>sleep(<span class="hljs-number">1</span>);<br>t1.start();<br>t1.interrupt();<br></code></pre></td></tr></table></figure><p>需注意的是，如果一个线程当前打断标记为真的时候，park 方法会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br> LockSupport.park();<br> LockSupport.park();<br>&#125;)<br>sleep(<span class="hljs-number">1</span>);<br>t1.start();<br>t1.interrupt();<br></code></pre></td></tr></table></figure><p>所以 park 一般配合 interrupted 使用。static interrupted 会在判断完后清除打断标记。</p><h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p>在一个线程 t1 中<u>优雅</u>的终止 t2 线程</p><h4 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h4><p>使用 t2.stop()杀死 t2</p><ul><li>如果 t2 线程锁住了共享资源，那么它被杀死后就再也没有机会释放锁</li></ul><p>使用 system.exit()直接退出线程所在的进程。</p><h4 id="具体应用-监控记录"><a href="#具体应用-监控记录" class="headerlink" title="具体应用 - 监控记录"></a>具体应用 - 监控记录</h4><p><img src="/img/mac/image-20220325165859927.png" alt="image-20220325165859927"></p><p>如果正常执行被打断，打断标记会变成 true；如果在睡眠的时候被打断，会抛出异常，并且将打断标记变成 false。这时我们要处理异常并且将打断标记置为 true（重新打断），从而执行料理后事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-keyword">private</span> Thread thread;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><br>             <span class="hljs-comment">//如果当前打断标记为true ， 结束</span><br>               <span class="hljs-keyword">if</span> (thread.isInterrupted())&#123;<br>                   log.debug(<span class="hljs-string">&quot;该线程被打断，现在是善后工作&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>               <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-comment">//正常工作</span><br>                   Thread.sleep(<span class="hljs-number">1000</span>);<br>                   log.debug(<span class="hljs-string">&quot;执行监控&quot;</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   log.debug(<span class="hljs-string">&quot;在睡眠时被打断，需要重新打断&quot;</span>);<br>                   thread.interrupt();<br>               &#125;<br>           &#125;<br>        &#125;,<span class="hljs-string">&quot;thread1&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        thread.interrupt();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">termination</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();<br>        termination.start();<br>        Thread.sleep(<span class="hljs-number">1500</span>);<br>        termination.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><h4 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority"></a>setPriority</h4><p>线程的优先级默认 5</p><ul><li>如果 cpu 忙，那么优先级高的线程会获得更多时间片；但 cpu 闲时，优先级几乎无作用。</li><li>线程优先级会提示调度器优先调用该线程，但仅仅是提示。</li></ul><h3 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h3><p>过时方法。不多介绍。容易破坏同步代码块，造成死锁。</p><p>stop</p><p>suspend</p><p>resume</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>默认情况下，java 进程需要等待所有线程都运行结束，才会结束。</p><p>有一种特殊的线程叫守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没执行完，也强制结束。</p><h4 id="setDaemon-true"><a href="#setDaemon-true" class="headerlink" title="setDaemon(true)"></a>setDaemon(true)</h4><p>将调用此方法的线程设置为守护线程。</p><h4 id="守护线程实例"><a href="#守护线程实例" class="headerlink" title="守护线程实例"></a>守护线程实例</h4><ul><li><strong>垃圾回收器线程</strong>就是守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程。这两个线程是用来接收请求和分发线程的请求。</li></ul><h3 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态"></a>线程的五种状态</h3><p>从<strong>操作系统</strong>层面来描述</p><p><img src="/img/mac/image-20220325173135494.png" alt="image-20220325173135494"></p><ul><li><p>初始：仅在语言层面创建了线程对象，还未与操作系统线程关联。</p></li><li><p>就绪：该线程已于操作系统关联，并且可由 cpu 调度执行</p></li><li><p>运行：获取了 cpu 时间片，正在执行的线程。时间片用完后进入就绪态。</p></li><li><p>阻塞态：当一个线程请求某种资源，或者发起请求给 os（如读取文件），这时线程实际上用不到 cpu，这时会发生线程上下文切换，随后该线程进入阻塞态。待得到资源得到满足，由操作系统对其进行唤醒，进入就绪态。</p></li><li><p>终止：线程执行完毕，生命周期结束。</p></li></ul><h3 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h3><p><img src="/img/mac/image-20220325174451100.png" alt="image-20220325174451100"></p><p>根据 Thread.State 枚举，分为六种状态。</p><ul><li>NEW:刚被创建的线程，但是还没有被调用 start 方法；对应 os 层面的初始状态</li><li>RUNNABLE：涵盖了<strong>操作系统</strong>层面的<strong>就绪态，运行状态，阻塞状态</strong>（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行状态。）</li><li>WAITING：join 方法对应的等待状态，<strong>没有时限</strong>的等待。</li><li>BLOCKED：拿不到锁的状态。</li><li>TIMED_WAITING：sleep 方法对应的状态，一种<strong>有时限的等待</strong>；</li><li>TERMINATED：对应 os 的终止状态</li></ul><p>测试代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="应用之防止-CPU-占用-100"><a href="#应用之防止-CPU-占用-100" class="headerlink" title="应用之防止 CPU 占用 100%"></a>应用之防止 CPU 占用 100%</h2><h3 id="sleep-实现"><a href="#sleep-实现" class="headerlink" title="sleep 实现"></a>sleep 实现</h3><p>防止 while true 中空转浪费 cpu</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-comment">//要抛异常</span><br>  Thread.sleep(<span class="hljs-number">50</span>);<br>  <span class="hljs-comment">//do other ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以使用 wait 或条件变量达到类似效果</li><li>不同的是 wait 和条件变量需要加锁和唤醒。</li><li>sleep 适用于无需锁同步场景</li></ul><h2 id="应用之同步"><a href="#应用之同步" class="headerlink" title="应用之同步"></a>应用之同步</h2><ul><li>需要等待结果返回才能继续运行，同步</li><li>不需要等待结果返回也能继续运行，异步</li></ul><h3 id="使用-join-实现同步"><a href="#使用-join-实现同步" class="headerlink" title="使用 join 实现同步"></a>使用 join 实现同步</h3><p><img src="/img/mac/image-20220325163450536.png" alt="image-20220325163450536"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;t1 sleep 1s...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            r = <span class="hljs-number">10</span>;<br>            log.debug(<span class="hljs-string">&quot;t1 over...&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            log.debug(<span class="hljs-string">&quot;t2 sleep 2s...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            r = <span class="hljs-number">20</span>;<br>            log.debug(<span class="hljs-string">&quot;t2 over...&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        t1.start();<br>        t2.start();<br>        t1.join(); <span class="hljs-comment">//等待t1执行完毕</span><br>        t2.join();<span class="hljs-comment">//等待t2执行完毕</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        log.debug(<span class="hljs-string">&quot;r = &#123;&#125;,cost = &#123;&#125;ms&quot;</span>,r,end-start);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> time)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        TimeUnit.SECONDS.sleep(time);<br><br></code></pre></td></tr></table></figure><p>等待 t1 运行完毕的同时，t2 也在并行的运行。</p><p>所以总共耗时 2s。</p><h3 id="有时限的-join-实现有时限的同步"><a href="#有时限的-join-实现有时限的同步" class="headerlink" title="有时限的 join 实现有时限的同步"></a>有时限的 join 实现有时限的同步</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">　　t1.join(<span class="hljs-number">1500</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="应用之统筹"><a href="#应用之统筹" class="headerlink" title="应用之统筹"></a>应用之统筹</h2><h3 id="烧水泡茶之-join"><a href="#烧水泡茶之-join" class="headerlink" title="烧水泡茶之 join"></a>烧水泡茶之 join</h3><p><img src="/img/mac/image-20220325175849680.png" alt="image-20220325175849680"></p><p>如果让四个人（四个线程）做这四件事，太浪费。</p><p>让两个线程来做即可。</p><ul><li>第一个线程</li></ul><p>洗水壶 1 分钟 -&gt; 烧开水 15 分钟</p><ul><li>第二个线程</li></ul><p>洗茶壶，洗茶杯，拿茶叶 4 分钟</p><ul><li>最后，泡茶。用 join 实现。</li></ul><p><strong>拓展</strong>：最后泡茶的时候，我们只能指定两个线程其中之一来做。我们的代码最好能适应两个线程都能执行泡茶的这个行为。这步留着后面进一步学习来实现。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p><img src="/img/mac/image-20220325193527073.png" alt="image-20220325193527073"></p><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="共享的问题"><a href="#共享的问题" class="headerlink" title="共享的问题"></a>共享的问题</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul><li><p>如果多个线程<strong>读取</strong>共享资源，是不会有问题的</p></li><li><p>多个线程对共享资源进行读写操作，就会出问题</p></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incr</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//临界区</span><br>  i++;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>多个线程在临界区内执行，由于代码的执行序列不恰当而出现不正确的结果，称为竞态条件。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>为了避免临界区的竞态条件发生，可以用 synchronized 解决。</p><p>synchronized 是阻塞式的解决方案，是采用<strong>互斥</strong>的方式解决</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只有一个线程执行临界区代码</li><li>同步是由于线程执行的先后顺序不同，需要一个线程等待其他线程运行到某个点</li></ul><p>互斥和同步都可以用 synchronized 解决</p><p>持有锁的对象，依旧会正常进行时间片的切换，但是没有锁的对象无法进入临界区。</p><p><img src="/img/mac/image-20220326091814627.png" alt="image-20220326091814627"></p><p>synchronized 是用对象锁保证了<strong>临界区内代码的原子性</strong>，原子的意思就是代码是不可分割的，是一块整体。</p><ul><li><p>synchronized 加在非 static 成员方法上，等价于锁住 this 对象；</p></li><li><p>synchronized 加在 static 成员方法上，等价于锁住当前类的 Class 对象。</p></li></ul><h2 id="变量的线程安全"><a href="#变量的线程安全" class="headerlink" title="变量的线程安全"></a>变量的线程安全</h2><h3 id="成员变量和静态变量"><a href="#成员变量和静态变量" class="headerlink" title="成员变量和静态变量"></a>成员变量和静态变量</h3><ul><li><p>如果它们没有被共享，则线程安全</p></li><li><p>如果被共享了，根据它们的状态能否被改变</p><ul><li>如果只有读，线程安全</li><li>如果有读写，则这段代码是临界区，需要考虑线程安全</li></ul></li><li><p>分析</p><p>成员变量需要考虑线程安全。</p></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeThread</span>()</span>&#123;<br>  <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul><li><p>局部变量是线程安全的</p></li><li><p>局部变量引用的对象未必线程安全</p><ul><li>如果该对象没有逃离方法的作用范围，则它是安全的</li><li>如果该对象逃离了方法的作用范围，如 return，则需要考虑线程安全</li></ul></li><li><p>局部变量线程安全分析</p></li></ul><p>基本类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  i++;<br>&#125;<br>如果多个线程调用这个方法，局部变量i会在每个线程的栈帧内存中创建多份，不存在共享<br></code></pre></td></tr></table></figure><p>引用类型对象</p><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ul><li><p>String</p></li><li><p>Integer 等包装类</p></li><li><p>StringBuffer</p></li><li><p>Random</p></li><li><p>Vector</p></li><li><p>Hashtable</p></li><li><p>juc 包下的类</p></li></ul><p>说明：</p><ol><li>这里的线程安全是指，多个线程调用它们<strong>同一个实例</strong>的某个方法时，是线程安全的。</li><li>它们的每个方法是原子的</li><li><strong>注意</strong>它们多个方法的组合不是原子的</li></ol><p>分析：它们只是方法内部是原子性的，但是组合并不是原子性的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br><br><br><span class="hljs-comment">//如果多个线程执行这段代码，还是会有线程安全问题</span><br><span class="hljs-keyword">if</span>(table.get(<span class="hljs-string">&quot;key&quot;</span>) == <span class="hljs-literal">null</span>)&#123;<br>  table.put(<span class="hljs-string">&quot;key&quot;</span>,value);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220326104711247.png" alt="image-20220326104711247"></p><h2 id="不可变类的线程安全"><a href="#不可变类的线程安全" class="headerlink" title="不可变类的线程安全"></a>不可变类的线程安全</h2><p>String / Integer 等都是不可变类，因为其内部状态不可改变。</p><p>如 String 类的 substring 方法，它并没有改变自身的 value 字符数组，它只直接创建了一个新的对象。</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>具体情况具体分析，成员变量等。</p><h2 id="习题-卖票"><a href="#习题-卖票" class="headerlink" title="习题-卖票"></a>习题-卖票</h2><p>开启 1k 个线程进行卖票。</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>找到临界区，就是对共享变量进行读写操作的代码块。</p><p>还要进行组合问题的考虑。</p><h2 id="习题-转账"><a href="#习题-转账" class="headerlink" title="习题-转账"></a>习题-转账</h2><p>两个人开两个线程多次转账。</p><h2 id="Monitor-管程-重量级锁-10"><a href="#Monitor-管程-重量级锁-10" class="headerlink" title="Monitor 管程-重量级锁 10"></a>Monitor 管程-重量级锁 10</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>如果使用 synchronized 给对象上重量级锁，该对象的对象头中的 mark word 就有<strong>指向操作系统的 monitor 对象</strong>的指针。</p><p>具体底层实现：将 Mark word 里面的<strong>标志位由 01 改成 10</strong>，并且将<strong>其他位全部改成指向 monitor 对象的指针。</strong></p><p>即图中倒数第二行</p><p><img src="/img/mac/image-20220326144719280.png" alt="image-20220326144719280"></p><h3 id="图例分析"><a href="#图例分析" class="headerlink" title="图例分析"></a>图例分析</h3><ul><li><p>一个线程 t1 想进入临界区</p></li><li><p>此时 owner 已经是 t2 了，所以 t1 会进入 BLOCKED 状态，并且进入等待队列 EntryList</p></li></ul><p><img src="/img/mac/image-20220326145415282.png" alt="image-20220326145415282"></p><ul><li>图中的 waitset 里的线程是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面在学习 wait - notify 时具体分析。</li></ul><h3 id="synchronized-字节码"><a href="#synchronized-字节码" class="headerlink" title="synchronized 字节码"></a>synchronized 字节码</h3><p>《深入理解 Java 虚拟机》p259</p><p>monitorenter 指令：将锁对象的 markword 改成指向 monitor 的指针。</p><p>不论是否有异常，monitorexit 和 monitorenter 指令总是一一对应。</p><h2 id="轻量级锁-00"><a href="#轻量级锁-00" class="headerlink" title="轻量级锁 00"></a>轻量级锁 00</h2><p>场景：一个对象虽然有多线程访问，但是多线程<strong>访问的时间是错开的（没有竞争）</strong>，可以用轻量级锁优化。</p><p>轻量级锁<strong>对使用者透明</strong>，<strong>语法仍是 synchronized</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            method2();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>每个线程的栈帧都会包含一个<strong>锁记录 Lock Record</strong>，内部可以存储<strong>锁对象的 markword</strong>和<strong>锁对象的地址</strong>。</p><p><img src="/img/mac/image-20220326152408704.png" alt="image-20220326152408704"></p><ul><li><p>进入 synchronized 后</p></li><li><p><strong>如果 cas 替换成功</strong>（需要上锁对象原先标志位为 01，表示未锁定），<strong>对象头中存储了 Lock Record 地址和状态 00</strong>，表示由该线程给对象加锁</p></li></ul><p><img src="/img/mac/image-20220326154904240.png" alt="image-20220326154904240"></p><ul><li><p><strong>如果 cas 失败</strong>，有两种情况</p><ul><li>锁重入</li></ul><p>在上面例子中，一个线程先请求<strong>未被持有的锁</strong>给 lock，<strong>jvm 会记录下锁的持有者（线程），同时将计数值置为 1</strong>；随后这个线程<strong>再次请求获取同样的锁</strong>，计数值就再+1。<strong>当线程退出同步代码块时，计数值会相应递减直到 0。</strong></p><p>锁重入底层：会再添加一条 Lock Record 作为重入的计数；当解锁时，如果有取值为 null 的锁记录，表示有重入。</p><p><img src="/img/mac/image-20220326153829444.png" alt="image-20220326153829444"></p><ul><li>锁膨胀</li></ul><p>如果另一条线程也想获取锁，此时轻量级锁将升级为重量级锁。Mark word 中的标志位变为<strong>10</strong>，<strong>表示重量级锁</strong>。同时为 obj 申请 monitor 锁，<strong>让 obj 的 Markword 指向 monitor</strong>。然后另一条线程进入 monitor 的 EntryList,进入 BLOCKED 状态。</p></li><li><p>退出同步代码块时，如果锁记录不为 null，<strong>使用 cas 将 Mark word 的值恢复给对象头</strong></p><ul><li>成功</li><li>失败，说明轻量级锁进行了锁膨胀或升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><p>存疑，cas？一种乐观锁的思想，后面介绍。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><strong>重量级锁竞争时，可以使用自旋来优化</strong>。如果当前线程自旋成功（持锁线程释放了锁），就可以避免阻塞，<strong>避免线程上下文切换带来的开销</strong>。</p><p>自旋（让线程不进入阻塞，而是先忙等）；</p><p>自旋需要占 CPU,只有<strong>多核 cpu</strong>才好用</p><p>jdk6 中引入了<strong>自适应自旋</strong></p><p><strong>自旋重试成功的情况</strong></p><p><img src="/img/mac/image-20220326155700103.png" alt="image-20220326155700103"></p><p><strong>自旋重试失败的情况</strong></p><p><img src="/img/mac/image-20220326155918003.png" alt="image-20220326155918003"></p><h2 id="偏向锁-101"><a href="#偏向锁-101" class="headerlink" title="偏向锁 101"></a>偏向锁 101</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>《深入理解 java 虚拟机》第 3 版 p484</p><p>解决轻量级锁在<strong>没有竞争的时候</strong>，<strong>每次重入仍然需要执行 CAS 操作</strong>尝试替换 Mark word，虽然这个 CAS 必定失败。导致 Lock Record 中的取值为 null。<strong>如果有竞争的话，就升级为重量级锁了</strong>。</p><p>偏向，就是**偏向第一个获取锁的<u>线程</u>**。如果该锁一直没有被其他线程获取，则持有偏向锁的线程永远不需要再进行同步。</p><p>只有第一次使用 CAS<strong>将线程 ID 设置到对象的 Mark word 头</strong>，之后再获取锁时检查这个线程的 ID，如果是自己的就表示没有竞争，无需重新 CAS。</p><p>启用偏向锁的 Mark word：</p><p>标志位为 01，但是偏向模式 biased_lock=1。<strong>即 Mark word 的后三位为 101</strong>。</p><p>优先级：偏向锁&gt;轻量级锁</p><p>（禁用偏向锁）</p><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p><strong>轻量级锁</strong>中，Mark word 的信息存放在线程栈帧内的锁记录中。</p><p>当<strong>第一次调用对象的 hashCode</strong>时，才会给对象头中的 Mark word 相应的 31 位赋值，<strong>此时还会禁用对象的偏向锁</strong>。</p><p>原因，偏向锁模式下，对象头中的 Mark word 中要存储线程 ID，这需要大量的存储空间，以至于 hashcode 没地方存，所以导致偏向锁的禁用。</p><h4 id="其他线程使用对象"><a href="#其他线程使用对象" class="headerlink" title="其他线程使用对象"></a>其他线程使用对象</h4><p>当有其他线程使用偏向锁对象时，会<strong>将偏向锁升级为轻量级锁</strong>。当然，持锁线程和其他线程必须是<strong>非竞争关系</strong>。否则会升级成<strong>重量级锁</strong>。</p><h4 id="调用-wait-notify"><a href="#调用-wait-notify" class="headerlink" title="调用 wait/notify"></a>调用 wait/notify</h4><p>因为 wait/notify 只有重量级锁才有。</p><h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>这里的批量，是让一批对象全部进行重新偏向，而不是撤销偏向升级轻量级锁</p><p>当 jvm 对一个线程<strong>撤销偏向锁，升级成轻量级锁</strong>这个行为达到一个阈值（20 次）时，就会思考之前是不是偏向了一个错的线程。</p><p>所以它干脆不撤销了，去偏向另外一个新的线程。</p><h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>当撤销偏向锁超过 40 次后，jvm 会觉得自己确实偏向错了，根本就不该进行偏向。</p><p>所以会让整个类的所有对象都会变为不可偏向的。即便是后来新建的对象。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>  x++;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span>(o)&#123;<br> x++;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>即时编译器发现加锁的对象不会逃离方法，也就是它的作用域被限制在方法内部，其他线程无法访问到 o，所以这里虽然有锁，但是可以被安全的消除。</p><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><p><img src="/img/mac/image-20220326172244396.png" alt="image-20220326172244396"></p><ul><li><strong>Owner 线程</strong>发现条件不满足，<strong>调用 wait 方法</strong>，即可进入 WaitSet 变成 WAITING 状态</li><li>BLOCKED 和 WAITING 线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 owner 线程释放锁时唤醒</li><li>WAITING 线程会在<strong>owner 线程调用 notify 或 notifyall 方法时唤醒</strong>，但唤醒后并不重新获得锁，<strong>仍需进入 EntryList 进行竞争</strong></li></ul><h3 id="api-介绍"><a href="#api-介绍" class="headerlink" title="api 介绍"></a>api 介绍</h3><p><strong>线程必须先获得锁</strong>，<strong>必须是成为 monitor 中的 owner 才能调用下面三个方法</strong></p><p>具体实现也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(obj)&#123;<br>   obj.wait();<br>   obj.notify();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>obj.wait() ：owner 线程进入 wait set;进入等待直到被 notify</li><li>obj.wait(long timeout) ：timeout 时间走完后还没有被唤醒，就自动结束等待。</li><li>obj.notify()：从 wait set 中唤醒一个</li><li>obj.notifyAll() ： 唤醒 wait set 全部的线程</li></ul><h2 id="wait-notify-正确使用"><a href="#wait-notify-正确使用" class="headerlink" title="wait notify 正确使用"></a>wait notify 正确使用</h2><h3 id="wait（long-n）-和-sleep（long-n）的区别"><a href="#wait（long-n）-和-sleep（long-n）的区别" class="headerlink" title="wait（long n） 和 sleep（long n）的区别"></a>wait（long n） 和 sleep（long n）的区别</h3><ol><li>sleep 是 Thread 的静态方法，而 wait 是 object 的方法</li><li>sleep 不需要强制和 synchronized 配合使用</li><li><strong>sleep 在睡眠的同时，不会释放对象锁，会带着锁睡觉</strong>；但是<strong>wait</strong>在等待时<strong>会释放对象锁</strong></li><li>共同点：它们的状态都是 TIMED_WAITING</li></ol><p>注：synchronized 锁住的对象一般加上 final</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>如果 notify 叫醒了一个不是我们想要的线程，怎么处理？</p><p>notify 的条件用 while 代替 if</p><p>实例：点烟和送外卖</p><p>总结，</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">synchronized</span>(lock)&#123;<br><br><span class="hljs-built_in">while</span>(条件不成立)&#123;<br>   lock<span class="hljs-selector-class">.wait</span>();<br>&#125;<br>   <span class="hljs-comment">//干活</span><br>&#125;<br><br>另一个线程，用lock<span class="hljs-selector-class">.notifyAll</span>唤醒对象，解决虚假唤醒问题。<br></code></pre></td></tr></table></figure><h2 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h2><p>用在<strong>一个线程等待另一个线程的执行结果</strong>，Guarded Suspension</p><p><img src="/img/mac/image-20220326193820238.png" alt="image-20220326193820238"></p><ul><li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程，那么要使用消息队列</li><li>JDK 中 join 到实现，future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br>  <span class="hljs-keyword">private</span> Object response;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>      <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-built_in">this</span>.wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> response;<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>      <span class="hljs-built_in">this</span>.response = response;<br>      <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="增加超时"><a href="#增加超时" class="headerlink" title="增加超时"></a>增加超时</h3><p>记录等待的开始时间和经历时间。等待一定的时间后，计算经历的时间，如果大于某个值，退出循环。 <strong>记得解决虚假唤醒问题！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span>&#123;<br><br><br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>           <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>           <span class="hljs-type">long</span> <span class="hljs-variable">passTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passTime;<br>               <span class="hljs-comment">//应该等待的时间小于0了，break，退出等待</span><br>               <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-built_in">this</span>.wait(waitTime);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>             passTime = System.currentTimeMillis() - startTime;<br>           &#125;<br><br>           <span class="hljs-keyword">return</span> response;<br>       &#125;<br><br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span>&#123;<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>           <span class="hljs-built_in">this</span>.response = response;<br>           <span class="hljs-built_in">this</span>.notifyAll();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="join-原理"><a href="#join-原理" class="headerlink" title="join 原理"></a>join 原理</h3><p>保护性暂停模式的具体实现；跟有时限的保护性暂停逻辑基本一样。</p><h3 id="解耦生产和消费"><a href="#解耦生产和消费" class="headerlink" title="解耦生产和消费"></a>解耦生产和消费</h3><p>一个邮箱和多个 guarded object，一个居民类，一个邮递员类。</p><p><img src="/img/mac/image-20220327092609476.png" alt="image-20220327092609476"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.mailbox&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailBox</span>&#123;<br><br>    <span class="hljs-comment">//邮箱 设为线程安全的hashtable</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,GuardedObject2&gt; box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span>&#123;<br>        id ++;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject2 <span class="hljs-title function_">createGuardedObj</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> generateId();<br>        <span class="hljs-type">GuardedObject2</span> <span class="hljs-variable">guarded</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject2</span>(i);<br>        box.put(i,guarded);<br>        log.debug(<span class="hljs-string">&quot;创建了一个guarded，&#123;&#125;&quot;</span>,i);<br>        <span class="hljs-keyword">return</span> guarded;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject2 <span class="hljs-title function_">getGuardedObj</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-keyword">return</span> box.remove(id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getKeySet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> box.keySet();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//等待接受者</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.person&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject2</span> <span class="hljs-variable">guardedObj</span> <span class="hljs-operator">=</span> MailBox.createGuardedObj();<br><br>        <span class="hljs-comment">//居民要拿一封信</span><br>        log.debug(<span class="hljs-string">&quot;居民在5s内想要收信&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> guardedObj.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;居民收到信&#123;&#125;&quot;</span>,o);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.postman&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Postman</span><span class="hljs-params">(<span class="hljs-type">int</span> id,String mail)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.mail = mail;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject2</span> <span class="hljs-variable">guardedObj</span> <span class="hljs-operator">=</span> MailBox.getGuardedObj(id);<br>        guardedObj.complete(mail);<br>        log.debug(<span class="hljs-string">&quot;信件&#123;&#125;完成投递&quot;</span>,id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h2><p>在上面的介绍中，产生结果和消费结果线程一一对应，一个居民就要一个邮递员。</p><ul><li>与前面的保护性暂停不同，<strong>不需要产生结果和消费结果的线程一一对应</strong></li><li>消息队列可以用来平衡生产和消费的线程资源</li><li><strong>生产者仅负责产生结果数据，不关心数据如何处理，而消费者专心处理结果数据</strong></li><li>消息队列有容量限制，满了就不会再加入数据，空时不再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="/img/mac/image-20220327104117360.png" alt="image-20220327104117360"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 异步模式生产消费 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">messageQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                messageQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id,<span class="hljs-string">&quot;msg&quot;</span>+id));<br>            &#125;).start();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                messageQueue.take();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.messageQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span>&#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-comment">//队列满了，就去wait</span><br>            <span class="hljs-keyword">while</span> (queue.size() &gt;= capcity)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列已满，添加消息失败&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;添加消息成功&quot;</span>);<br>            queue.addLast(message);<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-comment">//队列空了，去wait</span><br>            <span class="hljs-keyword">while</span> (queue.isEmpty())&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;队列为空，获取消息失败&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;获取消息成功&#123;&#125;&quot;</span>,m.getMsg());<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String msg;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现消息队列类"><a href="#实现消息队列类" class="headerlink" title="实现消息队列类"></a>实现消息队列类</h3><p>rabbitmq 等，是<strong>进程间通信</strong>。而这里的消息队列，是<strong>java 线程间通信</strong>，注意区别。</p><ol><li>把 Message 对象设计成线程安全的类，需要有 id 和消息的内容（final，状态不可变）</li><li>消息队列里面的集合选择，双向队列 linkedlist。</li><li>capacity 容量规定；</li><li>获取消息 take 和存入消息 put 的实现；给谁上锁？条件变量不满足怎么办，唤醒？</li></ol><h2 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park&amp;Unpark"></a>Park&amp;Unpark</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>LockSupport.park()暂停当前线程</li><li>LockSupport.unpark(Thread t)恢复 t 线程的运行</li></ul><p>注：park 下的<strong>线程状态是 WAIT</strong>，<strong>是无时限的等待</strong></p><p>如果先执行了 unpark() , 再执行 park，则线程<strong>不会如预期一样进行阻塞 WAIT</strong></p><p><strong>结论</strong>：unpark 可以在线程暂停前执行，也可以在线程暂停后执行，对应线程都不会阻塞</p><h3 id="与-wait-amp-notify-比较"><a href="#与-wait-amp-notify-比较" class="headerlink" title="与 wait&amp;notify 比较"></a>与 wait&amp;notify 比较</h3><ul><li><p>Wait&amp;notify 必须配合 object monitor 一起使用</p></li><li><p>park&amp;unpack 是<strong>以线程为单位进行唤醒</strong>；notify 是随机唤醒一个线程，没有那么<strong>精确</strong></p></li><li><p>基本介绍中最后一段</p></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>线程底层用 c 代码写了一个 Paker 类。里面有 cond, mutex, counter 属性。类比成旅行者，带着一个帐篷和干粮。</p><p>分别是等待队列，互斥锁，信号量。</p><h4 id="情况-1-先-park-后-unpark"><a href="#情况-1-先-park-后-unpark" class="headerlink" title="情况 1-先 park 后 unpark"></a>情况 1-先 park 后 unpark</h4><ol><li>调用 park 时，如果 counter=0 ，获得 mutex 互斥锁；</li><li>线程进入 cond 等待队列阻塞；</li><li>设置 counter = 0</li><li>调用 unpark，设置 counter =1</li><li>唤醒阻塞队列中的线程</li><li>线程恢复运行</li><li>设置 counter 为 0</li></ol><h4 id="情况-2-先-unpark-后-park"><a href="#情况-2-先-unpark-后-park" class="headerlink" title="情况 2-先 unpark 后 park"></a>情况 2-先 unpark 后 park</h4><ol><li>调用 unpark，设置 counter=1</li><li>调用 park，检查到 counter=1</li><li>线程无需阻塞，继续运行</li><li>设置 counter=0</li></ol><h2 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h2><p>双向箭头表示可以互相转换。</p><p><img src="/img/mac/image-20220327113320087.png" alt="image-20220327113320087"></p><ul><li>1:调用 start 方法，从 NEW 进入 RUNNABLE</li><li>2:调用 wait&amp;notify 可以在 RUNNABLE 和 WAITING 之间进行转换<ul><li>调用 obj.wait 方法从 runnable 进 waiting</li><li>obj.notify &amp; notifyAll &amp; t.interrupt<ul><li>竞争锁成功：t 线程从 waiting 进入 runnable 状态</li><li>竞争锁失败，t 线程从 waiting 进入 blocked 状态</li></ul></li></ul></li><li>3:调用 t.join 方法，<strong>让调用 join 方法的线程等待 t 线程运行完毕</strong>。当前线程从 runnable 进入 waiting；t 线程运行结束，或调用了<strong>当前线程的 interrupt</strong>，当前线程从 waiting 进入 runnable</li><li>4:当前线程调用 Locksupport.park()方法会让当前线程从 runnable 进入 waiting；调用 LockSupport.unpark(目标线程)或调用当前线程的 interrupt，会让目标线程从 waiting 进入 runnable</li><li>5:带时限的 wait&amp;notify，参考情况 2，区别是有超时时间和在 runnable 与 timed waiting 之间转换</li><li>6:带时限的 join 参考情况 3，同上</li><li>7:带时限的 park 参考情况 4，同上</li><li>8: 调用了 thread.sleep 方法。</li><li>9:获取锁时竞争失败，线程从 Runnable 变为 blocked；持锁线程退出同步代码块，当前线程竞争成功后，从 blocked 转为 runnable</li><li>10:所有代码执行完毕，进入 TERMINATRED</li></ul><h2 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h2><p>之前介绍的都是<strong>单把锁</strong>出现的问题。</p><p>小明和小红都要学习和睡觉，如果就一个房间（一把锁），它们的并发度很低。</p><p>解决：使用多个房间（多把锁），studyroom 和 bed room</p><ul><li><p>好处：增强并发度</p></li><li><p>坏处：如果一个线程要获取多把锁，容易出现<strong>死锁</strong></p></li></ul><h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个线程各自持有一个锁，却都想获取对方的锁，就没法接着运行。</p><h4 id="死锁定位"><a href="#死锁定位" class="headerlink" title="死锁定位"></a>死锁定位</h4><p>方法一：通过 <strong>jps</strong> 和 <strong>jstack</strong>进行定位</p><p>jps 查看进程</p><p>jstack 用来抓取进程快照</p><p>方法二：使用<strong>jconsole</strong></p><h4 id="哲学家就餐"><a href="#哲学家就餐" class="headerlink" title="哲学家就餐"></a>哲学家就餐</h4><p>五个哲学家，五根筷子</p><p>Philosopher 类 / Chopstick 类</p><p>演示死锁，使用 jconsole 进行检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 哲学家就餐 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c1,c2,<span class="hljs-string">&quot;cx1&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c2,c3,<span class="hljs-string">&quot;cx2&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c3,c4,<span class="hljs-string">&quot;cx3&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c4,c5,<span class="hljs-string">&quot;cx4&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c5,c1,<span class="hljs-string">&quot;cx5&quot;</span>);<br>        p1.start();<br>        p2.start();<br>        p3.start();<br>        p4.start();<br>        p5.start();<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>&#125;<br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopstick left;<br>    <span class="hljs-keyword">private</span> Chopstick right;<br>    <span class="hljs-keyword">private</span> String name;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;eating .. &quot;</span>,name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>两个线程不断的改变对方的结束条件，从而导致谁也无法结束。</p><p>与死锁的区别：死锁是两个线程都在<strong>阻塞</strong>，<strong>无法继续运行</strong>；而活锁仍然占用 cpu</p><p>解决：<strong>尝试增加一些随机的睡眠时间</strong>。</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><h4 id="顺序加锁解决死锁"><a href="#顺序加锁解决死锁" class="headerlink" title="顺序加锁解决死锁"></a>顺序加锁解决死锁</h4><p>先看一个<strong>顺序加锁</strong>解决死锁的案例</p><p>线程 1 先获取锁 A,线程 2 也获取锁 A，线程 2 会进入阻塞直到线程 1 释放锁 A。</p><p>在哲学家就餐中，如果五个人的筷子都是按顺序获取的，就不会有死锁。</p><p>但是，虽然没有死锁，会引出另一种问题，就是<strong>饥饿</strong>。</p><p>将死锁情况下的最后一个哲学家的持有筷子改为 c1 c5，就没有死锁发生，但是会发现，最后一个哲学家基本吃不上饭，</p><p>这就发生了饥饿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 哲学家就餐 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">4</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c1,c2,<span class="hljs-string">&quot;cx1&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c2,c3,<span class="hljs-string">&quot;cx2&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c3,c4,<span class="hljs-string">&quot;cx3&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c4,c5,<span class="hljs-string">&quot;cx4&quot;</span>);<br>        <span class="hljs-type">Philosopher</span> <span class="hljs-variable">p5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(c1,c5,<span class="hljs-string">&quot;cx5&quot;</span>);<br>        p1.start();<br>        p2.start();<br>        p3.start();<br>        p4.start();<br>        p5.start();<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>&#125;<br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopstick left;<br>    <span class="hljs-keyword">private</span> Chopstick right;<br>    <span class="hljs-keyword">private</span> String name;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (left)&#123;<br>                <span class="hljs-keyword">synchronized</span> (right)&#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;eating .. &quot;</span>,name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock 可重入锁"></a>ReentrantLock 可重入锁</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>相对于 synchronized，其特点</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁（解决饥饿）；<strong>线程先到先得，而不是随机争抢</strong>，但是并发度低</li><li>支持多个条件变量</li></ul><p>与 synchronized 一样，ReentrantLock 支持重入</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁</span><br>reentrantlock.lock();<br><br><span class="hljs-keyword">try</span>&#123;<br> <span class="hljs-comment">//临界区</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">//释放锁</span><br>  reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>synchronized 的锁实际上是 monitor 对象。</p><p>而 ReentrantLock 本身就是锁对象</p><p>演示可重入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 可重入 &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            method2();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>这里就与 synchronized 不同，reentrant lock 可打断</p><p>由其他线程调用 interrupt 的来打断，是被动的放弃锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//如果没有竞争，那么此方法会获取lock锁</span><br>         <span class="hljs-comment">//如果有竞争,进入阻塞队列，可以被其他线程用interrupt方法打断</span><br>                lock.lockInterruptibly();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                log.debug(<span class="hljs-string">&quot;未获取到锁，return&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;成功获取锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br><br>        lock.lock();<br>        t1.start();<br>        t1.interrupt();<br></code></pre></td></tr></table></figure><p>可以打断，也是一种防止死锁的手段。</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>这是主动放弃锁的方式；如果其他线程占有了锁，自己不会无限制的阻塞下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//尝试得到锁，如果已被占有就return false</span><br>                <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS))&#123;<br>                    log.debug(<span class="hljs-string">&quot;未获得锁&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>            <span class="hljs-comment">//得到锁了也要释放</span><br>            <span class="hljs-keyword">try</span> &#123;<br>               log.debug(<span class="hljs-string">&quot;获得锁&quot;</span>);<br>           &#125;<span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>           &#125;<br><br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        log.debug(<span class="hljs-string">&quot;main 上锁&quot;</span>);<br>        lock.lock();<br><br>        t1.start();<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;main 释放锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br></code></pre></td></tr></table></figure><p>tryLock 返回的是 bool 值，得到锁就返回 true</p><p>tryLock 也可以带参数，表示尝试获取锁等待的时间。同时在等待的时候也会被打断。被打断的逻辑与之前基本一致。</p><h4 id="锁超时解决哲学家吃饭"><a href="#锁超时解决哲学家吃饭" class="headerlink" title="锁超时解决哲学家吃饭"></a>锁超时解决哲学家吃饭</h4><ol><li><p>筷子是锁，所以筷子继承 ReentrantLock</p></li><li><p>核心思想：用 tryLock 获取锁，获取不到也不拿着另一把干等着；两把锁获取到了，吃饭，把锁释放掉</p></li><li><p>为什么能解决？因为当一个哲学家拿起左手筷子后，拿右手筷子失败了，他会把左手筷子释放掉。而不是带着左手筷子死等。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br>&#125;<br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Chopstick left;<br>    <span class="hljs-keyword">private</span> Chopstick right;<br>    <span class="hljs-keyword">private</span> String name;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>           <span class="hljs-keyword">if</span>(left.tryLock())&#123;<br>              <span class="hljs-keyword">try</span>&#123;<br>                  <span class="hljs-keyword">if</span> (right.tryLock())&#123;<br>                      <span class="hljs-keyword">try</span> &#123;<br>                          eat();<br>                      &#125;<span class="hljs-keyword">finally</span> &#123;<br>                          right.unlock();<br>                      &#125;<br>                  &#125;<br>              &#125;<span class="hljs-keyword">finally</span> &#123;<br>                  left.unlock();<br>              &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;eating .. &quot;</span>,name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>ReentrantLock 默认是不公平锁；可以<strong>在构造方法中</strong>指定。</p><p>公平的意思是<strong>阻塞队列中先入队的线程</strong>先获得锁。</p><p>这里先不讲，公平锁一般没有必要，<strong>会降低并发度</strong>，后面分析原理时学习。</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量</p><p>而 reelock<strong>支持多条件变量</strong>，也就是支持多间”休息室“，不同的条件变量有独属于自己的“休息室”</p><p>这样的好处是<strong>不用再使用</strong>notifyall 进行<strong>虚假唤醒</strong>然后重新循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-comment">//创建一个条件变量</span><br>lock.newCondition();<br>lock.lock();<br><span class="hljs-comment">// 去等待</span><br>condition1.await();<br><span class="hljs-comment">//叫醒condition1中的一个线程</span><br>condition1.signal();<br><span class="hljs-comment">//叫醒condition1中的全部线程</span><br>condition1.signalAll();<br></code></pre></td></tr></table></figure><p><strong>使用流程</strong></p><ul><li>使用 await 前需要获得锁</li><li>await 执行后，会释放锁，进入 condition 等待</li><li>await 的线程被唤醒（或打断，超时），重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><h4 id="条件变量使用例子"><a href="#条件变量使用例子" class="headerlink" title="条件变量使用例子"></a>条件变量使用例子</h4><ol><li>以 room 为锁</li><li>创建等烟和等外卖的休息室（条件变量）；两个 condition</li><li>依旧是循环判断条件变量有没有满足</li><li>区别在于<strong>不会被虚假唤醒</strong></li></ol><h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><p><strong>控制线程的运行次序</strong></p><h3 id="控制次序"><a href="#控制次序" class="headerlink" title="控制次序"></a>控制次序</h3><h4 id="方式一-wait-amp-notify-的正确姿势"><a href="#方式一-wait-amp-notify-的正确姿势" class="headerlink" title="方式一 wait&amp;notify 的正确姿势"></a>方式一 wait&amp;notify 的正确姿势</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> canGo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">while</span> (canGo == <span class="hljs-literal">false</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br><br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                canGo = <span class="hljs-literal">true</span>;<br>                lock.notifyAll();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="方式二-park-amp-unpark"><a href="#方式二-park-amp-unpark" class="headerlink" title="方式二 park&amp;unpark"></a>方式二 park&amp;unpark</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">//Thread.sleep(2000);</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                LockSupport.unpark(t1);<br><br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br></code></pre></td></tr></table></figure><h4 id="方式三-reentrantlock-的-await-amp-signal"><a href="#方式三-reentrantlock-的-await-amp-signal" class="headerlink" title="方式三 reentrantlock 的 await&amp;signal"></a>方式三 reentrantlock 的 await&amp;signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">static</span> Condition condition;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        condition = lock.newCondition();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>               lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                condition.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-comment">//Thread.sleep(2000);</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br><br><br>                <span class="hljs-keyword">try</span>&#123;<br>                    log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                    condition.signalAll();<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="交替执行"><a href="#交替执行" class="headerlink" title="交替执行"></a>交替执行</h3><p>线程一输出 5 个 a，线程 2 输出 5 个 b，线程 3 输出 5 个 c，想要输出 abcabcabcabcabc？</p><p>解决：需要<strong>等待标记</strong>和<strong>下一个标记</strong></p><h4 id="方式一-wait-amp-notify"><a href="#方式一-wait-amp-notify" class="headerlink" title="方式一 wait&amp;notify"></a>方式一 wait&amp;notify</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify</span> <span class="hljs-variable">waitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>).start();<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> waitFlag,<span class="hljs-type">int</span> nextFlag)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>                <span class="hljs-keyword">while</span>(flag != waitFlag)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式二-await-amp-signal"><a href="#方式二-await-amp-signal" class="headerlink" title="方式二 await&amp;signal"></a>方式二 await&amp;signal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">aw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> aw.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> aw.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> aw.newCondition();<br>        t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            aw.print(<span class="hljs-string">&quot;a&quot;</span>,a,b);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            aw.print(<span class="hljs-string">&quot;b&quot;</span>,b,c);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>        t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            aw.print(<span class="hljs-string">&quot;c&quot;</span>,c,a);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        aw.lock();<br>        a.signal();<br>        aw.unlock();<br>    &#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNum)</span>&#123;<br>        <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition now, Condition next)</span>&#123;<br>       lock();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                now.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.print(str);<br>            next.signal();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式三-park-amp-unpark"><a href="#方式三-park-amp-unpark" class="headerlink" title="方式三 park&amp;unpark"></a>方式三 park&amp;unpark</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Thread t1,t2,t3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ParkUnpark</span> <span class="hljs-variable">waitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParkUnpark</span>(<span class="hljs-number">5</span>);<br>         t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;b&quot;</span>,t3);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>         t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;a&quot;</span>,t2);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>         t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitNotify.print(<span class="hljs-string">&quot;c&quot;</span>,t1);<br>        &#125;,<span class="hljs-string">&quot;t3&quot;</span>);<br><br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        LockSupport.unpark(t1);<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkUnpark</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNum;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParkUnpark</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNum)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNum = loopNum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,Thread thread)</span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNum; i++) &#123;<br><br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(thread);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220327173020587.png" alt="image-20220327173020587"></p><p><img src="/img/mac/image-20220327173031893.png" alt="image-20220327173031893"></p><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="java-内存模型"><a href="#java-内存模型" class="headerlink" title="java 内存模型"></a>java 内存模型</h2><p>jmm 定义了主存和工作内存等抽象概念。</p><ul><li><p>主存，静态成员变量等<strong>共享的数据</strong></p></li><li><p>工作内存，每个线程私有的变量。</p></li></ul><p>底层对应了 cpu 寄存器、缓存、硬件内存、cpu 优化等。</p><ul><li>原子性：保证指令不会受到线程上下文切换的影响</li><li>可见性：保证指令不会受到 cpu 缓存的影响</li><li>有序性：保证指令不会受到 cpu 并行优化的影响</li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (flag)&#123;<br><br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;can print?&quot;</span>);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        flag = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>初始状态，t 线程刚开始从主存读取了 run 的值到工作内存。</li><li>因为 t 线程要频繁的从主内存中读取 run 的值，<strong>即时编译器会将 run 的值缓存至自己工作内存中的高速缓存中</strong>。减少对主存中 run 的访问，提高效率。</li><li>1 秒后，main 线程修改了 run 的值，并同步至主存，而<strong>t 线程是从自己工作内存中的高速缓存中</strong>读取这个变量的值，结果永远是旧值。</li></ol><h3 id="volatile-解决可见性"><a href="#volatile-解决可见性" class="headerlink" title="volatile 解决可见性"></a>volatile 解决可见性</h3><p>它只能修饰<strong>成员变量</strong>和<strong>静态成员变量</strong></p><p>被这个关键字修饰的值就不<strong>能再从缓存中读取</strong>，必须<strong>从主存中获取</strong>。</p><p>解决退不出的循环：可以用 volatile，也可以用 synchronized。把对共享变量的修改放在 synchronized 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用synchronized解决</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                    <span class="hljs-keyword">if</span> (!flag)&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;can print?&quot;</span>);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a>可见性 vs 原子性</h3><p><strong>volatile 适合一个线程修改</strong>共享变量，<strong>多个线程读取</strong>共享变量的情况。</p><p><strong>volatile 只能保证多个线程看到最新值</strong>，但不能保证指令交错，也就是<strong>不能保证原子性，只能保证可见性</strong>。</p><p>以一个线程 i++，一个 i–为例。</p><p><img src="/img/mac/image-20220328142549030.png" alt="image-20220328142549030"></p><p>volatile 只能保证 getstatic 读取的是最新值，但不一定是修改后的值。</p><p><strong>synchronized</strong>语句<strong>既可以保证代码块内的原子性，又可以保证代码块内变量的可见性</strong>，但其缺点是 synchronized 是重量级锁,性能低。</p><h2 id="改进两阶段终止模式"><a href="#改进两阶段终止模式" class="headerlink" title="改进两阶段终止模式"></a>改进两阶段终止模式</h2><p>设置一个 stop 标记，由打断线程将其置为 true；</p><p>符合仅一个线程修改，将其用 volatile 修饰，保证可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Thread thread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (stop)&#123;<br>                    log.debug(<span class="hljs-string">&quot;现在是善后工作&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;执行监控&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.debug(<span class="hljs-string">&quot;在睡眠时被打断，为了更快的善后&quot;</span>);<br>                &#125;<br>            &#125;<br><br><br>        &#125;,<span class="hljs-string">&quot;thread1&quot;</span>);<br>        thread.start();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        thread.interrupt();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="同步模式之犹豫-Balking-模式"><a href="#同步模式之犹豫-Balking-模式" class="headerlink" title="同步模式之犹豫 Balking 模式"></a>同步模式之犹豫 Balking 模式</h2><p>用在一个线程发现<strong>另一个线程或本线程已经做了某一件相同的事</strong>，那么<strong>本线程就无需再做了，直接返回</strong>。</p><p>如何保证一个方法只运行一次，再运行一次就返回？</p><p>以两阶段终止的 start 方法为例。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>前面说的监控是一个；</p><p>它还经常用来实现线程安全的单例。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>jvm 在不影响正确性的前提下，可以调整语句的执行顺序</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static int i<span class="hljs-comment">;</span><br>static int j<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<br><br>指令重排可能变成<br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<br>单线程下可能没问题<br>多线程情况下会出问题<br></code></pre></td></tr></table></figure><h3 id="指令重排优化"><a href="#指令重排优化" class="headerlink" title="指令重排优化"></a>指令重排优化</h3><p>cpu 会把多个指令的不同部分并发的执行，来提高吞吐量。</p><p>执行一条指令的过程：<strong>取指令-指令译码-执行指令-内存访问-数据写回。</strong></p><p>流水线技术并不能缩短单条指令的执行时间，但其变相的提高了指令的吞吐率</p><p><img src="/img/mac/image-20220328151206165.png" alt="image-20220328151206165"></p><p>再来看 java 中的指令重排，其实是跟流水线一样的。这些指令的各个阶段可以通过重排序和组合来实现指令级并行。</p><p>指令重排的前提是，重排指令不能影响结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不能重排</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>　<span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span>&#123;<br>　 <span class="hljs-keyword">if</span>(ready)&#123;<br>　  num = num + num;<br>　 &#125;<span class="hljs-keyword">else</span>&#123;<br>　  num = <span class="hljs-number">1</span>;<br>　 &#125;<br>　&#125;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span>&#123;<br>　<br>num= <span class="hljs-number">2</span>;<br>　ready = <span class="hljs-literal">true</span>;<br>　&#125;<br></code></pre></td></tr></table></figure><p>以上代码中，<strong>最后 num 的值有可能是 0</strong>！</p><p>是因为<strong>在 actor2 中 两段语句发生了重排</strong>，ready = true 先执行。 最后 num = 0+0；</p><h3 id="指令重排的禁用"><a href="#指令重排的禁用" class="headerlink" title="指令重排的禁用"></a>指令重排的禁用</h3><p>在 ready 上<strong>添加一个 volatile</strong>即可。</p><p>为什么不添加在 num 上？</p><p>因为加在 ready 上，能<strong>防止它之前的代码不会被重排序到他后面</strong>。<strong>原理是写屏障</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>　<span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span>&#123;<br>　 <span class="hljs-keyword">if</span>(ready)&#123;<br>　  num = num + num;<br>　 &#125;<span class="hljs-keyword">else</span>&#123;<br>　  num = <span class="hljs-number">1</span>;<br>　 &#125;<br>　&#125;<br>　<br>　<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span>&#123;<br>　<br>num= <span class="hljs-number">2</span>;<br>　ready = <span class="hljs-literal">true</span>;<br>　&#125;<br></code></pre></td></tr></table></figure><h2 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h2><p>volatile 的实现原理是内存屏障</p><ul><li>对 volatile 变量的写指令会加入写屏障</li><li>对 volatile 变量的读指令会加入读屏障</li></ul><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><ul><li>写屏障实例 保证在该屏障之前的，对<strong>共享变量的改动，都同步到主存当中</strong>；例子中就是<strong>ready 的值同步到主存，顺带将 num 的值也同步到主存中</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">()</span>&#123;<br>　<br>   num= <span class="hljs-number">2</span>;<br>　ready = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">//写屏障</span><br>　&#125;<br></code></pre></td></tr></table></figure><ul><li>读屏障 保证在该屏障之后，对共享变量的读取，加载的是主存中最新的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">()</span>&#123;<br>　 <span class="hljs-comment">//读屏障</span><br>　 <span class="hljs-keyword">if</span>(ready)&#123;<br>　  num = num + num;<br>　 &#125;<span class="hljs-keyword">else</span>&#123;<br>　  num = <span class="hljs-number">1</span>;<br>　 &#125;<br>　&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/mac/image-20220328154056508.png" alt="image-20220328154056508"></p><h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><ul><li>写屏障保证指令重排序时，不会将<strong>写屏障之前的代码排在写屏障之后</strong></li><li>读屏障会确保指令重排序时，<strong>不会将读屏障之后的代码排在读屏障前</strong></li></ul><h3 id="不能解决指令交错-原子性"><a href="#不能解决指令交错-原子性" class="headerlink" title="不能解决指令交错-原子性"></a>不能解决指令交错-原子性</h3><ul><li>写屏障<strong>仅仅是保证之后的读能够读取到最新值</strong>，但不能保证读跑到它前面去。</li><li><strong>有序性</strong>的保证也<strong>只是保证本线程相关代码不被重排序</strong></li></ul><h2 id="单例-double-check"><a href="#单例-double-check" class="headerlink" title="单例 double-check"></a>单例 double-check</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)&#123;<br>instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 instance 不加 volatile，上面的代码在多线程环境下还是有问题的。</p><p>第一个 if 语句使用了 instance，没有被 synchronized 保护，会发生<strong>指令重排</strong>问题。</p><p>getInstance 方法的字节码为：</p><p><img src="/img/mac/image-20220328161638346.png" alt="image-20220328161638346"></p><ul><li>17 表示创建对象，将对象引用入栈</li><li>20 表示复制一份对象引用</li><li>21 表示根据引用地址，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>可能 jvm 会将其优化为<strong>先执行 24，后执行 21</strong>。这可能会进一步导致对象的构造方法还没有执行完毕就被 t2 线程拿到了单例对象。</p><p><img src="/img/mac/image-20220328161423924.png" alt="image-20220328161423924"></p><p>关键在于 <strong>0：getstatic 这行代码在 monitor 控制之外</strong>，它可以越过 monitor 读取 INSTANCE 变量的值。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>你可能会疑惑为什么 synchronized 代码块里的对象还会发生重排序呢？</p><p>synchronized 代码块中的代码块依旧有可能是被重排序的。但是如果一个共享变量完全交给 synchronized 保护，那么就完全不会有原子性，可见性，有序性的问题。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>解决方法很简单。<strong>给 INSTANCE 加上 volatile</strong>即可。</p><p>从内存屏障进行分析重排序</p><p><strong>读屏障之后不发生重排，写屏障之前不发生重排</strong>。</p><p>t1 线程对共享变量进行赋值，同时带了写屏障。这就能保证 <strong>赋值和执行构造方法的两条指令不再发生重排序</strong>。所以不会有刚才的问题。</p><p><img src="/img/mac/image-20220328162318395.png" alt="image-20220328162318395"></p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens before"></a>happens before</h2><p>happens before<strong>规定了对共享变量的写操作对其他线程的读可见</strong>，它是可见性与有序性的一套规则。</p><p>太多了，具体看笔记。</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="balking-模式习题"><a href="#balking-模式习题" class="headerlink" title="balking 模式习题"></a>balking 模式习题</h3><h3 id="线程安全单例习题"><a href="#线程安全单例习题" class="headerlink" title="线程安全单例习题"></a>线程安全单例习题</h3><p>饿汉式：类加载时就会导致该单例对象创建</p><p>懒汉式：类加载时不会导致该单例对象被创建，首次使用该对象时才创建</p><h4 id="实验-1-饿汉式"><a href="#实验-1-饿汉式" class="headerlink" title="实验 1 饿汉式"></a>实验 1 饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;&#125;<br><br></code></pre></td></tr></table></figure><p>如果实现了序列化接口，还要做什么来防止反序列化破坏单例？</p><p>可以这么做：在单例类中加个方法；反序列化时就调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">　<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span>&#123;<br>　<span class="hljs-keyword">return</span> INSTANCE;<br>　&#125;<br></code></pre></td></tr></table></figure><p>将构造器设为私有能否防止反射创建新的实例？</p><p>不行，反射可以获得构造器并且把 setaAccessable 为 true。</p><p>饿汉式的初始化能否保证单例创建时的线程安全？</p><p>可以，由 jvm 保证线程安全。</p><p>为什么提供静态方法而不是 public？</p><p>可以使用懒惰式加载；更好的封装性；利用泛型等等。。</p><h4 id="实验-2-枚举"><a href="#实验-2-枚举" class="headerlink" title="实验 2 枚举"></a>实验 2 枚举</h4><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span></span>&#123;<br> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举如何限制实例个数？</p><p>创建时是否有并发问题？</p><p>枚举类的实例实际上就是静态成员变量。</p><p>public final static …</p><p>能否用反射破坏单例？</p><p>不行。</p><p>枚举能否被反序列化破坏单例？</p><p>枚举默认实现序列化接口。但是其在实现中可以避免被反序列化破坏单例。</p><p>枚举是懒汉还是饿汉？</p><p>静态变量，饿汉</p><p>如果希望加入一些单例创建时的初始化怎么做？</p><p>使用构造方法。</p><h4 id="实验-3-懒汉式-doublecheck"><a href="#实验-3-懒汉式-doublecheck" class="headerlink" title="实验 3 懒汉式-doublecheck"></a>实验 3 懒汉式-doublecheck</h4><p>为什么要加 volatile</p><p>解决<strong>synchronized 代码块里指令发生重排序</strong>问题，从而导致线程获取到了<strong>还没调用构造方法的引用</strong>。</p><p>为什么要第二次判断实例是否为空？</p><p>为了避免首次创建对象时的并发问题，如果没有这次判断。单例对象会被多次创建。</p><h4 id="实验-4-懒汉式静态内部类"><a href="#实验-4-懒汉式静态内部类" class="headerlink" title="实验 4 - 懒汉式静态内部类"></a>实验 4 - 懒汉式静态内部类</h4><p>为什么是懒汉？</p><p>类在被使用到才进行加载，对类进行加载，从而进行实例的初始化，所以是懒汉</p><p>创建时并发问题？</p><p>由 jvm 保证线程安全。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/img/mac/image-20220328171654735.png" alt="image-20220328171654735"></p><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><p>先看一个案例</p><p>一个账户 10000 元，</p><p>开 1000 个线程-10 元。账户金额是共享变量，我们知道 synchronized 对其进行保护即可。</p><p>但是先引入一下原子类，用无锁的方式保证并发。</p><h2 id="无锁实现对比有锁实现"><a href="#无锁实现对比有锁实现" class="headerlink" title="无锁实现对比有锁实现"></a>无锁实现对比有锁实现</h2><p>AtoInteger 套路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>　(<span class="hljs-literal">true</span>)&#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br> <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br> <span class="hljs-comment">//比较并设置</span><br> <span class="hljs-keyword">if</span>(balance.compareAndSet(prev,next))&#123;<br>    <span class="hljs-keyword">break</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CAS-与-volatile"><a href="#CAS-与-volatile" class="headerlink" title="CAS 与 volatile"></a>CAS 与 volatile</h2><h3 id="CAS-原理"><a href="#CAS-原理" class="headerlink" title="CAS 原理"></a>CAS 原理</h3><p>上例中关键的是 compareAndSet<strong>比较并交换</strong>。他简称就是 cas，cas 这个操作是原子的，由 cpu 来保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>　(<span class="hljs-literal">true</span>)&#123;<br> <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br> <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br> <span class="hljs-comment">//比较并设置</span><br> <span class="hljs-keyword">if</span>(balance.compareAndSet(prev,next))&#123;<br>    <span class="hljs-keyword">break</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>balance.compareAndSet(prev,next)是将<strong>prev 参数和 balance 里维护的 value</strong>对比，如果值不一样就返回 false。</p><ul><li>CAS 的底层是 lock cmpxchg 指令，在单核和多核 cpu 下都能保证【比较-交换】的原子性</li><li>多核状态下，某个核执行到带 lock 的指令时，cpu 会让总线锁住，当这个核把此指令执行完毕再开启总线。 这个过程不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><h3 id="volatile-cas"><a href="#volatile-cas" class="headerlink" title="volatile-cas"></a>volatile-cas</h3><p>cas 操作<strong>必须配合</strong>volatile。每次 cas 需要保证读取到共享变量的最新值。</p><p>AtomicInteger 里面就维护了一个 volatile 修饰的共享变量 value。</p><h3 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h3><ul><li>无锁情况下，<strong>即使重试失败，线程仍然在运行</strong>；而 synchronized 会让线程进入阻塞状态，发生<strong>上下文切换</strong>，上下文切换的代价是很大的。</li><li>无锁情况下，因为线程要保持运行，需要多核 cpu 支持。让线程数小于 cpu 核心数，否则一样会发生上下文切换</li></ul><h3 id="cas-的特点"><a href="#cas-的特点" class="headerlink" title="cas 的特点"></a>cas 的特点</h3><ul><li>无锁并发，适用于线程数少，多核 cpu 的场景</li><li>cas 是基于乐观锁的思想；不怕别的线程来修改共享变量，就算改了，大不了就吃点亏重试</li><li>cas 体现的是无锁并发，无阻塞并发<ul><li>因为没有使用 synchronized，所以线程不会进入阻塞，是效率提升的因素之一</li><li>但如果竞争激烈，重试必然频繁发生，反而效率会受到影响。</li></ul></li></ul><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ul><li>AtomicInteger</li><li>AtomicBoolean</li><li>AtomicLong</li></ul><p>三者差不多，以 AtomicInteger 为例。</p><ul><li>compareAndSet 方法</li><li>incrementAndGet 自增并获取值等价于 ++i</li><li>getAndIncrement 先获取值后自增，等价于 i++</li><li>decrementAndGet –i 同上</li><li>getAndDecrement i–同上</li></ul><p>上面的操作都可以认为是原子的。利用 cas 保证安全性。后面的方法也一样。</p><ul><li>getAndAdd(5) 先获取后增加</li><li>addAndGet(5) 先增加后获取</li></ul><p>用这两个方法改进取款。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">不用之前的<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> + compareAndSet<br>直接<br>balance.addAndGet(-<span class="hljs-number">1</span>*amount);<br>结束<br></code></pre></td></tr></table></figure><ul><li>updateAndGet(IntUnaryOperation updateFunction)</li></ul><p>这个参数是什么？是一个<strong>函数式接口</strong>。<strong>里面的方法是一个 int 类型的参数（自身维护的 value 值），返回 int 类型的值（运算后得到的值）</strong>。</p><p>用这个方法可以实现乘除运算，同样保证原子操作。</p><h3 id="模拟-updateAndGet-原理"><a href="#模拟-updateAndGet-原理" class="headerlink" title="模拟 updateAndGet 原理"></a>模拟 updateAndGet 原理</h3><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> operator(prev);<br>  <span class="hljs-keyword">if</span>(balance.compareAndSet(prev,next))&#123;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把上面的代码块模拟成方法</p><p>把<strong>对数值的操作当作接口</strong>传递进来。IntUnaryOperator, unary 是一元的意思，表示一个参数。</p><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>如果想保护如 BigDecimal 等小数类型的原子性，可以用原子引用。</p><ul><li>AtoReference</li><li>AtoMarkableReference</li><li>AtomicStampedReference</li></ul><h3 id="AtoReference"><a href="#AtoReference" class="headerlink" title="AtoReference"></a>AtoReference</h3><p>依旧以账户转账为例，金额用 bigdecimal，共享变量用 AtomicReference&lt;&gt;。</p><p>依旧是 compare and set 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicRefeAccount</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicRefeAccount</span><span class="hljs-params">(AtomicReference&lt;BigDecimal&gt; ato)</span>&#123;<br>        <span class="hljs-built_in">this</span>.balance = ato;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withDraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(prev);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev,next))&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>CAS 仅仅只是判断共享变量前后是否一致，但是能不能判断被其他线程修改过？</p><p><strong>并不能</strong></p><p>主线程想把 A 改成 C; 如果另外两个线程把 a 改成 b，又让 b 变回 a；主线程是无法感知到这一情况的，一样会把 a 改成 c。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicReference&lt;String&gt; ato = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;a&quot;</span>);<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>))&#123;<br>                    log.debug(<span class="hljs-string">&quot;a to b&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>))&#123;<br>                    log.debug(<span class="hljs-string">&quot;b to a&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;).start();<br><br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;a to c&quot;</span>);<br></code></pre></td></tr></table></figure><p>解决？</p><p>只要有其他线程动过了共享变量，那么自己的 cas 就算失败，<strong>仅仅比较值是不够的，需要添加一个<u>版本号</u></strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><ul><li>getStamp   获取版本号</li><li>compareAndSet 额外的两个参数，是之前的版本号和更新后的版本号（+1）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">AtomicStampedReference&lt;String&gt; ato = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">0</span>);<br><br><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>               <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))&#123;<br>                   log.debug(<span class="hljs-string">&quot;a to b&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br><br>       &#125;).start();<br><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>           <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>               <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))&#123;<br>                   log.debug(<span class="hljs-string">&quot;b to a&quot;</span>);<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br><br>       &#125;).start();<br><br>       Sleeper.sleep(<span class="hljs-number">1</span>);<br>       <span class="hljs-keyword">if</span> (ato.compareAndSet(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>       log.debug(<span class="hljs-string">&quot;a to c&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="AtoMarkableReference"><a href="#AtoMarkableReference" class="headerlink" title="AtoMarkableReference"></a>AtoMarkableReference</h3><p>通过 AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，<strong>我们不关心被更改了几次，只关心是否被更改了</strong>。</p><p>就可以用<strong>AtoMarkableReference</strong>，用一个 bool 变量维护状态是否改变</p><p><img src="/img/mac/image-20220329101713577.png" alt="image-20220329101713577"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>原子引用如 AtomicReference 修改的是引用本身，如果我们想引用里面的值。如数组，我们想修改数组里的元素。</p><p>则 Atomic reference 就不能进行对数组里面的值修改的保护。</p><p>由此引出原子数组。</p><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><p>Supplier ： 无中生有，没有参数，一个结果</p><p>Function ： 一个参数，一个结果</p><p>BiFunction：两个参数，一个结果</p><p>Consumer： 一个参数，没有结果</p><p>BiConsumer： 两个参数，没有结果</p><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>Test39.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>                    array -&gt; array.length,<br>                    (array,index)-&gt; array[index]++,<br>                    array -&gt; System.out.println(Arrays.toString(array))<br><br>            );<br>        &#125;<br><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>                    array -&gt; array.length(),<br>                    (array,index)-&gt; array.incrementAndGet(index),<br>                    array -&gt; System.out.println(array.toString())<br><br>            );<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    supplier : 提供数组</span><br><span class="hljs-comment">    function : 提供数组长度</span><br><span class="hljs-comment">    BiConsumer : 数组操作</span><br><span class="hljs-comment">    consumer : 打印数组</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; supplier,</span><br><span class="hljs-params">            Function&lt;T,Integer&gt; function,</span><br><span class="hljs-params">            BiConsumer&lt;T,Integer&gt; biConsumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; consumer</span><br><span class="hljs-params"></span><br><span class="hljs-params">    )</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> supplier.get();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> function.apply(array);<br>        List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//开10个线程，每个线程10000次累加 最后应该要有10个10000</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    biConsumer.accept(array,j%length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        list.forEach(thread -&gt; thread.start());<br>        list.forEach(thread -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.print((end-start)+<span class="hljs-string">&quot; &quot;</span>);<br>        consumer.accept(array);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><p>利用字段更新器，可以针对对象的某个域进行原子操作，<strong>只能配合 volatile 修饰的字段使用</strong>，否则出现异常。</p><ul><li>AtomicReferenceFieldUpdater</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">studnet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;san&quot;</span>);<br>AtomicReferenceFieldUpdater&lt;Student, String&gt; updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br>updater.compareAndSet(studnet,<span class="hljs-string">&quot;san&quot;</span>,<span class="hljs-string">&quot;sisis&quot;</span>);<br>System.out.println(studnet);<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-keyword">volatile</span> String name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name= name;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h2><h3 id="基本介绍-amp-感受"><a href="#基本介绍-amp-感受" class="headerlink" title="基本介绍&amp;感受"></a>基本介绍&amp;感受</h3><ul><li>LongAdder</li><li>LongAccumulater</li></ul><p>Test41.java</p><p>Supplier 提供累加器对象</p><p>Consumer 执行累计操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>(),<br>                    adder -&gt; adder.increment(),<br>                    longAdder -&gt; System.out.println(longAdder.longValue())<br>            );<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            demo(<br>                    ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>),<br>                    adder -&gt; adder.getAndIncrement(),<br>                    adder -&gt; System.out.println(adder.get())<br><br>            );<br>        &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>&lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; supplier,</span><br><span class="hljs-params">            Consumer&lt;T&gt; consumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; printConsumer</span><br><span class="hljs-params">    )</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">adder</span> <span class="hljs-operator">=</span> supplier.get();<br>        List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000000</span>; j++) &#123;<br>                    consumer.accept(adder);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br><br>        list.forEach(Thread::start);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Thread thread : list) &#123;<br>                thread.join();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        System.out.print(<span class="hljs-string">&quot;costTime:&quot;</span>+((end-start)/<span class="hljs-number">1000000</span>) +<span class="hljs-string">&quot;,&quot;</span>);<br>        printConsumer.accept(adder);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="性能提升的原因"><a href="#性能提升的原因" class="headerlink" title="性能提升的原因"></a>性能提升的原因</h3><ul><li>普通原子类</li></ul><p>多个线程对共享变量进行++操作，必然导致重试次数变多，导致性能下降</p><ul><li><p>累加器</p><p>在有竞争的时候，设置<strong>多个累加单元（</strong>多个共享变量），它们在累加时操作不同的共享变量（叫 cell），因此减少了 CAS 的重试，从而提高性能</p></li></ul><h3 id="LongAdder-源码"><a href="#LongAdder-源码" class="headerlink" title="LongAdder 源码"></a>LongAdder 源码</h3><p>//累加单元数组，懒惰初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br></code></pre></td></tr></table></figure><p>//基础值，如果没竞争，则累加这个域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br></code></pre></td></tr></table></figure><p>// 在 cells 创建或扩容时，置为 1，表示加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><p>transient 表示不会被序列化</p><h4 id="用-CAS“加锁”-“解锁”"><a href="#用-CAS“加锁”-“解锁”" class="headerlink" title="用 CAS“加锁” “解锁”"></a>用 CAS“加锁” “解锁”</h4><p>LockCas.java</p><p>这就是 cellsBusy 的原理</p><h4 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h4><p>//防止缓存行伪共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span><br></code></pre></td></tr></table></figure><p>//最重要的方法，用来 cas 方式进行累加，cmp 表示旧值，val 新值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> cmp, <span class="hljs-type">long</span> val)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, cmp, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>什么是缓存行？</strong></p><p>cpu 有寄存器，一缓/二缓/三缓。再然后是内存。</p><p><img src="/img/mac/image-20220329111538879.png" alt="image-20220329111538879"></p><p>cpu 读取数据的速度：</p><p><img src="/img/mac/image-20220329111457024.png" alt="image-20220329111457024"></p><p>因为 cpu 和内存交互较慢，需要靠预读数据到缓存来提升效率。而<strong>缓存以缓存行为单位</strong>，每个缓存行对应着一块内存，一般是 64byte（8 个 long）。</p><p><strong>数据一致性问题</strong></p><p>如果<strong>一个核心对某个缓存行上的数据做了修改</strong>，会让其他核心<strong>对应的缓存行失效</strong>。cpu 要<strong>保证数据的一致性</strong>，必须要重新从内存中读取数据。</p><p>接着来看 cells 的具体实现</p><p>线程 1 和线程 2 的一个缓存行先从内存中读取 2 个 cell 对象，</p><p><img src="/img/mac/image-20220329112339269.png" alt="image-20220329112339269"></p><p>因为 cell 是数组形式，在内存中是连续存储的，一个 cell 为 24 字节（16 字节对象头+8 字节的 value） ， 因此缓存行可以存下 2 个 cell 对象。</p><p>问题来了</p><ul><li>core-0 要修改 cell[0]</li><li>core-1 要修改 cell[1]</li></ul><p>无论谁修改成功，都会导致对方的 core 的缓存行失效，要重新去内存中读取，这就导致了性能的下降。</p><p>解决，让<strong>它们处于不同的缓存行</strong>。</p><p>将 cell[0]放在一个缓存行，将 cell[1]放在另一个缓存行。</p><p>@sun.misc.Contented 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>，从而<strong>让 cpu 将对象预读至缓存时占用不同的缓存行</strong>，这样不会造成对方的缓存行的失效。</p><p><img src="/img/mac/image-20220329113043453.png" alt="image-20220329113043453"></p><p>再总结//防止缓存行伪共享</p><p>由于一个缓存行加入多个 cell 对象叫做伪共享，这个注解就是防止缓存行伪共享。</p><h4 id="原理之-add"><a href="#原理之-add" class="headerlink" title="原理之 add"></a>原理之 add</h4><p>先判断 cells 是否为空；</p><p>cells 为空：</p><ul><li>为基础累加值 cas base 累加；<ul><li>基础累加值累加成功，return；</li><li>基础累加值累加失败，进入 longAccumulate 方法；</li></ul></li></ul><p>cells 不为空 说明有竞争存在：</p><ul><li>判断当前线程有没有对应的 cell 已经被创建<ul><li>没创建，进入 longAccumulate 方法</li><li>创建了<ul><li>cas cell 累加<ul><li>成功，return；</li><li>失败，进入 longAccumulate 方法；</li></ul></li></ul></li></ul></li></ul><p><img src="/img/mac/image-20220329114825181.png" alt="image-20220329114825181"></p><p>源码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h4 id="原理之-longAccumulate"><a href="#原理之-longAccumulate" class="headerlink" title="原理之 longAccumulate"></a>原理之 longAccumulate</h4><ul><li>cells 不存在&amp;未加锁&amp;未新建，对应第二个和第三个大 elseif</li></ul><p><img src="/img/mac/image-20220329151110499.png" alt="image-20220329151110499"></p><ul><li>cells 存在&amp;cell 没创建，对应第一个大 if</li></ul><p><img src="/img/mac/image-20220329151831542.png" alt="image-20220329151831542"></p><ul><li>cells 存在&amp;cell 已创建</li></ul><h4 id="原理之-sum-方法"><a href="#原理之-sum-方法" class="headerlink" title="原理之 sum 方法"></a>原理之 sum 方法</h4><h2 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h2><h3 id="unsafe-获取"><a href="#unsafe-获取" class="headerlink" title="unsafe 获取"></a>unsafe 获取</h3><p>unsafe 对象提供了<strong>非常底层的，操作内存，操作线程的方法。</strong></p><p>unsafe 对象不能直接调用，<strong>只能通过反射获得</strong>。</p><p>我们要获得的 Unsafe.Class 的一个成员变量的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//因为是静态成员变量，所以不需要传入实例对象</span><br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> unsafe;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="unsafe-cas-操作"><a href="#unsafe-cas-操作" class="headerlink" title="unsafe cas 操作"></a>unsafe cas 操作</h3><ol><li>从 Teacher 类中获取域的偏移地址 objectFieldOffset</li><li>执行 cas 操作 compareAndSet</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> UnsafeUtil.getUnsafe();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(field);<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>);<br>        unsafe.compareAndSwapObject(teacher,offset,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;zn&quot;</span>);<br>        System.out.println(teacher);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="模拟原子整数类"><a href="#模拟原子整数类" class="headerlink" title="模拟原子整数类"></a>模拟原子整数类</h3><p>// 1. 获取 unsafe 类，做成 util 包</p><p>//2.需要一个 value</p><p>//3.计算 value 对于类的偏移量</p><p>//4.实现 getVal 和 decrement 方法（compareAndSet）方法</p><p>最后，在减钱实例上测试一下。</p>]]></content>
    
    
    <categories>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/04/12/os/"/>
    <url>/2022/04/12/os/</url>
    
    <content type="html"><![CDATA[<h1 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h1><h2 id="从用户角度来看"><a href="#从用户角度来看" class="headerlink" title="从用户角度来看"></a>从用户角度来看</h2><p><img src="/img/mac/image-20220314101541245.png" alt="image-20220314101541245"></p><h2 id="操作系统的层次架构"><a href="#操作系统的层次架构" class="headerlink" title="操作系统的层次架构"></a>操作系统的层次架构</h2><p><img src="/img/mac/image-20220314101702771.png" alt="image-20220314101702771"></p><h2 id="os-kernel-和-shell"><a href="#os-kernel-和-shell" class="headerlink" title="os kernel 和 shell"></a>os kernel 和 shell</h2><p><img src="/img/mac/image-20220314102014485.png" alt="image-20220314102014485"></p><p>shell 可以理解为操作系统提供的对外进行管理的接口。我们要学习的是操作系统的 kernel。</p><h2 id="kernel-要管理的硬件"><a href="#kernel-要管理的硬件" class="headerlink" title="kernel 要管理的硬件"></a>kernel 要管理的硬件</h2><p><img src="/img/mac/image-20220314100629747.png" alt="image-20220314100629747"></p><h2 id="os-Kernel-的特征"><a href="#os-Kernel-的特征" class="headerlink" title="os Kernel 的特征"></a>os Kernel 的特征</h2><ul><li>并行：一个时间点上有多个程序执行，一般要求多核 cpu。但是 kernel 的特征是并发。并发是一段时间内有多个程序执行。</li><li>虚拟：操作系统将 cpu 抽象成进程，将磁盘抽象成文件，将内存抽象成地址空间。</li></ul><p><img src="/img/mac/image-20220314095722816.png" alt="image-20220314095722816"></p><ul><li>异步：需要保证结果相同，1+1 一定也是等于 2 的。</li><li><img src="/img/mac/image-20220314101327083.png" alt="image-20220314101327083"></li></ul><h2 id="操作系统需要从更高的角度来学习。"><a href="#操作系统需要从更高的角度来学习。" class="headerlink" title="操作系统需要从更高的角度来学习。"></a>操作系统需要从更高的角度来学习。</h2><p><img src="/img/mac/image-20220314103806052.png" alt="image-20220314103806052"></p><h2 id="调度线程，多道程序设计，分时操作的基本介绍"><a href="#调度线程，多道程序设计，分时操作的基本介绍" class="headerlink" title="调度线程，多道程序设计，分时操作的基本介绍"></a>调度线程，多道程序设计，分时操作的基本介绍</h2><p>我们知道，io 的效率远远低于 cpu 的效率，当 cpu read disk 的时候，可以去执行其他程序。这是多道程序设计。</p><p><img src="/img/mac/image-20220314105742354.png" alt="image-20220314105742354"></p><p>分时操作的时间，把每个程序持有时间片的时间大大减少，如千分之一秒，随后不断的打断程序。</p><p>分时操作的好处：</p><p><img src="/img/mac/image-20220314110510820.png" alt="image-20220314110510820"></p><h1 id="第二课-启动，中断，异常和系统调用"><a href="#第二课-启动，中断，异常和系统调用" class="headerlink" title="第二课-启动，中断，异常和系统调用"></a>第二课-启动，中断，异常和系统调用</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>Bootloader 的作用:加载 os 到内存中</p><p>bios 是用来对一些硬件的处理</p><p><img src="/img/mac/image-20220314112645043.png" alt="image-20220314112645043"></p><h3 id="启动的过程"><a href="#启动的过程" class="headerlink" title="启动的过程"></a>启动的过程</h3><p>x86 架构中，bios 从如图所示的这个地址开始执行</p><p><img src="/img/mac/image-20220314112823551.png" alt="image-20220314112823551"></p><p>Bios 自检，加载硬件驱动</p><p><img src="/img/mac/image-20220314112916863.png" alt="image-20220314112916863"></p><p>自检后，将 boot loader 从硬盘的第一个扇区加载到内存。boot loader 又接着把 os 从硬盘加载到内存中。</p><p><img src="/img/mac/image-20220314113334784.png" alt="image-20220314113334784"></p><h2 id="系统调用，中断，异常"><a href="#系统调用，中断，异常" class="headerlink" title="系统调用，中断，异常"></a>系统调用，中断，异常</h2><h3 id="os-分别与硬件和程序打交道有以下几种形式："><a href="#os-分别与硬件和程序打交道有以下几种形式：" class="headerlink" title="os 分别与硬件和程序打交道有以下几种形式："></a>os 分别与硬件和程序打交道有以下几种形式：</h3><ul><li>对硬件采用中断</li><li>对应用程序采用系统调用和异常</li></ul><h3 id="他们的定义："><a href="#他们的定义：" class="headerlink" title="他们的定义："></a>他们的定义：</h3><p>异常是应用程序意想不到的行为，或者是恶意程序，又或是程序的资源得不到满足，这都应该被操作系统及时发现；</p><p><img src="/img/mac/image-20220314113712026.png" alt="image-20220314113712026"></p><h3 id="为什么应用程序不能直接和硬件打交道？"><a href="#为什么应用程序不能直接和硬件打交道？" class="headerlink" title="为什么应用程序不能直接和硬件打交道？"></a>为什么应用程序不能直接和硬件打交道？</h3><p>应用程序可能不被信任；操作系统封装了对 device 的操作，只开放接口，不用关注硬件的细节；</p><p><img src="/img/mac/image-20220314114124892.png" alt="image-20220314114124892"></p><h3 id="系统调用-中断-异常的特点和差异"><a href="#系统调用-中断-异常的特点和差异" class="headerlink" title="系统调用/中断/异常的特点和差异"></a>系统调用/中断/异常的特点和差异</h3><ul><li>产生的源头不同</li></ul><p><img src="/img/mac/image-20220314114350433.png" alt="image-20220314114350433"></p><ul><li>处理时间</li></ul><p>异步是当事件产生的时候，应用程序根本不知道什么时候会产生；</p><p>异常是同步的，异常的指令触发了系统调用的请求，指令的位置是一个同步的时间点，是同步的；</p><p>系统调用中，返回结果的这个时间可能是同步（应用程序等待结果）；也可能是异步（应用程序接着去干其他事，然后 os 会发一个异步的消息告诉应用程序我事干完了）；请求调用的这个时间点是同步的。</p><p><img src="/img/mac/image-20220314114700639.png" alt="image-20220314114700639"></p><ul><li>响应</li></ul><p><img src="/img/mac/image-20220314115723694.png" alt="image-20220314115723694"></p><h3 id="中断和异常的处理机制"><a href="#中断和异常的处理机制" class="headerlink" title="中断和异常的处理机制"></a>中断和异常的处理机制</h3><h4 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h4><p><img src="/img/mac/image-20220314185910289.png" alt="image-20220314185910289"></p><p>cpu 根据这个标记能够生成一个中断号，将其发给 os，os 根据中断号来进行处理。</p><p><img src="/img/mac/image-20220314190108570.png" alt="image-20220314190108570"></p><p>可以看到对程序是透明的。</p><h4 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h4><p><img src="/img/mac/image-20220314190325342.png" alt="image-20220314190325342"></p><p>发生异常后，也会产生一个异常编号，和上面中断的情况是类似的。如果异常处理中是重新执行异常指令，那么这个行为对程序来说也是透明的。</p><h3 id="系统调用的执行过程"><a href="#系统调用的执行过程" class="headerlink" title="系统调用的执行过程"></a>系统调用的执行过程</h3><p>简单的例子：os 开放一个接口给程序。</p><p><img src="/img/mac/image-20220314190601181.png" alt="image-20220314190601181"></p><p><img src="/img/mac/image-20220314190746834.png" alt="image-20220314190746834"></p><p><img src="/img/mac/image-20220314185630289.png" alt="image-20220314185630289"></p><p>app 应用程序通过 library code 直接或者间接访问系统调用的接口，同时完成用户态转变内核态。</p><p>用户态：无法执行特权指令和 io 指令，无法控制计算机系统。</p><p>内核态：可以执行任意一个 os 指令。</p><p>开销：因为要完成堆栈的切换和特权级的转换，所以调用操作系统接口比普通函数的执行开销要更大。</p><h2 id="跨越操作系统边界的开销"><a href="#跨越操作系统边界的开销" class="headerlink" title="跨越操作系统边界的开销"></a>跨越操作系统边界的开销</h2><p><img src="/img/mac/image-20220314191904592.png" alt="image-20220314191904592"></p><p>保证了应用程序在安全可靠的环境中执行，开销是值得的。</p><h1 id="第三课-操作系统管理物理内存"><a href="#第三课-操作系统管理物理内存" class="headerlink" title="第三课 操作系统管理物理内存"></a>第三课 操作系统管理物理内存</h1><h2 id="计算机体系结构-内存分层体系"><a href="#计算机体系结构-内存分层体系" class="headerlink" title="计算机体系结构/内存分层体系"></a>计算机体系结构/内存分层体系</h2><p><img src="/img/mac/image-20220314192233279.png" alt="image-20220314192233279"></p><p>cpu 要访问的指令在什么地方</p><ul><li><p>L1 L2 Cache - cpu 内部。缓存小，高速</p></li><li><p>主存 速度相对 cache 慢，内存大</p></li></ul><p><img src="/img/mac/image-20220314192425671.png" alt="image-20220314192425671"></p><p>操作系统内核做的事情-4 个。</p><p><img src="/img/mac/image-20220314192743746.png" alt="image-20220314192743746"></p><p>内存不够的时候，会把不常用的数据临时的放在磁盘上，变成虚拟内存。</p><p><img src="/img/mac/image-20220314193111494.png" alt="image-20220314193111494"></p><h2 id="地址空间-amp-地址生成"><a href="#地址空间-amp-地址生成" class="headerlink" title="地址空间&amp;地址生成"></a>地址空间&amp;地址生成</h2><h3 id="地址空间定义"><a href="#地址空间定义" class="headerlink" title="地址空间定义"></a>地址空间定义</h3><p>物理地址空间，主存上相应的位置</p><p>逻辑地址空间-&gt;应用程序看到的一个一维的地址空间，是易于访问的。</p><p>操作系统：逻辑地址空间会由 os 映射到物理地址空间上。</p><p><img src="/img/mac/image-20220314193313426.png" alt="image-20220314193313426"></p><h3 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h3><h4 id="逻辑地址生成"><a href="#逻辑地址生成" class="headerlink" title="逻辑地址生成"></a>逻辑地址生成</h4><p>c 程序，汇编中函数的位置，变量的名字就是逻辑地址。他是一个便于用户理解的地址。</p><p><img src="/img/mac/image-20220314193627988.png" alt="image-20220314193627988"></p><p>.o 文件中，把逻辑地址改为相对从 0 开始的地址。链接过程把多个.o 文件的合成一个.exe 文件。放在硬盘中的 exe 还要通过 loader 程序加载到内存中，图中最后一个图还有一个相应的偏移量。到这里为止都还是逻辑地址，是应用程序看到的地址。</p><p>总结：编译器把基于符号的地址空间变成基于逻辑地址的地址空间，操作系统可以进一步完成逻辑地址到物理地址的映射。</p><h4 id="物理地址生成"><a href="#物理地址生成" class="headerlink" title="物理地址生成"></a>物理地址生成</h4><p>1:cpu 把指令取出来，他的 ALU 部件需要参数，所以把指令中的逻辑地址交给 MMU。</p><p>2:MMU 根据地址转换表来查逻辑地址对应的物理地址，如果有那就返回；</p><p>3:如果没有，就会去内存中的 map 中找，如果找到了，cpu 就给主存发信息表示我要某个物理地址的内容，</p><p>4:内存把该内容通过总线传给 cpu。</p><p>操作系统在其中的作用：在这四步之前，生成逻辑地址和物理地址转换表。</p><p><img src="/img/mac/image-20220314194436384.png" alt="image-20220314194436384"></p><h3 id="地址安全检查"><a href="#地址安全检查" class="headerlink" title="地址安全检查"></a>地址安全检查</h3><p><img src="/img/mac/image-20220314195201347.png" alt="image-20220314195201347"></p><p>操作系统确保每一个程序可以访问的地址空间，包括起始地址和长度，如果超过这块空间，就会报 system memory error</p><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p><img src="/img/mac/image-20220314195618170.png" alt="image-20220314195618170"></p><p><img src="/img/mac/image-20220314195742024.png" alt="image-20220314195742024"></p><h4 id="首次适配算法"><a href="#首次适配算法" class="headerlink" title="首次适配算法"></a>首次适配算法</h4><p><img src="/img/mac/image-20220314195837235.png" alt="image-20220314195837235"></p><p>可用空闲空间分别是 1k 2k 500 bytes</p><p><img src="/img/mac/image-20220314200013810.png" alt="image-20220314200013810"></p><p>优点</p><ul><li>简单</li><li>易于产生更大空闲块，向着地址空间的结尾</li></ul><p>劣势</p><ul><li>外部碎片 多次使用之后更为明显</li><li>不确定性</li></ul><h4 id="最优适配算法"><a href="#最优适配算法" class="headerlink" title="最优适配算法"></a>最优适配算法</h4><p><img src="/img/mac/image-20220314200259134.png" alt="image-20220314200259134"></p><p>可以看出，空闲的 100 很难再被使用到了。</p><p><img src="/img/mac/image-20220314200333132.png" alt="image-20220314200333132"></p><h4 id="最差适配算法"><a href="#最差适配算法" class="headerlink" title="最差适配算法"></a>最差适配算法</h4><p><img src="/img/mac/image-20220314200523542.png" alt="image-20220314200523542"></p><p><img src="/img/mac/image-20220314200559358.png" alt="image-20220314200559358"></p><p>三个算法总结：三个算法里，没有最好的。每个应用程序不同，需求也不同，是随机的可变的。不论哪种算法，都会产生内/外碎片。</p><p>这三种的办法产生的碎片如何处理？下面介绍 2 种</p><h4 id="压缩式碎片整理"><a href="#压缩式碎片整理" class="headerlink" title="压缩式碎片整理"></a>压缩式碎片整理</h4><p><img src="/img/mac/image-20220314201008316.png" alt="image-20220314201008316"></p><p>紧致的方式，把内存空间压缩</p><p><img src="/img/mac/image-20220314201033083.png" alt="image-20220314201033083"></p><p>什么时候做这个行为？</p><p>把程序从一个地方挪到另一个地方。</p><p>开销如何？</p><p>频繁的拷贝，开销是很大的。</p><h4 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h4><p><img src="/img/mac/image-20220314201309131.png" alt="image-20220314201309131"></p><p>这时 p3 需要更多的内存，把 p4 所占的 memory 暂时放到 disk 上，让 p3 正常执行。</p><p>问题</p><p>把哪一个程序换出去？</p><p>什么时候换入换出？</p><p>开销？</p><p>换入换出是以一个程序为粒度，开销也是很大的。</p><h1 id="第四课-非连续内存管理"><a href="#第四课-非连续内存管理" class="headerlink" title="第四课 非连续内存管理"></a>第四课 非连续内存管理</h1><h2 id="为什么需要非连续内存"><a href="#为什么需要非连续内存" class="headerlink" title="为什么需要非连续内存"></a>为什么需要非连续内存</h2><p><img src="/img/mac/image-20220314202303944.png" alt="image-20220314202303944"></p><p><img src="/img/mac/image-20220314202337631.png" alt="image-20220314202337631"></p><p>解决内外碎片等等。</p><p><img src="/img/mac/image-20220314202419821.png" alt="image-20220314202419821"></p><p>软件的开销较大，考虑硬件。</p><h2 id="如何管理非连续内存"><a href="#如何管理非连续内存" class="headerlink" title="如何管理非连续内存"></a>如何管理非连续内存</h2><p><img src="/img/mac/image-20220314202502565.png" alt="image-20220314202502565"></p><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><h4 id="程序的分段地址空间"><a href="#程序的分段地址空间" class="headerlink" title="程序的分段地址空间"></a>程序的分段地址空间</h4><p><img src="/img/mac/image-20220314202745466.png" alt="image-20220314202745466"></p><p>应用程序自己往往也会有多个不同的逻辑段。</p><p>比如 jvm 中，也有 heap，stack，native stack，pc register，method area 多个不同的段。</p><p>可以把他们相应的分离出来。</p><p><img src="/img/mac/image-20220314202821052.png" alt="image-20220314202821052"></p><p>左边是连续的虚拟地址，右边是</p><p>不连续的物理地址。</p><p><img src="/img/mac/image-20220314203014295.png" alt="image-20220314203014295"></p><h4 id="分段寻址方案"><a href="#分段寻址方案" class="headerlink" title="分段寻址方案"></a>分段寻址方案</h4><p>段访问机制，用硬件来实现</p><p><img src="/img/mac/image-20220314203133547.png" alt="image-20220314203133547"></p><p>从一维的逻辑地址空间通过段访问机制映射到不同的物理地址中去。而这些物理地址是由不同的段组成的。</p><p>硬件实现方案</p><p><img src="/img/mac/image-20220314203451738.png" alt="image-20220314203451738"></p><p>其中段号就等于段表的索引，即 segment num。段表中包含了物理地址的起始位置和长度，从而确定相应的段在物理地址中的哪一块，如果不在合法的范围内，cpu 就会报一个异常让操作系统来 kill 或者重新执行该指令。</p><p>其中关键的是，这个段表就是由操作系统来生成的。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>目前主流的机制，分段已经用的很少了。现在往往都是以分页的形式来解决非连续内存管理。</p><h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>页的大小往往是固定不变的。</p><p><img src="/img/mac/image-20220315101750899.png" alt="image-20220315101750899"></p><p>逻辑页和物理页的大小是相等的。</p><p><img src="/img/mac/image-20220315101830624.png" alt="image-20220315101830624"></p><h5 id="物理地址页帧"><a href="#物理地址页帧" class="headerlink" title="物理地址页帧"></a>物理地址页帧</h5><p><img src="/img/mac/image-20220315102008501.png" alt="image-20220315102008501"></p><p>9bit 是页帧内的偏移，7 个 bit 是帧号的大小</p><p><img src="/img/mac/image-20220315102313425.png" alt="image-20220315102313425"></p><h5 id="逻辑地址页-page"><a href="#逻辑地址页-page" class="headerlink" title="逻辑地址页 page"></a>逻辑地址页 page</h5><p><img src="/img/mac/image-20220315102541329.png" alt="image-20220315102541329"></p><p>计算过程和物理地址是一样的。</p><h4 id="页寻址方案"><a href="#页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案</h4><p>页号作为索引查找 page table 页表，page table 里面的内容是帧号。</p><p>得到帧号后，再加上偏移地址就能得到物理地址。</p><p>类似的，页表也是由操作系统来生成的。</p><p><img src="/img/mac/image-20220315102912248.png" alt="image-20220315102912248"></p><p>注：逻辑地址的页和页帧大小一致，但逻辑地址更大，后面会介绍虚拟内存来解决二者大小不一致问题。</p><p><img src="/img/mac/image-20220315103100186.png" alt="image-20220315103100186"></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="页表-pagetable-的结构和优化"><a href="#页表-pagetable-的结构和优化" class="headerlink" title="页表 pagetable 的结构和优化"></a>页表 pagetable 的结构和优化</h3><p><img src="/img/mac/image-20220315103420007.png" alt="image-20220315103420007"></p><p>其中 flags 包括这个物理页帧是否存在，是否写过读过等。后面会再具体介绍。</p><p>逻辑地址空间有 16bit，64kb，而物理地址只有 32kb。所以，物理页帧无法和逻辑页一一对应。</p><p>resident bit 为 0 表示对应的物理页帧在内存中不存在，如果被 cpu 访问了会报异常。</p><p><img src="/img/mac/image-20220315103911075.png" alt="image-20220315103911075"></p><p>页表还存在的问题：</p><p>1.空间，越小越好</p><p>2.时间，越快越好</p><p>如果页表太大，cpu cache 放不下，将会放在内存中，造成 2 次内存访问</p><p>间接访问，也是解决空间问题，类似于索引机制。</p><p><img src="/img/mac/image-20220315104409112.png" alt="image-20220315104409112"></p><h4 id="性能优化之时间：tlb"><a href="#性能优化之时间：tlb" class="headerlink" title="性能优化之时间：tlb"></a>性能优化之时间：tlb</h4><p><img src="/img/mac/image-20220315104752933.png" alt="image-20220315104752933"></p><p>Tlb 存在于 cpu 上的 mmu 内存访问单元</p><p>他是一个 key value 的快表。</p><p>存的是 p 和 f，对应的是页号和帧号。</p><p>如果 tlb 命中，返回。</p><p>如果 tlb miss 未命中，查 pagetable，将其放入 tlb，返回。x86 架构中，这个行为是硬件自身完成的；mips 架构是由操作系统来完成，也就是软件支撑。</p><h4 id="性能优化之空间：二级页表"><a href="#性能优化之空间：二级页表" class="headerlink" title="性能优化之空间：二级页表"></a>性能优化之空间：二级页表</h4><p>一级页表存的是第二级页表的起始地址，这个地址再跟 p2 进行相加作为索引去二级页表中查找相应的值，得到 frame number。</p><p><img src="/img/mac/image-20220315105928232.png" alt="image-20220315105928232"></p><p>多次查找开销不是很大吗？</p><p>一级页表中，如果 resident 标志位为 0，二级页表中根本不需要存在。这就省了很多空间，尤其是在多级页表的情况下。</p><p>推广到多级页表：</p><p><img src="/img/mac/image-20220315110207423.png" alt="image-20220315110207423"></p><p>典型的以时间换取空间。</p><h4 id="性能优化之空间：反向页表"><a href="#性能优化之空间：反向页表" class="headerlink" title="性能优化之空间：反向页表"></a>性能优化之空间：反向页表</h4><p>因为之前介绍的页表的大小均和逻辑地址大小挂钩，但是逻辑地址比较大，也就造成了页表很大。</p><p>有没有办法让页表和物理地址挂钩？让索引变成帧号，内容成为页号。</p><p><img src="/img/mac/image-20220315110548448.png" alt="image-20220315110548448"></p><p>需要解决的问题，我们 cpu 得到的是逻辑页号，怎么解决和帧号的对应。</p><p>页寄存器</p><p><img src="/img/mac/image-20220315110744311.png" alt="image-20220315110744311"></p><p>关联内存</p><p><img src="/img/mac/image-20220315111139608.png" alt="image-20220315111139608"></p><p><img src="/img/mac/image-20220315111243805.png" alt="image-20220315111243805"></p><p>哈希 table</p><p><img src="/img/mac/image-20220315111540912.png" alt="image-20220315111540912"></p><p>存在 hash 碰撞问题</p><p><img src="/img/mac/image-20220315111755175.png" alt="image-20220315111755175"></p><h1 id="第五课-虚拟内存"><a href="#第五课-虚拟内存" class="headerlink" title="第五课 虚拟内存"></a>第五课 虚拟内存</h1><p><img src="/img/mac/image-20220315112622166.png" alt="image-20220315112622166"></p><p>越快的存储器离 cpu 越近。</p><p><img src="/img/mac/image-20220315113008700.png" alt="image-20220315113008700"></p><p><img src="/img/mac/image-20220315113244873.png" alt="image-20220315113244873"></p><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>覆盖：把常用的代码放到内存中，不用的先放到硬盘中；需要的时候再拿出，进行一个覆盖。</p><p>早期微软的 dos 系统就是采用覆盖技术 80 - 90 年代。</p><p><img src="/img/mac/image-20220315113708077.png" alt="image-20220315113708077"></p><p>没有相关调用关系的代码块先放到硬盘。a-b,a-c 的例子。</p><p><img src="/img/mac/image-20220315114149061.png" alt="image-20220315114149061"></p><p>另一种调用关系、覆盖方法：</p><p>可以看到，通过程序员的安排，把空间用到极致。</p><p><img src="/img/mac/image-20220315114343276.png" alt="image-20220315114343276"></p><p>缺点：</p><p>覆盖关系不好确定</p><p>频繁换入换出开销大</p><p><img src="/img/mac/image-20220315114439108.png" alt="image-20220315114439108"></p><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>unix 早期提出的方法。</p><p>交换：把不常用的程序放到硬盘里，把内存空间让出来，让正在运行的程序有更大的内存可以使用。<img src="/img/mac/image-20220315114834832.png" alt="image-20220315114834832"></p><p><img src="/img/mac/image-20220315115032588.png" alt="image-20220315115032588"></p><p>实现过程中的问题：</p><p><img src="/img/mac/image-20220315115442930.png" alt="image-20220315115442930"></p><p>重定位：可能换出的那个时候的地址已经被占用了，换入的时候地址又要重新考虑</p><p>覆盖和交换的比较：</p><p><img src="/img/mac/image-20220315115539550.png" alt="image-20220315115539550"></p><h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2><p>虚拟内存管理技术。</p><p>前面介绍的覆盖和交换都存在一些弊端。</p><p>一个增加程序员负担，一个粒度太大导致开销大。</p><p><img src="/img/mac/image-20220315140720888.png" alt="image-20220315140720888"></p><p>让粒度更小，并且带有覆盖的特征。</p><p><img src="/img/mac/image-20220315140905840.png" alt="image-20220315140905840"></p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>为了让内存管理完全依赖于 os，需要程序带有局部性。</p><p><img src="/img/mac/image-20220315141118766.png" alt="image-20220315141118766"></p><p><img src="/img/mac/image-20220315141835271.png" alt="image-20220315141835271"></p><p>一个例子：每页大小 4k,内存也定为 4k。1024 * 4byte = 4k</p><p><img src="/img/mac/image-20220315141858679.png" alt="image-20220315141858679"></p><p>缺页异常：要频繁的把每个页都读取到内存中。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>操作系统可以在分段和分页的基础之上，来进行虚存管理</p><p><img src="/img/mac/image-20220315142116822.png" alt="image-20220315142116822"></p><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p><img src="/img/mac/image-20220315142545605.png" alt="image-20220315142545605"></p><p>程序是感觉不到内存的具体大小的，处理过程都给 os 来执行，程序会感受到自己可用的空间是足够的。</p><p>交换的粒度相对于交换技术来说更小。</p><p>换入换出的机制，可能 os 会把虚拟地址空间中连续的代码换出。</p><h3 id="虚拟页式内存管理"><a href="#虚拟页式内存管理" class="headerlink" title="虚拟页式内存管理"></a>虚拟页式内存管理</h3><p><img src="/img/mac/image-20220315142902768.png" alt="image-20220315142902768"></p><p>其中 resident 在接下来的管理有关键作用。</p><p><img src="/img/mac/image-20220315143032359.png" alt="image-20220315143032359"></p><p>上图的请求调用机制就是由 resident bit 来实现的。</p><p>页面置换：需要一些算法，把不常用的页帧换出，后面介绍。</p><p>页表结构再深入</p><p><img src="/img/mac/image-20220315153217040.png" alt="image-20220315153217040"></p><p>修改位：代表这个页是否被写过。被写过后内存和磁盘的数据是不一致的，需要刷盘。</p><p>驻留位：resident，已经介绍过。</p><p>Mov reg,0</p><p>0 对应的页帧是 2，通过计算公式</p><p>2*页大小 4k + 偏移 = 8192，得到对应的物理地址 8192。</p><p>mov reg 32768，对应第 8 位，驻留位是 0 的情况，发生缺页中断。需要操作系统把页从外存中调入。</p><p><img src="/img/mac/image-20220315144019183.png" alt="image-20220315144019183"></p><p>缺页中断执行流程：</p><p><img src="/img/mac/image-20220315144313435.png" alt="image-20220315144313435"></p><p>内存的各个段在外存中的存储形式：后备存储</p><p><img src="/img/mac/image-20220315144936056.png" alt="image-20220315144936056"></p><h3 id="虚拟内存性能"><a href="#虚拟内存性能" class="headerlink" title="虚拟内存性能"></a>虚拟内存性能</h3><p><img src="/img/mac/image-20220315145213412.png" alt="image-20220315145213412"></p><p>p ： 缺页的比例</p><p>q ： 进行了写操作的页</p><p>1+q：因为是脏页要写入磁盘，又要多访问一次磁盘。</p><p>如果程序有局部性原理，产生缺页的情况就会大大减少，让效率更高。</p><h1 id="第六课-页面置换算法"><a href="#第六课-页面置换算法" class="headerlink" title="第六课 页面置换算法"></a>第六课 页面置换算法</h1><h2 id="功能目标"><a href="#功能目标" class="headerlink" title="功能目标"></a>功能目标</h2><p>磁盘 io 的开销是比较高的，尽量少换入换出。</p><p><img src="/img/mac/image-20220315150017680.png" alt="image-20220315150017680"></p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>我们可以直接不考虑偏移，因为要研究的页的换入换出，只考虑页号。</p><p><img src="/img/mac/image-20220315150225932.png" alt="image-20220315150225932"></p><h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换"><a href="#最优页面置换" class="headerlink" title="最优页面置换"></a>最优页面置换</h3><p>不太现实，但是可以作为其他算法的评判标准。其他算法越逼近他，效果就越好。</p><p><img src="/img/mac/image-20220315150444209.png" alt="image-20220315150444209"></p><p>Requests：当前时间轴下要访问的页</p><p>总共有四个页帧，五个页，所以会发生页替换。</p><p>第一次访问 e 的时候发生缺页，需要用算法计算。</p><p><img src="/img/mac/image-20220315150759529.png" alt="image-20220315150759529"></p><h3 id="先进先出算法-fifo"><a href="#先进先出算法-fifo" class="headerlink" title="先进先出算法 fifo"></a>先进先出算法 fifo</h3><p>belady 现象，你给他的物理页帧越多，反而缺页情况也越多。</p><p><img src="/img/mac/image-20220315150904269.png" alt="image-20220315150904269"></p><p><img src="/img/mac/image-20220315151306909.png" alt="image-20220315151306909"></p><p><img src="/img/mac/image-20220315151326311.png" alt="image-20220315151326311"></p><p>实现简单，但缺页次数多。</p><h3 id="最近最久未使用算法-lru"><a href="#最近最久未使用算法-lru" class="headerlink" title="最近最久未使用算法 lru"></a>最近最久未使用算法 lru</h3><p>least recently used</p><p>他是根据过去很长时间都没访问过的页面，来推测未来。最优页面置换是根据未来来推测未来。</p><p><img src="/img/mac/image-20220315151547725.png" alt="image-20220315151547725"></p><p>实验过程：</p><p><img src="/img/mac/image-20220315151852730.png" alt="image-20220315151852730"></p><p><img src="/img/mac/image-20220315151938981.png" alt="image-20220315151938981"></p><p>lru 维护各个页面的使用时间：</p><p>链表 - 头插法，最近使用的成为链首，每次剔除的时候选择链尾。</p><p>栈，最近使用的页压入栈中，每次剔除的时候从栈尾中弹出。</p><p><img src="/img/mac/image-20220315152247073.png" alt="image-20220315152247073"></p><p>虽然解决缺页效果不错，但是开销比较大，因为每次都要遍历链表或者栈看看页帧是否在里面。</p><p><img src="/img/mac/image-20220315152559378.png" alt="image-20220315152559378"></p><h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>访问位 置 1 是由硬件来完成的，但是软件可以对其修改。</p><p>当页帧最近被访问过，访问位置 1。</p><p><img src="/img/mac/image-20220315153722011.png" alt="image-20220315153722011"></p><p>环形链表的维护：</p><p><img src="/img/mac/image-20220315154106879.png" alt="image-20220315154106879"></p><p>当发生了缺页，从当前指针开始遍历，如果是访问位是 1，就将其变 0；直到找到访问位为 0 的页，将其替换。</p><p>实验过程：</p><p><img src="/img/mac/image-20220315154712009.png" alt="image-20220315154712009"></p><h3 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h3><p>在 clock 的基础上，多判断一个 dirty bit（是否写过该页）</p><p><img src="/img/mac/image-20220315155748580.png" alt="image-20220315155748580"></p><p>两个 bit，四种情况。</p><p>如果写入过某个页，两个 bit 都会变成 1；第一次遍历到这个页的时候变成 0 1，第二次再变成 0 0；再下一次 replace。</p><p>所以被写入过的页，被换出的机会更少；只读的页，会更快的被换出。所以叫做二次机会法。</p><p>实验过程：10 表示 used bit = 1，dirty bit = 0；</p><p><img src="/img/mac/image-20220315160450793.png" alt="image-20220315160450793"></p><h3 id="最不常用算法-lfu"><a href="#最不常用算法-lfu" class="headerlink" title="最不常用算法 lfu"></a>最不常用算法 lfu</h3><p>least frequently used</p><p>lfu 和 lru 的区别：一个是访问次数，一个是多久未访问。</p><p><img src="/img/mac/image-20220315160927016.png" alt="image-20220315160927016"></p><p>问题：一个页面在进程开始时用的很多，但以后就不再使用了。</p><p>解决方法：定期把次数寄存器右移一位。就是除以 2。</p><p>实验过程：</p><p><img src="/img/mac/image-20220315161141452.png" alt="image-20220315161141452"></p><h3 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h3><p><img src="/img/mac/image-20220315161416331.png" alt="image-20220315161416331"></p><p>head：当前在内存中要被淘汰的页。</p><p><img src="/img/mac/image-20220315161656419.png" alt="image-20220315161656419"></p><p><img src="/img/mac/image-20220315161842043.png" alt="image-20220315161842043"></p><p>同样的访问序列，加大了页帧，产生的缺页反而更多，被一个叫 belady 的科学家发现。</p><p>采用 lru 算法就不会产生 belady</p><p><img src="/img/mac/image-20220315161954935.png" alt="image-20220315161954935"></p><p>为什么呢？</p><p>lru 满足栈算法，你给他资源越多，他的缺页越少。具体内容自行 google 或翻阅《操作系统概述》。</p><p><img src="/img/mac/image-20220315162336046.png" alt="image-20220315162336046"></p><p><img src="/img/mac/image-20220315162614428.png" alt="image-20220315162614428"></p><p>clock 算法只用了 1bit，思路是模仿 lru，但开销更小。</p><h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><p>上面的算法都是针对一个进程的局部置换算法。并且用的都是固定物理页帧。</p><p>我们希望通过动态页帧来最大程度减少缺页的发生</p><p><img src="/img/mac/image-20220315163836144.png" alt="image-20220315163836144"></p><p>不同的页帧的效果差别是很大的，能否动态调整？</p><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p><img src="/img/mac/image-20220315163945697.png" alt="image-20220315163945697"></p><p>前面的局部置换算法全部基于程序的局部性原理。</p><p>定义：</p><p>工作集窗口类似于滑动窗口</p><p><img src="/img/mac/image-20220315164208803.png" alt="image-20220315164208803"></p><p>例子</p><p><img src="/img/mac/image-20220315164331593.png" alt="image-20220315164331593"></p><p>可以看到，滑动集对页进行了去重操作。</p><p><img src="/img/mac/image-20220315164545591.png" alt="image-20220315164545591"></p><p>工作集表示的是程序进行的时候要访问的页是哪些，这些页可能在内存中，也可能不在内存中。</p><p>常驻集表示在内存中有哪些页。</p><p>我们希望工作集和常驻集尽量重合，以减少缺页。</p><p><img src="/img/mac/image-20220315164828959.png" alt="image-20220315164828959"></p><p>给不同的应用程序以不同的常驻集，来减少缺页。</p><h3 id="两个全局页面置换算法"><a href="#两个全局页面置换算法" class="headerlink" title="两个全局页面置换算法"></a>两个全局页面置换算法</h3><h4 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h4><p>工作集是随着时间进行移动的滑动窗口，不在滑动窗口（工作集）内的就换出去。具体图示在上方的图。</p><p>实验过程：</p><p>这个可以动手画一下，光看可能不够清晰。</p><p><img src="/img/mac/image-20220315165622326.png" alt="image-20220315165622326"></p><p>在物理内存中放的页参考的是工作集窗口</p><h3 id="缺页率页面置换算法"><a href="#缺页率页面置换算法" class="headerlink" title="缺页率页面置换算法"></a>缺页率页面置换算法</h3><p>缺页率：缺页次数/内存访问次数<img src="/img/mac/image-20220315184540203.png" alt="image-20220315184540203"></p><p>缺页率算法实现</p><p><img src="/img/mac/image-20220315184709513.png" alt="image-20220315184709513"></p><p>缺页率高和低的计算</p><p>计算这次缺失和上次缺失的时间进行相减。如果值大于某个阈值，说明缺页率比较低，相应的可以减少工作集。如果小于某个阈值，说明缺页率高。</p><p><img src="/img/mac/image-20220315184849983.png" alt="image-20220315184849983"></p><p>实验过程：图有点糊， t current - t last &gt; 2</p><p><img src="/img/mac/image-20220315185637612.png" alt="image-20220315185637612"></p><p>两个算法发生的时机是不一样的，缺页率算法是在中断发生时发生。</p><h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><p><img src="/img/mac/image-20220315190028579.png" alt="image-20220315190028579"></p><p>cpu 利用率是 y 轴：尽量不把 cpu 用于换入换出。</p><p>开启的进程数是 x 轴：</p><p><img src="/img/mac/image-20220315190220994.png" alt="image-20220315190220994"></p><p>解决：尽量让平均页缺失时间等于页缺失服务时间，让尽量跑更多的进程的情况下，还保持 cpu 高利用率。</p><p><img src="/img/mac/image-20220315190459458.png" alt="image-20220315190459458"></p><h1 id="第七课-进程管理"><a href="#第七课-进程管理" class="headerlink" title="第七课-进程管理"></a>第七课-进程管理</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>进程代表着运行着的程序的执行过程，消耗着各种资源如 cpu，内存，网络，io 等。</p><p><img src="/img/mac/image-20220315191212264.png" alt="image-20220315191212264"></p><p><img src="/img/mac/image-20220315191508500.png" alt="image-20220315191508500">代码编译后成为可执行文件，只有当操作系统把可执行文件调入内存中执行起来，所谓执行就是 cpu 调用其中的一条条指令，完成不同的功能，这个过程是动态的执行过程，这个执行过程就是<strong>进程</strong>。和静态的可执行文件是不同的。</p><h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p><img src="/img/mac/image-20220315191834893.png" alt="image-20220315191834893"></p><p>进程和程序的联系：</p><p>程序的代码限制了进程产生的功能。</p><p><img src="/img/mac/image-20220315191939659.png" alt="image-20220315191939659"></p><p>进程与程序的区别：</p><p>核心态：某些行为只能 os 才能完成（如读取文件）；os 代表进程在内存中完成这些行为</p><p>用户态：仅仅执行程序写的代码</p><p><img src="/img/mac/image-20220315192455070.png" alt="image-20220315192455070"></p><p>类比，便于理解：</p><p><img src="/img/mac/image-20220315192751422.png" alt="image-20220315192751422"></p><h2 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h2><p>动态性 包括进程创建、切换、结束</p><p>并行：在一个时刻有多个进程执行，需要多核 cpu 支撑</p><p>并发：在一段短时间内有多个进程执行</p><p>独立性：可以给每个进程分配几个独立的页表，在内存管理方面予以支持。</p><p>制约性</p><p><img src="/img/mac/image-20220315193451486.png" alt="image-20220315193451486"></p><h2 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h2><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p><img src="/img/mac/image-20220315193645495.png" alt="image-20220315193645495"></p><p>进程控制块可以作为进程存在的唯一标识。</p><p><img src="/img/mac/image-20220315193735471.png" alt="image-20220315193735471"></p><p><img src="/img/mac/image-20220315193836928.png" alt="image-20220315193836928"></p><h3 id="pcb-含有的信息"><a href="#pcb-含有的信息" class="headerlink" title="pcb 含有的信息"></a>pcb 含有的信息</h3><p><img src="/img/mac/image-20220315193949135.png" alt="image-20220315193949135"></p><p>处理机即 cpu</p><p>控制进程处于哪个状态，运行等待或者就绪等其他情况，描述进程的执行现状。</p><p><img src="/img/mac/image-20220315194216137.png" alt="image-20220315194216137"></p><p>数据结构连接信息：如进程 a 创建了进程 b，a 就是 b 的父进程。</p><h3 id="pcb-的组织方式"><a href="#pcb-的组织方式" class="headerlink" title="pcb 的组织方式"></a>pcb 的组织方式</h3><p>链表：可以更好地完成动态的插入和删除</p><p>如果没有频繁的创建和删除，可以考虑索引</p><p><img src="/img/mac/image-20220315194710456.png" alt="image-20220315194710456"></p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><p>创建-运行-等待-唤醒-结束</p><p><img src="/img/mac/image-20220315194837246.png" alt="image-20220315194837246"></p><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>有下图三种情况</p><p>系统初始化：先创建一个 init 进程，init 再创建其他进程</p><p><img src="/img/mac/image-20220315194938881.png" alt="image-20220315194938881"></p><h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p><img src="/img/mac/image-20220315195043941.png" alt="image-20220315195043941"></p><h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待 / 阻塞"></a>进程等待 / 阻塞</h4><p><img src="/img/mac/image-20220315195132996.png" alt="image-20220315195132996"></p><h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>等待的事件到达了，进入就绪态，等待操作系统调度，让 cpu 去执行</p><p><img src="/img/mac/image-20220315195340624.png" alt="image-20220315195340624"></p><h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p><img src="/img/mac/image-20220315195402683.png" alt="image-20220315195402683"></p><h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><img src="/img/mac/image-20220316104711131.png" alt="image-20220316104711131"></p><p>三个主要的基本状态和其他的基本状态：</p><p><img src="/img/mac/image-20220316104833846.png" alt="image-20220316104833846"></p><p><img src="/img/mac/image-20220316104929457.png" alt="image-20220316104929457"></p><p>Running -&gt; ready ：给每个进程分配一个小的时间片，让每个进程都有机会执行</p><p><img src="/img/mac/image-20220316105109329.png" alt="image-20220316105109329"></p><p>不会持续很久，pcb 的创建是很快的。</p><p><img src="/img/mac/image-20220316105202344.png" alt="image-20220316105202344"></p><p>操作系统来完成，os 管理着一个时钟，对应的管理时间片。</p><p><img src="/img/mac/image-20220316105421244.png" alt="image-20220316105421244"></p><p>事件还没有产生，对应的资源没得到满足。</p><p>阻塞时 事件来了，或者资源满足了，就从阻塞态进入就绪态，这也是操作系统来完成的状态转换。</p><h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p><img src="/img/mac/image-20220316105846558.png" alt="image-20220316105846558"></p><p><img src="/img/mac/image-20220316110104720.png" alt="image-20220316110104720"></p><p>阻塞挂起时，进程的资源得到了满足，成为就绪挂起。</p><p><img src="/img/mac/image-20220316110225989.png" alt="image-20220316110225989"></p><p>操作系统维护状态队列</p><p><img src="/img/mac/image-20220316110446729.png" alt="image-20220316110446729"></p><p><img src="/img/mac/image-20220316110815007.png" alt="image-20220316110815007"></p><p>多个就绪队列，这几个队列的优先级不同。</p><p>事件 1 满足后，将等待事件 1 的进程转为就绪状态。</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p><img src="/img/mac/image-20220316110958953.png" alt="image-20220316110958953"></p><h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程"></a>为什么使用线程</h3><p>编写一个 mp3</p><p><img src="/img/mac/image-20220316111059671.png" alt="image-20220316111059671"></p><p>可能 read 的地方阻塞了，导致声音断断续续。</p><p><img src="/img/mac/image-20220316111213808.png" alt="image-20220316111213808"></p><p>多进程的问题：并发的开销….</p><p><img src="/img/mac/image-20220316111321169.png" alt="image-20220316111321169"></p><p><img src="/img/mac/image-20220316111402830.png" alt="image-20220316111402830"></p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>进程当中的一条执行流程</p><p>从两个方面重新理解进程</p><p>资源管理+线程</p><p><img src="/img/mac/image-20220316111613746.png" alt="image-20220316111613746"></p><p>多个线程共享进程所拥有的资源，可以直接访问进程的代码，资源，文件等等。</p><p><img src="/img/mac/image-20220316111849951.png" alt="image-20220316111849951"></p><p>什么时候用进程，什么时候用线程？</p><p>打开浏览器的网页，现在一般是进程，如果用线程，一旦这个网页有问题，会导致其他的网页也崩溃。</p><p>高精度计算里可以用线程实现，如天气预报，空气动力学计算等等</p><p><img src="/img/mac/image-20220316112319233.png" alt="image-20220316112319233"></p><p>线程的资源共享和独占</p><p>code data files 共享，stack · pcgister 独占</p><p>复习 jvm：heap，method area 中资源线程共享，stack，pc register 线程独占</p><p><img src="/img/mac/image-20220316112357397.png" alt="image-20220316112357397"></p><p>线程与进程的比较</p><p><img src="/img/mac/image-20220316112943929.png" alt="image-20220316112943929"></p><p>进程的创建时还要进行资源的管理，而线程直接使用进程的资源，所以时间短。</p><p>线程的切换：线程切换不需要进行页的切换，而进程需要，从而要更改页表/tlb 等结构。</p><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>操作系统看不到的，由用户线程库来管理</p><p>用户线程的 tcb 操作系统是看不到的，线程的调度和管理由线程库函数管理。</p><p><img src="/img/mac/image-20220316113557923.png" alt="image-20220316113557923"></p><p><img src="/img/mac/image-20220316113706630.png" alt="image-20220316113706630"></p><p>用户线程缺点：</p><p><img src="/img/mac/image-20220316113941988.png" alt="image-20220316113941988"></p><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>操作系统管理的线程</p><p>tcb 是放在内核中的</p><h4 id="用户线程和内核线程的对应关系"><a href="#用户线程和内核线程的对应关系" class="headerlink" title="用户线程和内核线程的对应关系"></a>用户线程和内核线程的对应关系</h4><p><img src="/img/mac/image-20220316113417809.png" alt="image-20220316113417809"></p><p><img src="/img/mac/image-20220316114047677.png" alt="image-20220316114047677"></p><p>cpu 调度单位成了线程，进程主要完成资源的管理。 pcb 统一管理 tcb。</p><p><img src="/img/mac/image-20220316114323630.png" alt="image-20220316114323630"></p><h3 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h3><p><img src="/img/mac/image-20220316114516719.png" alt="image-20220316114516719"></p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>context switch</p><p>进程的上下文切换</p><p>进程的上下文切换换的是寄存器，如 pc register ， 栈指针等。</p><p><img src="/img/mac/image-20220316114732929.png" alt="image-20220316114732929"></p><p>切换时，将进程的当前状态（上下文）保存到 pcb 中的某一块中。再将要执行的进程的 pcb 中取出它对应的上下文。</p><p><img src="/img/mac/image-20220316115003158.png" alt="image-20220316115003158"></p><p><img src="/img/mac/image-20220316115157753.png" alt="image-20220316115157753"></p><p>僵尸队列：后续介绍。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>windows 和 unix 进程创建的系统调用</p><p><img src="/img/mac/image-20220316143325894.png" alt="image-20220316143325894"></p><p><img src="/img/mac/image-20220316143400299.png" alt="image-20220316143400299"></p><p><img src="/img/mac/image-20220316143447159.png" alt="image-20220316143447159"></p><p>fork 的地址空间复制</p><p><img src="/img/mac/image-20220316141202432.png" alt="image-20220316141202432"></p><p><img src="/img/mac/image-20220316141359910.png" alt="image-20220316141359910"></p><p>通过 if else 让子父进程执行的代码不一致。</p><p>空闲进程的创建</p><p><img src="/img/mac/image-20220316142449864.png" alt="image-20220316142449864"></p><p><img src="/img/mac/image-20220316143133176.png" alt="image-20220316143133176">让创建和加载在一个系统调用中完成，或者使用写时复制，用的时候再进行。</p><h3 id="加载和执行过程"><a href="#加载和执行过程" class="headerlink" title="加载和执行过程"></a>加载和执行过程</h3><p><img src="/img/mac/image-20220316143650881.png" alt="image-20220316143650881"></p><p>如果 exec 系统调用执行成功的话，why would i execute 不会输出。因为原先的代码块已经被改写了。</p><p><img src="/img/mac/image-20220316143953869.png" alt="image-20220316143953869"></p><p>fork 先创建新的地址空间，子进程先完全复制父进程的内存空间，当 exec 执行完后，子进程才执行不同的程序</p><p><img src="/img/mac/image-20220316144140317.png" alt="image-20220316144140317"></p><p>可以看到进程本身的堆栈代码段都变化了。</p><p><img src="/img/mac/image-20220316144211754.png" alt="image-20220316144211754"></p><p>fork 开销很大：</p><p>待优化的地方，复制的这个过程是可以被优化的，因为 exec 执行完后子进程都要修改掉。</p><p><img src="/img/mac/image-20220316144400307.png" alt="image-20220316144400307"></p><p>写时复制：当父进程执行 fork 时，不复制全部的数据，只进行元数据如页表等必要数据的复制。 当父进程或子进程对某一地址单元进行写的时候，会触发一个异常，让操作系统把触发异常的页复制成两份，进行按需写的操作。这是很高效的。</p><h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>我们看到上面的 else 语句块中，父进程总是会调用一个 wait()</p><p><img src="/img/mac/image-20220316145011673.png" alt="image-20220316145011673"></p><p>父进程得到子进程的 exit 消息后，且父进程在 wait，父进程帮助子进程把它的 PCB 在内存中释放掉。</p><p>僵尸状态：要死还不死的状态</p><p>子进程调用 exit 后其实已经没法正常工作，只等着被父进程回收。</p><p><img src="/img/mac/image-20220316145619754.png" alt="image-20220316145619754"></p><p>如果父进程没有在 wait，那么会有 root 根进程代替父进程进行回收僵尸进程。</p><p><img src="/img/mac/image-20220316145756774.png" alt="image-20220316145756774"></p><p>执行 exec 时，进程可能处于不同的状态</p><p>调用 exec 时-&gt; running</p><p>加载运行程序-&gt; ready</p><h1 id="第八课-cpu-调度"><a href="#第八课-cpu-调度" class="headerlink" title="第八课 cpu 调度"></a>第八课 cpu 调度</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/img/mac/image-20220316150049996.png" alt="image-20220316150049996"></p><p>什么时候调度？</p><p><img src="/img/mac/image-20220316150202618.png" alt="image-20220316150202618">当某个进程从一个状态切换到另一个状态时，进行调度</p><p><img src="/img/mac/image-20220316150400758.png" alt="image-20220316150400758"></p><p>上面的两个是用户态的抢占</p><p>内核的不可抢占：当一个用户态进程发起系统调用进入内核态，操作系统可以确定返回的是发起系统调用的那个进程，在这个过程中不会发生等待。</p><h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><p><img src="/img/mac/image-20220316151001873.png" alt="image-20220316151001873"></p><p>让进程更充分的利用 cpu 资源</p><p>评价调度的指标</p><p><img src="/img/mac/image-20220316151159812.png" alt="image-20220316151159812"></p><p>周转时间包括两块：初始化之后还要等待一段时间才能被 cpu 执行的等待时间，执行过程中的执行时间</p><p><img src="/img/mac/image-20220316151703757.png" alt="image-20220316151703757"></p><p>上面的指标有的是冲突的，如响应时间和吞吐量，我们要根据调度算法力求达到平衡。</p><p>我们希望算法有这样的效果：</p><p><img src="/img/mac/image-20220316151912231.png" alt="image-20220316151912231"></p><p><img src="/img/mac/image-20220316152234235.png" alt="image-20220316152234235"></p><p><img src="/img/mac/image-20220316152332248.png" alt="image-20220316152332248"></p><p>希望每个进程得到 cpu 使用时间大致相同，</p><p>每个进程等待 cpu 的时间也大致相同，为公平。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><img src="/img/mac/image-20220316152507960.png" alt="image-20220316152507960"></p><p>多级反馈队列：既强调公平又根据进程的动态执行过程来动态调整。</p><ul><li>FCFS 先来先服务</li></ul><p><img src="/img/mac/image-20220316152722265.png" alt="image-20220316152722265"></p><p>如果前面的进程执行时间长，会导致后面进程的等待时间也相应长，严重影响周转时间和平均等待时间。</p><p><img src="/img/mac/image-20220316153024253.png" alt="image-20220316153024253"></p><ul><li>短任务优先 SRT/SPN</li></ul><p><img src="/img/mac/image-20220316153144634.png" alt="image-20220316153144634"></p><p>如果来了一个时间比现在正在执行的进程时间短的进程。抢占（SRT)：现在执行的进程进入就绪，新来的执行。</p><p>非抢占(SPN)：新来的最短时间进程进入链头</p><p><img src="/img/mac/image-20220316153602722.png" alt="image-20220316153602722"></p><p>可以看到最短任务优先的速度是最快的。</p><p><img src="/img/mac/image-20220316153941197.png" alt="image-20220316153941197"></p><p>我们很难知道一个程序的执行时间。所以这个算法很难实现。</p><p><img src="/img/mac/image-20220316154316946.png" alt="image-20220316154316946"></p><p>我们通过一种公式来预估程序的执行时间。</p><p>通过 2 个时刻来预估下一刻的时间。也是一种根据过去来预估未来的方式。</p><ul><li>最高响应比优先</li></ul><p><img src="/img/mac/image-20220316154537699.png" alt="image-20220316154537699"></p><p>综合考虑了等待时间和执行时间。</p><ul><li>轮询 round robin</li></ul><p>让各个进程轮流占有时间片执行</p><p><img src="/img/mac/image-20220316154828628.png" alt="image-20220316154828628"></p><p>没有占满时间片的直接交出。</p><p><img src="/img/mac/image-20220316155114602.png" alt="image-20220316155114602"></p><p>时间片太小，切换太频繁。时间片太大，退化成 fcfs</p><p>看看不同时间片大小下的平均等待时间</p><p><img src="/img/mac/image-20220316155345905.png" alt="image-20220316155345905"> fcfs 相对于 rr 牺牲了公平性</p><ul><li>多级反馈队列</li></ul><p>多级队列：</p><p>把就绪队列分为多级，他们有不同优先级，每级采取不同算法</p><p><img src="/img/mac/image-20220316155707140.png" alt="image-20220316155707140"></p><p>多级反馈队列：</p><p>根据进程的动态变化，而让进程在不同的队列中移动</p><p><img src="/img/mac/image-20220316155914130.png" alt="image-20220316155914130"></p><ul><li>FFS 公平共享调度</li></ul><p><img src="/img/mac/image-20220316160256308.png" alt="image-20220316160256308"></p><p>现在介绍的调度算法是简单的，实际操作系统中可能更复杂，但是我们上面的算法都会体现出思想。如公平性和等待时间如何权衡等。</p><p><img src="/img/mac/image-20220316160602236.png" alt="image-20220316160602236"></p><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>区别于前面的通用型操作系统方法。</p><p>实施调度大多用于工业控制如火车，机床和嵌入式之类的实施系统中。</p><p><img src="/img/mac/image-20220316160928808.png" alt="image-20220316160928808"></p><p>实施系统分为两类：</p><p><img src="/img/mac/image-20220316160945836.png" alt="image-20220316160945836"></p><p>前者的重要性任务如果不完成可能会发生灾难性的后果。所以必须要完成。</p><p><img src="/img/mac/image-20220316161240412.png" alt="image-20220316161240412"></p><p>released：代表程序进入就绪</p><p>就绪后等待一段时间执行，execution time</p><p>deadline ：期限，执行时间一定不能超过期限，超过了实时性就不能得到满足</p><p>relative deadline：在周期中的某个任务的相对期限。</p><p><img src="/img/mac/image-20220316161318156.png" alt="image-20220316161318156"></p><p><img src="/img/mac/image-20220316161719461.png" alt="image-20220316161719461"></p><p><img src="/img/mac/image-20220316161922647.png" alt="image-20220316161922647"></p><p>任务的优先级随着执行过程而发生改变</p><p>实施系统的两种调度算法</p><p><img src="/img/mac/image-20220316162042920.png" alt="image-20220316162042920"></p><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>前面的调度算法都是针对单个 cpu</p><p>我们要考虑程序放哪个 cpu 上，和负载均衡问题。</p><p>但是对于每个独立的 cpu 内部，里面用的方法和普通操作系统的调度算法差不多。</p><p><img src="/img/mac/image-20220316162717935.png" alt="image-20220316162717935"></p><p>不多介绍。</p><h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><h1 id="第九课-同步"><a href="#第九课-同步" class="headerlink" title="第九课 同步"></a>第九课 同步</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p><img src="/img/mac/image-20220316185003082.png" alt="image-20220316185003082"></p><p>上图中的线程可以替换进程，在这里都看作是 cpu 的调度单位</p><p><img src="/img/mac/image-20220316185230533.png" alt="image-20220316185230533"></p><p>完成相应的共享和交互</p><p>不确定性和不可重现的例子：</p><p><img src="/img/mac/image-20220316185424543.png" alt="image-20220316185424543"></p><p>有点像 jvm 中的 i++的字节码：iinc 1，1 之类的</p><p>java 中类似的并发问题：不确定进程 1 的时间片什么时候用完，从而在本该进行原子操作的代码中发生非原子操作</p><p><img src="/img/mac/image-20220316185811356.png" alt="image-20220316185811356"></p><p>调度导致线程上下文切换，切换完毕后，进程 1 的寄存器要进行恢复，这样就又恢复到了 100。</p><p><img src="/img/mac/image-20220316190356638.png" alt="image-20220316190356638"></p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>引入同步互斥，解决</p><p><img src="/img/mac/image-20220316190516195.png" alt="image-20220316190516195"></p><p>方法：保证原子操作</p><p><img src="/img/mac/image-20220316190535001.png" alt="image-20220316190535001"></p><p><img src="/img/mac/image-20220316190659040.png" alt="image-20220316190659040"></p><p>可能 a 先执行完，b 先执行完，还有一种一直僵持下去的情况，谁都无法 print。</p><p>我们要通过同步机制解决这个问题。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>有一段代码要访问共享资源如静态变量，访问共享资源的那段代码就是临界区</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>保证访问临界区的进程只有一个，不允许多个进程都进入临界区</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>a 等 b 的资源</p><p>b 等 a 的资源</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个迟迟得不到资源的进程</p><p><img src="/img/mac/image-20220316191815197.png" alt="image-20220316191815197"></p><p>例子：</p><p><img src="/img/mac/image-20220316192049203.png" alt="image-20220316192049203"></p><p>其实就是两个进程做了重复的事，不是我们所期望的。</p><p>可以用锁来解决</p><p><img src="/img/mac/image-20220316192258237.png" alt="image-20220316192258237"></p><p>锁住冰箱，粒度太大了，我们可以用粒度更小的标签来当作锁</p><p><img src="/img/mac/image-20220316192530795.png" alt="image-20220316192530795"></p><p>但是依旧存在问题</p><p>如果进程切换在第二个 if 语句，那么一样会出问题</p><p><img src="/img/mac/image-20220316192758620.png" alt="image-20220316192758620"></p><p><img src="/img/mac/image-20220316192835099.png" alt="image-20220316192835099"></p><p>如果把放置标签放在第一步</p><p>根本不会有人去买面包</p><p><img src="/img/mac/image-20220316193051262.png" alt="image-20220316193051262"></p><p>比如 a 先放标签，b 也放标签，到了判断有无标签的时候，都进不去 if 里面的代码块。</p><p>为便签增加标签，依旧不行</p><p><img src="/img/mac/image-20220316193543860.png" alt="image-20220316193543860"></p><p><img src="/img/mac/image-20220316193619833.png" alt="image-20220316193619833"></p><p><img src="/img/mac/image-20220316193831165.png" alt="image-20220316193831165"></p><p>这样的逻辑可以解决一个人买面包且不多买</p><p>但是</p><p><img src="/img/mac/image-20220316194110732.png" alt="image-20220316194110732"></p><p>这只是两个进程的情况，很难推广到多个。</p><p>另一个解决方案<img src="/img/mac/image-20220316194447529.png" alt="image-20220316194447529"></p><p>同一时间只能有一个进程执行临界区的的代码，其他进程如果想进来需要等待。</p><p><img src="/img/mac/image-20220316194725057.png" alt="image-20220316194725057"></p><h3 id="怎么设计进入和离开临界区的代码"><a href="#怎么设计进入和离开临界区的代码" class="headerlink" title="怎么设计进入和离开临界区的代码"></a>怎么设计进入和离开临界区的代码</h3><p><img src="/img/mac/image-20220316194916384.png" alt="image-20220316194916384"></p><p>设计的原则，一个进程如果想进去，就一定会进去等等……</p><p><img src="/img/mac/image-20220316195257045.png" alt="image-20220316195257045"></p><h4 id="方法-1-禁用硬件中断"><a href="#方法-1-禁用硬件中断" class="headerlink" title="方法 1 禁用硬件中断"></a>方法 1 禁用硬件中断</h4><p>中断使得操作系统有了打断进程的能力，但这也是得到不确定结果的主要原因。</p><p><img src="/img/mac/image-20220316195311150.png" alt="image-20220316195311150"></p><p>缺点：中断主要是用于及时的外设进行交互的，如果停止了中断，硬件没法得到及时的响应，会有一定影响。</p><p><img src="/img/mac/image-20220316195417039.png" alt="image-20220316195417039"></p><h4 id="方法-2-基于软件的解决方法"><a href="#方法-2-基于软件的解决方法" class="headerlink" title="方法 2 基于软件的解决方法"></a>方法 2 基于软件的解决方法</h4><p><img src="/img/mac/image-20220316195735072.png" alt="image-20220316195735072"></p><p>根据 turn 来决定谁进入临界区</p><p><img src="/img/mac/image-20220316195935089.png" alt="image-20220316195935089"></p><p>假设 turn = 0；非 0 的进程进来会在 while 里面打转，只有 0 的进程会进入临界区</p><p>progress：某个进程不往前走了，一直在临界区门口等着。如果进程 1 进去后把 turn 改成了 0，但是 1 想再进去一次，可是 0 不再来访问这次代码了，导致 1 无法进去，一直在门口打转。</p><p>另一种方案</p><p>flag[i] == 1 表示进程 i 想进入临界区</p><p><img src="/img/mac/image-20220316200757200.png" alt="image-20220316200757200"></p><p>j 是现在正在临界区里的进程，它执行完后把 flag[j]置 0，让等待的进程 i 进入。</p><p>这种方案有什么问题？</p><p>没有互斥。</p><p>初始的时候，两个进程的对应 flag 都为 0，都进入了第二条语句，造成两个人买面包问题。</p><p>交换两条语句</p><p><img src="/img/mac/image-20220316201303313.png" alt="image-20220316201303313"></p><p>进程 0 和进程 1 可能都在 while 循环中打转</p><p>正确解法：</p><p><img src="/img/mac/image-20220316201428593.png" alt="image-20220316201428593"></p><p>皮特森算法</p><p><img src="/img/mac/image-20220316201644782.png" alt="image-20220316201644782"></p><p>互斥的证明：反证法，假设有两个进程 0，1。</p><p>如果两个进程都在临界区，但是 turn 又只能有一个值，所以不会有互斥。</p><p>德克斯算法 也是一个可行的算法</p><p><img src="/img/mac/image-20220316202222399.png" alt="image-20220316202222399"></p><p>推广到 n 个进程：另一个算法</p><p>让 n 个进程有序的进入临界区</p><p><img src="/img/mac/image-20220316202307917.png" alt="image-20220316202307917"></p><p>bakery 算法，例子</p><p>相当于银行取号，叫到号的进临界区，如果票号一样，就按他们的身份标识（身份证）来排。</p><p><img src="/img/mac/image-20220316202420592.png" alt="image-20220316202420592"></p><p>总结</p><p><img src="/img/mac/image-20220316202729203.png" alt="image-20220316202729203"></p><p>忙等：在 while 中循环打转</p><h4 id="方法-3-更高级的抽象-原子操作指令"><a href="#方法-3-更高级的抽象-原子操作指令" class="headerlink" title="方法 3 更高级的抽象 原子操作指令"></a>方法 3 更高级的抽象 原子操作指令</h4><p><img src="/img/mac/image-20220316202907928.png" alt="image-20220316202907928"></p><p>只有获得锁的才能进入临界区</p><p><img src="/img/mac/image-20220316202931210.png" alt="image-20220316202931210"></p><p>抽象怎么实现？</p><p><img src="/img/mac/image-20220316203008197.png" alt="image-20220316203008197"></p><p>test-and-set：一条机器指令，完成通常的读写操作的两条指令</p><p>exchange ： 输入的是两个内存单元</p><p><img src="/img/mac/image-20220316203608393.png" alt="image-20220316203608393"></p><p>Test and Set 的具体使用</p><p><img src="/img/mac/image-20220316203935765.png" alt="image-20220316203935765"></p><p>两个进程和 n 个进程都可以实现</p><p>在自旋的进程还能再优化，让忙等的进程睡眠，进入一个等待队列，锁释放后再进行唤醒</p><p><img src="/img/mac/image-20220316204006873.png" alt="image-20220316204006873"></p><p><img src="/img/mac/image-20220316204158628.png" alt="image-20220316204158628"></p><p>但是不忙等的情况会发生线程上下文切换，而忙等又占用一定的 cpu 资源。如果临界区的代码较长，可以考虑无忙等待；如果临界区的代码很短，那就可以等一会。</p><p>exchange 实现机制</p><p><img src="/img/mac/image-20220316204436028.png" alt="image-20220316204436028"></p><p>基于原子操作指令的同步现在是广泛使用的</p><p><img src="/img/mac/image-20220316204750456.png" alt="image-20220316204750456"></p><p><img src="/img/mac/image-20220316204802677.png" alt="image-20220316204802677"></p><p>高优先级的进程在忙等的时候，因为低优先级进程的优先级低，导致无法释放锁。从而发生死锁。可以用上面介绍的优先级反转来解决。</p><p><img src="/img/mac/image-20220316205002882.png" alt="image-20220316205002882"></p><h1 id="第十课-信号量和管程"><a href="#第十课-信号量和管程" class="headerlink" title="第十课 信号量和管程"></a>第十课 信号量和管程</h1><p>复习第九课</p><p><img src="/img/mac/image-20220316205439909.png" alt="image-20220316205439909"></p><p>软件的开销是很大的，我们用硬件来支撑这个锁的概念。</p><h2 id="信号量-sem"><a href="#信号量-sem" class="headerlink" title="信号量 sem"></a>信号量 sem</h2><p>临界区的读操作是可以并发执行的，但我们上面的都只能有一个进程进入临界区，这就引出信号量的概念</p><p><img src="/img/mac/image-20220317093501831.png" alt="image-20220317093501831"></p><p>直到一个列车离开临界区，等待的那个列车会被离开的列车唤醒，进入临界区</p><p><img src="/img/mac/image-20220317093551747.png" alt="image-20220317093551747"></p><h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p><img src="/img/mac/image-20220317093843765.png" alt="image-20220317093843765"></p><p>一般来说，只唤醒一个进程的话，采用 fifo 机制，让等的最久的进程进行唤醒。</p><p><img src="/img/mac/image-20220317094030744.png" alt="image-20220317094030744"></p><p>模拟 lock 操作，初值设成 1</p><p><img src="/img/mac/image-20220317094212990.png" alt="image-20220317094212990"></p><p>模拟同步操作，将初值设为 0</p><p><img src="/img/mac/image-20220317094402522.png" alt="image-20220317094402522"></p><p>当线程 a 需要线程 b 执行到某个地方时，才能接着执行，就可以采用上面的设 sem 初值为 0 的操作。</p><p>上面的二进制 sem 有局限，看一下计数信号量的使用</p><p><img src="/img/mac/image-20220317094844068.png" alt="image-20220317094844068"></p><p>我们可以有多个生产者往 buffer 中写数据，也可以有多个 consumer 往里面读数据，这都取决于我们的 sem 怎么设置。</p><p>用二进制信号量做操作/取出的互斥</p><p><img src="/img/mac/image-20220317095123293.png" alt="image-20220317095123293"></p><p>具体实现</p><p>fullbuffer：bufffer 里面的数据初始值 0</p><p>emptybuffer：当前生产者可以往 buffer 里面放多少个数据</p><p><img src="/img/mac/image-20220317095240884.png" alt="image-20220317095240884"></p><p>确保互斥</p><p><img src="/img/mac/image-20220317095517202.png" alt="image-20220317095517202"></p><p>可以有 n 个生产者进入 deposit</p><p>执行完后把 full buffer+1,意味着通知消费者来取数据</p><p><img src="/img/mac/image-20220317095714835.png" alt="image-20220317095714835"></p><p>消费者和生产者相反</p><p><img src="/img/mac/image-20220317095803078.png" alt="image-20220317095803078"></p><p>如果 p/v 操作顺序改了，如消费者的 mutex -p 和 emptyBuffer - p 交换顺序</p><p>有可能发生死锁。</p><h3 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h3><p>等待队列里的进程，就是待唤醒的进程。</p><p>信号量的本身结构和 pv 操作硬件原语</p><p><img src="/img/mac/image-20220317101149943.png" alt="image-20220317101149943"></p><p><img src="/img/mac/image-20220317101356539.png" alt="image-20220317101356539">和锁的区别：锁还可以进行忙等和等待队列；而信号量只能用等待队列进行。</p><h2 id="管程-monitor"><a href="#管程-monitor" class="headerlink" title="管程 monitor"></a>管程 monitor</h2><p>最开始提出是用在简化高级语言的同步互斥问题。</p><p>管程是什么？</p><p>包含了一系列的共享变量，以及操作了这些共享变量的函数的总和</p><p><img src="/img/mac/image-20220317101736888.png" alt="image-20220317101736888"></p><p>条件变量？</p><p>在访问共享资源和变量的过程中，可能某个条件得不到满足，把得不到满足资源的线程挂起，就挂在条件变量变量上，根据条件个数来确定条件变量。</p><p><img src="/img/mac/image-20220317102204705.png" alt="image-20220317102204705"></p><p>进入管程是互斥的，需要 lock，所以用了进入队列 entry lock。</p><p>圆柱体代表着操作共享变量的函数，x 和 y 是条件变量，条件变量也有自己的等待队列。</p><p>对条件变量有 wait 和 signal 操作</p><p><img src="/img/mac/image-20220317102429558.png" alt="image-20220317102429558"></p><p>条件变量的实现以及条件变量的两个方法</p><p><img src="/img/mac/image-20220317102751076.png" alt="image-20220317102751076"></p><p>schedule 是选择 ready 状态的线程去执行</p><p>为什么要先 release 再 require？后面再说</p><p>wakeup 是把 sleep 的线程改为 ready 状态</p><p>我们再用管程来解决生产消费</p><p><img src="/img/mac/image-20220317103149857.png" alt="image-20220317103149857"></p><p>notFull 和 not empty 是两个条件变量</p><p>count 表示 buffer 的大小</p><p><img src="/img/mac/image-20220317104010327.png" alt="image-20220317104010327"></p><p>先看生产者，当 buffer 满了之后，我们将 lock 传入 wait 方法，先释放一次锁，让其他线程先来执行（不能让这个线程带着锁去等待 c），当它再次得到锁之后（notfull.singal)，依旧会在生产者的 while 里继续判断 count==n；</p><p>消费者这边也是一样的</p><p><img src="/img/mac/image-20220317104330558.png" alt="image-20220317104330558"></p><p>再来看一个细节，当一个线程调用了条件变量的 signal 方法后，是直接让唤醒的线程直接执行，还是等待调用 signal 方法的线程执行完毕后再执行</p><p>hoare 方法，让唤醒的线程直接去执行</p><p>hansen，让调用 signal 的执行完毕后再去执行那个被唤醒的线程</p><p><img src="/img/mac/image-20220317104818593.png" alt="image-20220317104818593"></p><p>if 还是 while</p><p><img src="/img/mac/image-20220317105211437.png" alt="image-20220317105211437"></p><p>因为 hansen 的实现方式可能导致唤醒的多个线程来抢占 cpu，导致 count 不为 n，所以要用 whiile 做判断</p><p>hoare</p><p>不需要多次判断 count==n，因为执行 signal 后就去执行唤醒的线程了，但是在执行 signal 之前一定会执行 count–</p><h2 id="同步互斥基本总结"><a href="#同步互斥基本总结" class="headerlink" title="同步互斥基本总结"></a>同步互斥基本总结</h2><p>信号量和管程</p><p><img src="/img/mac/image-20220317105659276.png" alt="image-20220317105659276"></p><p><img src="/img/mac/image-20220317105708144.png" alt="image-20220317105708144"></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h3><p><img src="/img/mac/image-20220317110148346.png" alt="image-20220317110148346"></p><p><img src="/img/mac/image-20220317110317695.png" alt="image-20220317110317695"></p><p>读者优先：如果有人在读，又有人想写，写的人等着；当有人在读时，如果后面的读者想进来，也可以进来</p><p>Rcount 位读者的数量，写者始终只有一个</p><p>semwait 就是 p，sempost 就是 v</p><p>读者优先的实现：</p><p><img src="/img/mac/image-20220317111345352.png" alt="image-20220317111345352"></p><p><img src="/img/mac/image-20220317111518383.png" alt="image-20220317111518383"></p><p>如何实现写者优先？读者需要给两种写者让步，一种是正在执行写操作的写者，另一种是在等待队列中的写者，只要这两者都不存在，读者才能进入。</p><p><img src="/img/mac/image-20220317114116923.png" alt="image-20220317114116923"></p><p><strong>上面用的是信号量，这里用管程实现</strong></p><p><img src="/img/mac/image-20220317114326780.png" alt="image-20220317114326780"></p><p>伪代码 写优先</p><p><img src="/img/mac/image-20220317114655209.png" alt="image-20220317114655209"></p><p>具体实现</p><p><img src="/img/mac/image-20220317114940338.png" alt="image-20220317114940338"></p><p>有 writer 存在，就不能进行读。这是同时判断了 aw 和 ww，体现了写者优先。</p><p>确保 ar=0，再去判断 wait writer 以及唤醒写者 体现可以有多个读者同时读；而写者要等到没有人在读或者写的时候才能进行写</p><p><img src="/img/mac/image-20220317115221895.png" alt="image-20220317115221895"></p><p>写者的实现</p><p><img src="/img/mac/image-20220317115556400.png" alt="image-20220317115556400"></p><p>具体代码</p><p><img src="/img/mac/image-20220317115649853.png" alt="image-20220317115649853"></p><p>先判断等待的 writer，在判断等待的 reader，这里还用的是 broadcast 广播。</p><p><img src="/img/mac/image-20220317120026581.png" alt="image-20220317120026581"></p><h3 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h3><p>五个人吃饭，一个人吃饭要两把叉子，总共五把叉子</p><p><img src="/img/mac/image-20220317174222615.png" alt="image-20220317174222615"></p><p><img src="/img/mac/image-20220317174318786.png" alt="image-20220317174318786"></p><p>基本的想法，但是是错的。</p><p>如果五个人同步执行，都执行了第二条语句，都准备执行第三个的时候就发生了死锁。</p><p>再进一步呢？我们加个判断</p><p><img src="/img/mac/image-20220317174628338.png" alt="image-20220317174628338"></p><p>依旧有问题：</p><p>还是五把叉子一起拿起，一样有问题。</p><p>如果修改了每个人的等待时间</p><p><img src="/img/mac/image-20220317174918896.png" alt="image-20220317174918896"></p><p>虽然可行，但是随机时间是不固定的，我们不能保证每个哲学家都能吃上饭，如果一个哲学家要等特别久，这样还是不理想。</p><p>如果我们给每个人吃饭操作都加上锁，虽然能解决，但是效率 很低。</p><p><img src="/img/mac/image-20220317175128757.png" alt="image-20220317175128757"></p><p>上面方案的缺点</p><p><img src="/img/mac/image-20220317175329645.png" alt="image-20220317175329645"></p><p>饥饿状态表明自己想要叉子（锁）</p><p><img src="/img/mac/image-20220317175636002.png" alt="image-20220317175636002"></p><p><img src="/img/mac/image-20220317175920030.png" alt="image-20220317175920030"></p><p><img src="/img/mac/image-20220317180158687.png" alt="image-20220317180158687"></p><p><img src="/img/mac/image-20220317184840176.png" alt="image-20220317184840176"></p><p>哲学家的运行的函数：</p><p><img src="/img/mac/image-20220317185151704.png" alt="image-20220317185151704"></p><p>拿叉子的函数 takeforks 的具体实现：</p><p><img src="/img/mac/image-20220317185524459.png" alt="image-20220317185524459"></p><p>state 的赋值和拿叉子需要锁来保护</p><p>再进一步：拿两把叉子的具体操作</p><p>当我处于 hungry 并且左右邻居都没在吃饭</p><p>我就可以拿两把叉子了，<strong>并且这里通知我自己可以吃饭了</strong>，后面还会有另外的场景来调用这个函数，就是另外一种情形。</p><p><img src="/img/mac/image-20220317185722120.png" alt="image-20220317185722120"></p><p>putforks 具体操作</p><p><img src="/img/mac/image-20220317190723521.png" alt="image-20220317190723521"></p><p>这里就复用了上面的代码</p><p>自己吃完饭后判断左右邻居是能否吃饭，如果可以的话，就把它们给唤醒，并且把叉子给他们。</p><p><img src="/img/mac/image-20220317191007531.png" alt="image-20220317191007531"></p><p>eat（）其实不需要了，因为拿到叉子后已经变成了 eat 状态，think（）可以用作初始化使用。</p><p>伪代码 - 数据结构 - 定义各种变量 - 代码撰写，我们同步问题的这一章基本就是这样的流程，来解决同步互斥问题。</p><h1 id="第-11-课-死锁和进程间通信"><a href="#第-11-课-死锁和进程间通信" class="headerlink" title="第 11 课 死锁和进程间通信"></a>第 11 课 死锁和进程间通信</h1><p>大纲</p><p><img src="/img/mac/image-20220317191537025.png" alt="image-20220317191537025"></p><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>我们把行车道理解成一种资源</p><p><img src="/img/mac/image-20220317191623604.png" alt="image-20220317191623604"></p><p>车的倒退就是一种释放资源的过程。</p><p><img src="/img/mac/image-20220317191813441.png" alt="image-20220317191813441"></p><p>死锁的出现是在并发的基础之上的。</p><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p><img src="/img/mac/image-20220317192032401.png" alt="image-20220317192032401"></p><p>进程对资源有三种情况，请求，持有，释放。资源对应的状态时空闲，正在使用，空闲。</p><p>有关资源：</p><p><img src="/img/mac/image-20220317192312399.png" alt="image-20220317192312399"></p><p>如果一个进程拥有一个资源并且请求其他资源，就有可能发生死锁。</p><p>一般来说，一个进程的资源得不到满足，他就会进入 blocked 状态</p><p>我们用一个有向图来表示资源分配图</p><p><img src="/img/mac/image-20220317192837756.png" alt="image-20220317192837756"></p><p><img src="/img/mac/image-20220317192919075.png" alt="image-20220317192919075"></p><p>举个例子</p><p>r2 中有两个资源实例，一个给了 p1，一个给了 p2.</p><p>p1 请求 r1 资源但是无法得到满足，因为 r1 资源已经给 p2 占用了。</p><p><img src="/img/mac/image-20220317193159445.png" alt="image-20220317193159445"></p><p>虽然这里有进程的 sleep，但是没有产生死锁。</p><p>我们更进一步，看看</p><p><img src="/img/mac/image-20220317193522806.png" alt="image-20220317193522806"></p><p>图中有一个 p1 到 p3 的大环，有 p2 到 p3 的小环。这里有死锁存在。因为三个线程最后都会 sleep，互相等待对方释放资源。</p><p>另一种情况</p><p><img src="/img/mac/image-20220317193854353.png" alt="image-20220317193854353"></p><p>p2 运行一段时间后会释放 r1 的实例，打破 p1 和 p3 的“死锁”。</p><p>小总结</p><p><img src="/img/mac/image-20220317194052621.png" alt="image-20220317194052621"></p><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p><img src="/img/mac/image-20220317194436628.png" alt="image-20220317194436628"></p><p>循环等待其实就是上面所说的环</p><p>上面所介绍的是必要条件，并不是说这四个条件会产生死锁。</p><h2 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h2><p><img src="/img/mac/image-20220317194724955.png" alt="image-20220317194724955"></p><p>约束从上往下递减。</p><p><img src="/img/mac/image-20220317194936376.png" alt="image-20220317194936376">判断出现死锁的开销挺大的，所以有的操作系统干脆忽略死锁。</p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>就是让死锁不出现。</p><p>只要把死锁出现之后的四个条件之一打破，就可以预防死锁。</p><p><img src="/img/mac/image-20220317195216164.png" alt="image-20220317195216164"></p><p>如果互斥不满足，会带来不确定性问题，不好。</p><p>占用并等待：极端一点，如果每个进程要 hold 所有的资源才能运行，这样虽然可以运行，但是饥饿现象非常明显。</p><p><img src="/img/mac/image-20220317195613561.png" alt="image-20220317195613561"></p><p>要让无抢占不执行，只能把对应的进程 kill 掉让他释放资源。</p><p>将循环等待打破是可行的，将资源类型排序，。。。</p><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>进程获取资源前先进行判断，如果有可能发生死锁，就不把资源给他。要进行这样的判断需要一些条件</p><p><img src="/img/mac/image-20220317200145674.png" alt="image-20220317200145674"></p><p>进程先确定自己需要的资源数量和大小等等，如果超出了自己的需求，系统就可以不给他分配资源。</p><p>动态检查进程获取资源后是否可能出现环，如果会出现就不给其分配资源</p><p><img src="/img/mac/image-20220317200750121.png" alt="image-20220317200750121"></p><p>安全序列：一个进程一定能够等到他所需要的资源从而顺利结束。就是对于一个进程 pi ， 他所需的资源可以由 p0 到 pi-1 所拥有的资源满足。</p><p><img src="/img/mac/image-20220317201345547.png" alt="image-20220317201345547"></p><p><img src="/img/mac/image-20220317201436043.png" alt="image-20220317201436043"></p><p>虚线表示进程所需要的资源。</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>简单点 说就是银行贷款钱一定要收的回来，如果钱没法回来，就不给他钱。<img src="/img/mac/image-20220318085930854.png" alt="image-20220318085930854"></p><p><img src="/img/mac/image-20220318090131091.png" alt="image-20220318090131091"></p><p>寻找我们前面所说的 safe 序列</p><p><img src="/img/mac/image-20220318090625347.png" alt="image-20220318090625347"></p><p>max 矩阵：pi 需要资源 rj 的资源个数</p><p>available</p><p>allocation：pi 已有资源 rj 的个数</p><p>need ： pi 未来可能需要资源 rj 的个数</p><p>need= max - allocationa</p><p><img src="/img/mac/image-20220318091205552.png" alt="image-20220318091205552"></p><p>finish i = true 表示进程的资源可以得到满足，并且正常结束</p><p>如果 need i 的每一个资源都小于 work</p><p>这个进程就能正常结束</p><p>这个进程正常结束后，这个进程所拥有的资源全部释放，转给 work</p><p>上述为判断安全的算法，我们接下来以他为基础来构建银行家算法</p><p><img src="/img/mac/image-20220318091620719.png" alt="image-20220318091620719"></p><p>举个例子</p><p><img src="/img/mac/image-20220318091952493.png" alt="image-20220318091952493"></p><p><img src="/img/mac/image-20220318092008662.png" alt="image-20220318092008662"></p><p>首先找一个进程所需资源 need&lt;available</p><p>找到了 p2，所以把 p2 的 allocate 还给 available</p><p>接着，我们可以选择 p1，流程和上面是一样的。继续实现下去我们就能得到一个 safe 序列。</p><p>另一个例子</p><p>如果 available 原先是 112，p1 发起一次 101 的资源获取请求之后变成这样</p><p><img src="/img/mac/image-20220318092724846.png" alt="image-20220318092724846"></p><p>这时候没有一个进程的资源能够得到满足，说明这是一个 unsafe 队列，我们的银行家算法不会满足这次 p1 的资源请求</p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>和上面的死锁避免相比，我们的条件再次放宽</p><p><img src="/img/mac/image-20220318092934188.png" alt="image-20220318092934188"></p><p>可以死锁，死锁后将其查出来。</p><p>我们对上面的资源分配图简化一下，变成进程等待图</p><p><img src="/img/mac/image-20220318093106060.png" alt="image-20220318093106060"></p><p><img src="/img/mac/image-20220318093132432.png" alt="image-20220318093132432"></p><h4 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h4><p><img src="/img/mac/image-20220318093343953.png" alt="image-20220318093343953"></p><p>我们一般很少使用银行家算法和死锁检测算法，一个是系统很难知道每个进程所需要的资源总数，一个是死锁检测开销很大。</p><p><img src="/img/mac/image-20220318094441978.png" alt="image-20220318094441978"></p><p>available 初始值为 000</p><p>safe 队列的顺序是 p0 p2 p1 p3 p4</p><p>有可能出现死锁的情况</p><p><img src="/img/mac/image-20220318094541898.png" alt="image-20220318094541898"></p><p><img src="/img/mac/image-20220318094911813.png" alt="image-20220318094911813"></p><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>如果已经发生死锁了，看下如何解决</p><p>一般是 kill 一个进程，判断的依据如下</p><p><img src="/img/mac/image-20220318095031507.png" alt="image-20220318095031507"></p><p><img src="/img/mac/image-20220318095246411.png" alt="image-20220318095246411"></p><p>正常操作系统一般都是用鸵鸟办法，就是不管死锁，出现了就 reboot</p><h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h2><p><img src="/img/mac/image-20220318095606638.png" alt="image-20220318095606638"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/img/mac/image-20220318095722807.png" alt="image-20220318095722807"></p><p>间接通信和直接通信</p><p><img src="/img/mac/image-20220318095809696.png" alt="image-20220318095809696"></p><p>左边类似于发邮件，邮件先投递到邮局，再转交。</p><p><img src="/img/mac/image-20220318095918007.png" alt="image-20220318095918007"></p><p>通信链路的建立需要操作系统来完成</p><p><img src="/img/mac/image-20220318100018653.png" alt="image-20220318100018653"></p><p><img src="/img/mac/image-20220318100111196.png" alt="image-20220318100111196"></p><p>从发送的路径来看可以分为直接和间接</p><p>阻塞，发消息的时候发送者进入 block，知道消息被接受；接受时，接受者阻塞直到这个消息是 available 的</p><p>非阻塞，sender 发送消息并且能持续执行；</p><p><img src="/img/mac/image-20220318100249506.png" alt="image-20220318100249506"></p><p>通信链路缓冲</p><p>发送的数据有一个缓存，当缓存的容量有三种以下情况</p><p><img src="/img/mac/image-20220318100616756.png" alt="image-20220318100616756"></p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>signal 类似于硬件的中断机制，由软件打断当前正在运行的应用程序</p><p><img src="/img/mac/image-20220318100932053.png" alt="image-20220318100932053"></p><p>catch：产生哪个信号，做哪种响应</p><p>信号一般只起通知作用，不传输数据。</p><p>具体实现</p><p><img src="/img/mac/image-20220318101523946.png" alt="image-20220318101523946"></p><p>应用程序先注册针对某个信号的 handle 给 os，当产生对应的信号后，会让该应用程序调用对应的信号处理函数；</p><p>当 os 收到信号时，他运行在内核态；当要返回用户态去执行相应信号的那个应用程序时，他返回的点是调用信号处理函数的地方，这是通过修改应用程序的调用堆栈实现的。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是用来数据交换的，是很早的进程间通信机制。</p><p>其实很像 linux 的管道符</p><p>把管道符前面的结果作为管道符后面的输入</p><p>把输出重定向为管道，不是原来的 stdout</p><p><img src="/img/mac/image-20220318102720762.png" alt="image-20220318102720762"></p><p>管道实际上就是内核中的一个 buffer</p><p>shell 是 ls 和 more 的父进程，子进程可以继承一些父进程的资源</p><p>​</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>和管道的区别</p><p>管道其实是父进程帮子进程建立好的通道</p><p>如果没有父子关系，就无法正常运作。</p><p>管道里的数据是一种字节流，没有结构化的表示形式。</p><p>这两种在消息队列里都可以解决</p><p>没有父子关系，字符流等等。。。</p><p><img src="/img/mac/image-20220318103559456.png" alt="image-20220318103559456"></p><h3 id="共享空间"><a href="#共享空间" class="headerlink" title="共享空间"></a>共享空间</h3><p>操作系统创建的共享区域，每个进程都可以读和写，但是需要同步互斥来保证其安全性。</p><p><img src="/img/mac/image-20220318103707853.png" alt="image-20220318103707853"></p><p><img src="/img/mac/image-20220318103942389.png" alt="image-20220318103942389"></p><p>不同的逻辑地址映射同一块物理地址空间。</p><h1 id="第十二课-文件系统"><a href="#第十二课-文件系统" class="headerlink" title="第十二课 文件系统"></a>第十二课 文件系统</h1><p><img src="/img/mac/image-20220318105155526.png" alt="image-20220318105155526"></p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/img/mac/image-20220318105337112.png" alt="image-20220318105337112"></p><h3 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h3><p>定义</p><p><img src="/img/mac/image-20220318105918029.png" alt="image-20220318105918029"></p><p>很多地方都存在文件系统；存储的最小粒度都是文件。创建、删除、读写的也都是文件。</p><p>硬盘眼中的文件</p><p><img src="/img/mac/image-20220318110131277.png" alt="image-20220318110131277"></p><p>文件和块</p><p><img src="/img/mac/image-20220318110346598.png" alt="image-20220318110346598"></p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p><img src="/img/mac/image-20220318110513636.png" alt="image-20220318110513636"></p><p>文件使用模式：这个 f 就是文件描述符，是一个整数。也是打开文件表的索引。</p><p><img src="/img/mac/image-20220318110749255.png" alt="image-20220318110749255"></p><p>文件打开计数：只有没有进程在使用文件时，才能把文件从内存中抹去。</p><p>访问权限：每个程序对这个文件是只读还是其他的。</p><p><img src="/img/mac/image-20220318111130240.png" alt="image-20220318111130240"></p><p>磁盘访问的基本单位是一个扇区</p><p><img src="/img/mac/image-20220318111402627.png" alt="image-20220318111402627"></p><p>用户看到的是一个抽象的一维空间，操作系统看到的是一个个块。</p><p><img src="/img/mac/image-20220318111457035.png" alt="image-20220318111457035"></p><p>文件结构</p><p><img src="/img/mac/image-20220318111908089.png" alt="image-20220318111908089"></p><p>这些结构由应用程序来识别，操作系统只以一种简洁的/统一的方式来理解他们（一串普通的字节流)</p><p>访问控制</p><p>linux 读写执行等等</p><p><img src="/img/mac/image-20220318112110916.png" alt="image-20220318112110916"></p><p>语义</p><p>一个用户对用户的写入对其他人是否可见</p><p><img src="/img/mac/image-20220318112505107.png" alt="image-20220318112505107"></p><p>确保写同一块内容有同步互斥机制。</p><p>锁：以文件为锁，或者以文件的某一块作为锁，可以有不同粒度的实现。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="/img/mac/image-20220318112853605.png" alt="image-20220318112853605"></p><p>对目录有哪些操作</p><p><img src="/img/mac/image-20220318112953652.png" alt="image-20220318112953652"></p><p>目录里的文件怎么存？</p><p>数组/链表/hash</p><p><img src="/img/mac/image-20220318113125505.png" alt="image-20220318113125505"></p><p>路径遍历</p><p><img src="/img/mac/image-20220318113203969.png" alt="image-20220318113203969"></p><p>挂载</p><p><img src="/img/mac/image-20220318113457887.png" alt="image-20220318113457887"></p><p>不同类型的文件系统要挂在不同的目录。挂载点在用户看来是一个目录，代表了根的起始位置。</p><h3 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h3><p><img src="/img/mac/image-20220318113943889.png" alt="image-20220318113943889"></p><p>软连接：一个文件的内容存的是另一个文件的路径名</p><p><img src="/img/mac/image-20220318114246021.png" alt="image-20220318114246021"></p><p>删除了一个有别名的文件 yinyong，只是他的文件引用数量减少了 1，并没有完全删除，这种方式可以用 backpointers 来实现。</p><p>潜在风险</p><p><img src="/img/mac/image-20220318114811727.png" alt="image-20220318114811727"></p><h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><p><img src="/img/mac/image-20220318144114875.png" alt="image-20220318144114875"></p><p>日志文件系统：保证内容一致性的问题，防止因掉电而丢失数据等。如 mysql 的 redolog 和 undolog。</p><p>其他文件系统没有过多的深入了解。</p><p>想更多的了解可以查看维基百科。</p><p>分布式文件系统</p><p><img src="/img/mac/image-20220318144733701.png" alt="image-20220318144733701"></p><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>站在实现的角度来理解文件系统</p><p><img src="/img/mac/image-20220318145038802.png" alt="image-20220318145038802"></p><p>屏蔽应用程序对不同的文件系统的差异性，只提供了文件系统 api，这些 api 其实就是简单的 read write ， 但是应用程序看到这些就足够了。</p><p>另一个角度，文件系统有可能是不同的形式，如 network io，虽然底层存在差异，但是通过虚拟文件系统，可以屏蔽这些不一致。</p><p><img src="/img/mac/image-20220318145640781.png" alt="image-20220318145640781"></p><p>文件系统、文件、目录的元数据</p><p><img src="/img/mac/image-20220318150037321.png" alt="image-20220318150037321"></p><p><img src="/img/mac/image-20220318150235386.png" alt="image-20220318150235386"></p><p>三个块都会映射到磁盘中的扇区</p><p><img src="/img/mac/image-20220318150337122.png" alt="image-20220318150337122"></p><p>我们什么时候把文件系统加载到内存中？</p><p><img src="/img/mac/image-20220318150427738.png" alt="image-20220318150427738"></p><h2 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h2><p>把常用的数据缓冲到内存，加快查询速度。</p><p><img src="/img/mac/image-20220318150715435.png" alt="image-20220318150715435"></p><p><img src="/img/mac/image-20220318150849097.png" alt="image-20220318150849097"></p><p>类似于页替换算法</p><p><img src="/img/mac/image-20220318151007899.png" alt="image-20220318151007899"></p><h2 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h2><p>把文件控制块的内容读到内存中</p><p>根据 f= read（），找到对应的文件表</p><p><img src="/img/mac/image-20220318151306935.png" alt="image-20220318151306935"></p><p>找到对应的文件后，根据一个 offset，来确定要对文件中的哪一块进行读或者写。</p><p>offset 经过转换变成 disk 的一个扇区内的编号，文件系统把具体的数据读到内存中来。</p><p><img src="/img/mac/image-20220318151731931.png" alt="image-20220318151731931"></p><p>一些保护机制</p><p><img src="/img/mac/image-20220318151811608.png" alt="image-20220318151811608"></p><h2 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h2><p><img src="/img/mac/image-20220318151935490.png" alt="image-20220318151935490"></p><p><img src="/img/mac/image-20220318152020907.png" alt="image-20220318152020907"></p><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p><img src="/img/mac/image-20220318152131908.png" alt="image-20220318152131908"></p><p>如果要对文件做扩展，而后面已经有文件了，那开销挺大。</p><p>分配策略可以参考内存的最佳适配，最差适配，首次适配等等。</p><h3 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h3><p><img src="/img/mac/image-20220318152643126.png" alt="image-20220318152643126"></p><p>不能高效的进行随机访问。</p><h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>指向这些文件的数据放在哪个索引数据块</p><p><img src="/img/mac/image-20220318152833224.png" alt="image-20220318152833224"></p><p>大文件的索引分配</p><p>将索引分级等</p><p><img src="/img/mac/image-20220318153053760.png" alt="image-20220318153053760"></p><p>早期 unix 的索引分级</p><p><img src="/img/mac/image-20220318153314140.png" alt="image-20220318153314140"></p><p><img src="/img/mac/image-20220318153338618.png" alt="image-20220318153338618"></p><h2 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h2><p><img src="/img/mac/image-20220318153648848.png" alt="image-20220318153648848"></p><p>安全性的保证</p><p><img src="/img/mac/image-20220318153824536.png" alt="image-20220318153824536"></p><p>其他形式：</p><p><img src="/img/mac/image-20220318153925945.png" alt="image-20220318153925945"></p><h2 id="多磁盘管理"><a href="#多磁盘管理" class="headerlink" title="多磁盘管理"></a>多磁盘管理</h2><p><img src="/img/mac/image-20220318154232176.png" alt="image-20220318154232176"></p><p><img src="/img/mac/image-20220318154349159.png" alt="image-20220318154349159"></p><p><img src="/img/mac/image-20220318154517682.png" alt="image-20220318154517682"></p><p>软 raid，操作系统位于磁盘之上进行磁盘管理。</p><p>硬 raid，将磁盘管理置入芯片中。</p><p>Raid0:</p><p><img src="/img/mac/image-20220318154844102.png" alt="image-20220318154844102"></p><p>把不同的数据放在不同的硬盘上，把这些数据并行的读取出来。</p><p>raid1:</p><p><img src="/img/mac/image-20220318154947692.png" alt="image-20220318154947692"></p><p>Raid4:</p><p><img src="/img/mac/image-20220318155130911.png" alt="image-20220318155130911"></p><p>用四个盘来进行并行，用一个盘来进行故障恢复。</p><p>瓶颈：故障恢复盘的读写非常频繁。</p><p>raid5:</p><p>保证了高可靠性，还提高了效率。</p><p>将奇偶校验分散到每个盘中</p><p><img src="/img/mac/image-20220318155431242.png" alt="image-20220318155431242"></p><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p><img src="/img/mac/image-20220318155827444.png" alt="image-20220318155827444"></p><p><img src="/img/mac/image-20220318155950645.png" alt="image-20220318155950645"></p><p>访问时间 = 寻道时间+旋转延迟时间+数据访问时间</p><p><img src="/img/mac/image-20220318160226944.png" alt="image-20220318160226944"></p><p>随机 io 效率很低，因为要不停的寻道</p><p>fifo 的磁盘访问</p><p><img src="/img/mac/image-20220318160422893.png" alt="image-20220318160422893"></p><p>简单，但是效率低</p><p><img src="/img/mac/image-20220318160518959.png" alt="image-20220318160518959"></p><p>短服务优先</p><p><img src="/img/mac/image-20220318160553156.png" alt="image-20220318160553156"></p><p>有可能导致饥饿现象，让磁头在一小块区域打转，有不公平性</p><p>电梯</p><p>磁头走到头，再走到尾</p><p><img src="/img/mac/image-20220318160750317.png" alt="image-20220318160750317"></p><p>上面是两种方向，优化成仅在一种方向上扫描</p><p><img src="/img/mac/image-20220318160956174.png" alt="image-20220318160956174"></p><p>走到一条路上最后的请求点</p><p><img src="/img/mac/image-20220318161130204.png" alt="image-20220318161130204"></p><p><img src="/img/mac/image-20220318161255596.png" alt="image-20220318161255596"></p><p><img src="/img/mac/image-20220318161355144.png" alt="image-20220318161355144"></p><p>理解就好，实际情况跟这些完全不一样。</p><div class="code-wrapper"><pre><code class="hljs">1. *</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2022/03/11/hello-world/"/>
    <url>/2022/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>本人是一位大三的在读生，正在学习后端知识。</p><h2 id="学习-amp-生活"><a href="#学习-amp-生活" class="headerlink" title="学习 &amp; 生活"></a>学习 &amp; 生活</h2><h3 id="3-11-第一篇-blog"><a href="#3-11-第一篇-blog" class="headerlink" title="3.11 第一篇 blog"></a>3.11 第一篇 blog</h3><p>看着不少大佬都有了自己的博客，今天脑子一热也捣鼓了一个，目前没有好好打理的想法，权当成自己的笔记仓库把</p><!-- ### 3.12今天学习了 jvm 中类的加载过程，加载-连接（验证、准备、解析）-初始化阶段，以及类加载器，双亲委派机制以及源码；还学习了运行期的优化如即时编译的逃逸分析，解释器和 JIT、方法内联；还有反射优化里的膨胀阈值。简单复习了优先队列（小顶堆和大顶堆）的使用，对应的刷了 LeetCode。### 3.13今天有事耽搁了，只有晚上学了一会。总的来说就是学了 JMM 内存模型。理解了原子性、可见性、有序性的问题产生(JIT 和高速缓存，指令重排)和对应的解决方法(synchronized、volatile)。笼统的看了 CAS 与原子类，简单了解了其实现。了解了 synchronized 在 jdk6 之后的优化，轻量级锁、重量级锁、偏向锁。轻量级锁的锁膨胀，重量级锁自旋，偏向锁的优缺点。JVM 到此就结束了，过几天将笔记整理完毕后会发到 blog 上。明天开始学习 OS。### 3.14&3.153.14 没更，放到今天一起总结。这两天猛攻操作系统，学了操作系统的基本介绍，操作系统分别对程序和硬件"打交道"的方式-中断、系统调用和异常，操作系统如何管理物理内存。管理内存是个大章节，由浅入深的学了地址空间和地址生成（逻辑地址和物理地址），地址的安全检查机制，连续内存分配的三种基本算法，分配后产生的内外碎片的处理机制（压缩式、交换式碎片整理）。 非连续内存管理-分段、分页，操作系统专门生成对应的段表，页表。 基于分页分段的非连续内存管理，又学习了虚拟内存。虚拟内存中，页面的置换又有多种算法。关于页面的置换，局部页面置换学了 FIFO、LRU、CLOCK、基于 CLOCK 的二次机会法、LFU、Belady 现象，这些是在一个进程中进行的，对于全局页面置换算法，深入了解了工作集页置换算法、缺页率页面置换算法、抖动现象。最后给进程管理开了个头，包括进程的定义、组成、特点、PCB。。。具体内容再展开就太多了。LeetCode 这两天复习的是树，树的复习大概会持续一周这样。over -->]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
