<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Synchronized 关键字</title>
    <link href="/2022/05/18/Synchronized/"/>
    <url>/2022/05/18/Synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><h2 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h2><p>假设以 obj 对象作为锁</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">synchronized</span>(obj) &#123;<br> <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>obj 对象在同一时间只与一个 monitor(锁)相关联，而一个 monitor 在同一时间只能被一个线程获得。</p><p>任意线程对 obj 的访问，首先要获得 obj 的监视器。如果获取失败，当前线程就进入了 BLOCKED 阻塞状态，即进入了一个同步队列 SynchronizedQueue。当收到 Monitor Exit 通知后，出队列。</p><h2 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h2><p>每个 Monitor 中有一个计数器，如果当前已获得 Monitor 锁的线程再次执行 Monitor Enter 指令，则计数 +1。</p><p>释放锁后，计数 -1。</p><h2 id="JVM-中锁的优化"><a href="#JVM-中锁的优化" class="headerlink" title="JVM 中锁的优化"></a>JVM 中锁的优化</h2><h3 id="Java-中锁的类型"><a href="#Java-中锁的类型" class="headerlink" title="Java 中锁的类型"></a>Java 中锁的类型</h3><p><code>无锁</code> <code>偏向锁</code> <code>轻量级锁</code> <code>重量级锁</code></p><p>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</p><h3 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>线程挂起和恢复需要转入内核态进行操作，这对性能有较大的影响。</p><p>Synchronized 没有获取到锁时，不是马上将当前线程挂起，而是自旋等待锁的释放。</p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>更加灵活的更改自旋的时间。</p><p>如果自旋等待刚刚成功获取过锁，那么 JVM 会认为该锁自旋获取到锁的可能性较大，会自动的增加等待时间。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>虚拟机即时编译器运行时，对一些代码上要求了同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>即使没有线程竞争，频繁的对同一对象反复加锁和解锁也会导致性能降低。</p><p>JVM 会将加锁同步的范围扩展到一系列操作的外部。减少加锁的次数。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>在 JDK 1.6 之后引入的轻量级锁，目的是对在大多数情况下同步块并不会有竞争出现提出的一种优化。</p><p>在对象头中(<code>Object Header</code>)存在两部分。第一部分用于存储对象自身的运行时数据，<code>HashCode</code>、<code>GC Age</code>、<code>锁标记位</code>、<code>是否为偏向锁</code>。等。一般为 32 位或者 64 位(视操作系统位数定)。官方称之为<code>Mark Word</code>，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(<code>Klass Point</code>)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。</p><h4 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h4><p>在线程执行同步块之前，JVM 会在栈帧中创建一个<code> Lock Record</code> 。</p><p>如果 CAS 操作将对象头中的标志位 <code>01</code> 改为 <code>00</code> 成功，<code>Lock Record</code> 会拷贝锁对象目前的 <code>Mark Word</code> ，锁对象的 <code>Mark Word</code> 更新为指向 <code>Lock Record</code> （栈帧）的指针。同时将对象头中的锁标记位改为 <code>00</code> ，表示轻量级锁。</p><p>如果这个 CAS 操作失败了，JVM 会检查对象头中的 <code>Mark Word</code> 是否存在指向当前线程的栈帧的指针，如果存在则说明该锁已经被获取，可以直接调用。如果不存在，说明当前有两个或以上的线程竞争同一把锁，轻量级锁升级为重量级锁，对象头中的 <code>Mark Word</code> 指向重量级锁的指针。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>背景：抹掉 <code>同一个线程</code> 反复获取锁和释放锁带来的性能开销。</p><p>总是偏向第一个获取锁对象的线程。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁。只需要简单的测试一下对象头的<code>Mark Word</code>里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p>在 Mark Word 中倒数第三位为标志位 ……101</p>]]></content>
    
    
    <categories>
      
      <category>原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用 Git 指令</title>
    <link href="/2022/05/09/git-pro/"/>
    <url>/2022/05/09/git-pro/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Git 指令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA 在 Windows &amp; Mac 下的快捷键</title>
    <link href="/2022/05/09/idea-properties/"/>
    <url>/2022/05/09/idea-properties/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-下的快捷键"><a href="#Windows-下的快捷键" class="headerlink" title="Windows 下的快捷键"></a>Windows 下的快捷键</h1><ul><li><p>ctrl + N 查找类</p></li><li><p>alt + 7 查看当前类的属性以及方法。</p></li><li><p>ctrl+D 复制粘贴当前行</p></li><li><p>ctrl + / 快速注释</p></li><li><p>ctrl + P 查看括号内的参数</p></li><li><p>ctrl + O 快速重写方法</p></li><li><p>ctrl + R 替换</p></li><li><p>ctrl + H 查找继承结构</p></li><li><p>ctrl + Alt + T 快速生成包围代码块</p></li><li><p>Alt + Shift + ↑ IDEA 上下移动一行</p></li><li><p>ctrl + Y 删除一行</p></li><li><p>ctrl + alt + L 对选中代码进行格式化</p></li><li><p>ctrl + F 查找</p></li><li><p>ctrl + F12 查看当前类的所有方法</p></li><li><p>在注解类中，按 Alt + 7 , 可以查看注解类拥有哪些属性</p></li><li><p>在接口中按 ctrl+shift+T , 可以进行代码的测试 test 工作</p></li></ul><h1 id="Mac-下的快捷键"><a href="#Mac-下的快捷键" class="headerlink" title="Mac 下的快捷键"></a>Mac 下的快捷键</h1>]]></content>
    
    
    <categories>
      
      <category>快捷键</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小小的笔记仓库</title>
    <link href="/2022/03/11/hello-world/"/>
    <url>/2022/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="学习-amp-生活"><a href="#学习-amp-生活" class="headerlink" title="学习 &amp; 生活"></a>学习 &amp; 生活</h2><h3 id="3-11-第一篇-blog"><a href="#3-11-第一篇-blog" class="headerlink" title="3.11 第一篇 blog"></a>3.11 第一篇 blog</h3><p>照着官方文档搭建的小网站，没有什么写文章的想法，先当做自己的笔记仓库~</p><!-- ### 3.12今天学习了 jvm 中类的加载过程，加载-连接（验证、准备、解析）-初始化阶段，以及类加载器，双亲委派机制以及源码；还学习了运行期的优化如即时编译的逃逸分析，解释器和 JIT、方法内联；还有反射优化里的膨胀阈值。简单复习了优先队列（小顶堆和大顶堆）的使用，对应的刷了 LeetCode。### 3.13今天有事耽搁了，只有晚上学了一会。总的来说就是学了 JMM 内存模型。理解了原子性、可见性、有序性的问题产生(JIT 和高速缓存，指令重排)和对应的解决方法(synchronized、volatile)。笼统的看了 CAS 与原子类，简单了解了其实现。了解了 synchronized 在 jdk6 之后的优化，轻量级锁、重量级锁、偏向锁。轻量级锁的锁膨胀，重量级锁自旋，偏向锁的优缺点。JVM 到此就结束了，过几天将笔记整理完毕后会发到 blog 上。明天开始学习 OS。### 3.14&3.153.14 没更，放到今天一起总结。这两天猛攻操作系统，学了操作系统的基本介绍，操作系统分别对程序和硬件"打交道"的方式-中断、系统调用和异常，操作系统如何管理物理内存。管理内存是个大章节，由浅入深的学了地址空间和地址生成（逻辑地址和物理地址），地址的安全检查机制，连续内存分配的三种基本算法，分配后产生的内外碎片的处理机制（压缩式、交换式碎片整理）。 非连续内存管理-分段、分页，操作系统专门生成对应的段表，页表。 基于分页分段的非连续内存管理，又学习了虚拟内存。虚拟内存中，页面的置换又有多种算法。关于页面的置换，局部页面置换学了 FIFO、LRU、CLOCK、基于 CLOCK 的二次机会法、LFU、Belady 现象，这些是在一个进程中进行的，对于全局页面置换算法，深入了解了工作集页置换算法、缺页率页面置换算法、抖动现象。最后给进程管理开了个头，包括进程的定义、组成、特点、PCB。。。具体内容再展开就太多了。LeetCode 这两天复习的是树，树的复习大概会持续一周这样。over -->]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
